## 1. `this`

자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수로 JS엔진에 의해 암묵적으로 생성된다.

**`this` 바인딩**<br/>
식별자와 값을 연결하는 과정으로 **`this`** 라는 식별자와 **`this`** 가 가리키는 객체를 바인딩 하는 것. **`this`** 바인딩은 **함수 호출 방식에 따라 동적으로 결정**

**함수 호출 방식에 따른 `this` 바인딩**

| 함수 호출 방식                                             | this 바인딩                                                           |
| ---------------------------------------------------------- | --------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                             |
| 메서드 호출                                                | 메서드를 호출한 객체                                                  |
| 생성자 함수 호출(new 키워드를 붙여 함수 실행)              | 생성자 함수가 (미래에) 생성할 인스턴스                                |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫번째 인수로 전달한 객체 |
| 화살표 함수                                                | 상위 스코프에 바인딩 된 this에 바인딩                                 |
| addEventListener() 안에서 호출                             | 이벤트가 발생한 DOM 요소                                              |

<br/>

## 2. 클래스

**클래스란?** <br/>

- 클래스란 객체를 생성하기 위한 템플릿으로 객체의 상태나 행동을 정의한다.
- 클래스는 표현식으로 정의할 수 있기 때문에 일급 객체이다.

**[클래스 호이스팅](https://blinders.tistory.com/90)**<br/>
자바스크립트에서 클래스는 함수로 평가된다. 클래스 선언문은 문이기 때문에 **호이스팅이 발생하고** 런타임 이전 소스코드 평가되어 함수 객체와 프로토타입을 생성한다. 이때 생성되는 함수 객체는 **`constructor`** 이다. 호이스팅이 발생하고 소스코드가 평가되어 객체가 생성되지만 클래스는 정의이전에 참조할 수 없다. 객체가 가진 내부 메서드들은 new 연산자를 통해 인스턴스가 생성되었을 때 유효한 것이므로 클래스는 선언 이후에 사용가능하다.

**클래스는 프로토타입의 문법적 설탕인가?**<br/>
JS의 클래스는 프로토타입으로 구현되었기 때문에 클래스는 프로토타입의 문법 설탕이라는 의견이 있으며, 클래스를 사용할 경우 프로토타입을 사용하는 것보다 좀 더 많은 일이 내부적으로 일어나기 때문에 그렇지 않다는 의견 또한 존재한다.

**`new` 키워드란 ?**<br/>

- **`new`** 키워드를 사용해서 클래스를 호출해 객체를 생성할 수 있다.

- **`new`** 키워드를 사용해 생성된 객체는 **`constructor`** 을 호출하게 된다.

<br/>

## 3. 불변성

**불변성이란?**<br/>
새로운 값을 생성하지 않고는 내용을 변경할 수 없는 값

**[불변성의 이점](<https://github.com/FEDeepDive/Front-end/blob/uraflower/5.%20JavaScript(%EA%B0%9D%EC%B2%B4).md>)**

- 예측 가능한 코드 (변하지 않고 일관적인 상태를 가지므로)
- 메모리 효율 증가 (변하지 않는 만큼 메모리를 덜 잡아먹으니까)
- 안전한 병렬 처리 (여러 곳에 동시에 공유되어도 문제 없으니까)

**객체타입의 불변성을 유지하는법**

- **`Object.preventExtensions()`** : 객체의 확장, 프로퍼티 추가를 금지
- `**Object.seal()`** : **`Object.preventExtensions()`\*\* 의 특징을 포함, 이미 존재하는 속성 삭제 금지
- `**Object.freeze()` : `Object.seal()`\*\* 의 특징을 포함, 속성의 값 변경 금지
- 불변성 라이브러리 : **`Immer`**등의 불변성을 관리하기 위한 라이브러리 사용

<br/>

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

자바스크립트의 데이터 타입은 크게 **`원시타입`** 과 **`객체`** 로 구분됨

|             | 원시타입(Primitive Type)                                 | 객체(Object)                                                          |
| ----------- | -------------------------------------------------------- | --------------------------------------------------------------------- |
| 변경 가능성 | 변경 불가능(immutable)                                   | 변경 가능(mutable)                                                    |
| 저장 방식   | 실제 값이 저장                                           | 참조 값이 저장                                                        |
| 복사 방식   | call-by-value(값에 의한 전달)                            | https://uraflower.tistory.com/entry/Call-by-Sharing(공유에 의한 전달) |
| 예시        | number, string, boolean, undefined, null, symbol, bigint | 객체(function, array 포함)                                            |

<br/>

## 5. 프로토타입

프로토타입이란 자바스크립트가 객체지향을 지원하기 위해 채택한 방식으로  **자신의 원형(prototype)이 되는 객체**를 의미한다.

모든 객체는 프로토타입 객체를 가지며 프로토타입 객체로부터 메서드와 속성을 상속받아 사용 가능하다.

**프로토타입 체인**

특정 객체의 프로퍼티/메서드를 **읽으려고 할 때**, 객체가 해당 프로퍼티/메서드를 직접 가지고 있지 않으면, 자신의 부모가 가진 프로토타입 객체의 프로퍼티/메서드를 **차례대로** 검색하는 성질

자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.

프로토타입 체인의 최상위에 위치하는 객체는 언제나 **`Object.prototype`** 이며 프로토타입의 프로토타입 또한 **`Object.prototype`** 이다.

**[프로토타입 상속](<https://github.com/FEDeepDive/Front-end/blob/uraflower/5.%20JavaScript(%EA%B0%9D%EC%B2%B4).md#5-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%83%81%EC%86%8D>)**

```jsx
const parent = { name: 'Kim', age: 50 };
const child = {};

child.__proto__ = parent; // 프로토타입 객체로 부모를 할당
console.log(child); // {}
console.log(child.name); // Kim (프로토타입 체인 작동 => parent.name)

child.age = 20;
console.log(child); // { age: 20 }
console.log(child.age); // 20
```

**프로토타입 장단점**

- 클래스 기반의 객체지향은 모든 속성과 메서드가 복사되어 자식클래스의 메모리에 올라가지만 프로토타입 기반의 객체지향인 경우 프로토타입에 대한 참조만 전달하므로 메모리 측면에서 효율적이다.
- 프로토타입기반의 객체지향은 동적으로 프로토타입을 변경할 수 있는데 동적 프로그래밍이 된다는 것이 장점이지만 신뢰성 측면에서는 단점일 수 있다.

**실제 사용 예**

- 클래스 기반 프로그래밍 구현
- 동적 프로그래밍을 구현

**[번외) 프로토타입 기반 언어 vs. 클래스 기반 언어](<https://github.com/FEDeepDive/Front-end/blob/uraflower/5.%20JavaScript(%EA%B0%9D%EC%B2%B4).md#%EB%B2%88%EC%99%B8-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B8%B0%EB%B0%98-%EC%96%B8%EC%96%B4-vs-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B0%98-%EC%96%B8%EC%96%B4>)**

- 프로토타입 기반 언어 : 구성원을 유사성에 따라 나눔(ex. Javascript, Lua)
- 클래스 기반 언어 : 구성원을 분류(ex. Java, C++, C#, Python, PHP, Ruby)

<br/>

## 6. (Weak)Map vs. (Weak)Set

ES6 에서 새로 도입된 조금 특별한 객체로 데이터를 효율적으로 저장하고 관리하는데 사용된다.

`Map` **과 `Set` 의 특징**

- **`Map`** 과 **`Set`** 은 요소 순서에 의미가 없어 인덱스로 요소에 접근할 수 없다.
- 이터러블이기 때문에 **`for .. of`** 문으로 순회 가능하다.

**`Map`**

- **`Map`** 은 키와 값의 쌍으로 이루어진 컬렉션 객체
- 키 값으로 문자열만 허용하는 객체와 달리 모든 값을 키로 사용할 수 있다. (**`null`**, **`undefined`**, **`NaN`** 도 가능)
- 요소를 추가하거나 삭제할 때 **`get`**, **`set`**, **`delete`**, **`clear`** 의 메소드들을 사용한다.
- 키 값으로 값에 접근하기 때문에 키는 중복될 수 없다.
- 객체의 프로퍼티를 자주 변경해야 할 때 유용하다.

**`Set`**

- **`Set`** 은 중복되지 않은 값들의 집합으로 이루어진 자료 구조
- 유일한 값을 가지는 목록을 만들거나 중복을 제거할 때 유용하다.

**`WeakMap`과 `WeakSet`**

- 키나 값이 반드시 객체여야하는 **`Map`** 과 **`Set`**
- 객체가 멜모리에서 사라지면 가비지 컬렉션 대상이 된다.

<br/>

## 7. `Date` 객체

표준 빌트인 객체인 **`Date`** 는 날짜와 시간을 표현하는데 사용되는 빌트인 객체이자 생성자 함수. **`new`** 연산자 없이 **`Date`** 생성자 함수 호출시 날짜와 시간 정보를 나타내는 문자열을 반환한다.

<br/>
