## 1. React의 장점, 사용 이유

- **널리 쓰임 ⇒ 크고 활성화된 커뮤니티 & 다양한 툴**
  - 다른 라이브러리, 도구들이 많고 꾸준히 업데이트 됨 (ex. 상태관리 라이브러리, 디버깅 툴)
  - 문제를 마주했을 때 해결 방법을 빠르게 찾을 수 있음
  - 기술, 이슈에 대한 토론이 활발하게 일어남
  - 많은 사람들이 관심을 가지기 때문에 React 관련 소식을 빠르게 접할 수 있음
- **JSX ⇒ 가독성, 개발 생산성, 유지보수 용이, 유연성 …**
  - HTML 파일 수정이 필요 없음
  - 컴포넌트 내에서 HTML-like 마크업을 사용 가능
  - 요소를 다루거나 이벤트/데이터 바인딩하기가 쉽고 유연하여 편함
- **가상 DOM ⇒ 빠르고 편한 DOM 조작 & DOM 성능 최적화**
  - DOM 변경은 무겁고 비용이 많이 듬 ⇒ DOM을 가상화해 DOM 조작 비용과 속도를 줄임
  - 변경이 있는 요소만 리렌더링

## 2. JSX

### **등장 배경**

- 기존에는 HTML이 UI, JS가 로직을 담당했음
- 웹이 interactive하게 변하면서, 로직이 점점 UI를 결정하게 됨
- ⇒ **렌더링 로직과 마크업을 같은 곳에 둬서**, 수정할 때마다 **동기화 상태를 유지**하게 하자!

### **개념**

- JavaScript를 확장한 문법으로, UI 마크업와 렌더링 로직을 함께 다룰 수 있게 함
- 보통 React에서 쓰이지만, React와 독립적인 문법 구문임([참고](https://ko.legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-a-jsx-transform))

### **동작 원리**

- 브라우저는 JSX를 이해하지 못하므로 트랜스파일이 필요함
- ⇒ 컴파일 시 JSX 요소는 JavaScript 객체로 변환되고, 프로퍼티는 객체의 키가 됨

  ```jsx
  const element = <h1 className='greeting'>Hello, world!</h1>;

  const element = React.createElement(
    'h1',
    { className: 'greeting' },
    'Hello, world!',
  );

  const element = {
    type: 'h1',
    props: {
      className: 'greeting',
      children: 'Hello, world!',
    },
  };
  ```

### **문법**

- **단일 루트 요소 반환**
  - 여러 요소를 반환하려면 하나의 상위 요소로 감싸져 있어야 함
  - React Fragment(`<></>`)로 감쌀 수 있음
  ```
  💡 JSX는 JavaScript 객체로 변환된다. 그러므로 여러 요소를 반환하는 것은 두 개 이상의 객체를 반환하는 것과 같은데, 이는 불가능하다. 그래서 그 객체들을 하나의 태그로 감싸야만 반환할 수 있는 것이다.
  ```
- **태그는 항상 닫기**
  ```html
  <!-- wrong (correct in HTML) -->
  <img src="..." alt="..." />
  <li> item

  <!-- correct -->
  <img src="..." alt="..." />
  <li>item</li>
  ```
- **프로퍼티 이름 제한**
  - JavaScript 예약어 사용 불가 (ex. `class`)
  - CamelCase 사용 (ex. `stroke-width` 대신 `strokeWidth`)
  - 예외: `aria-*`, `data-*`는 대시를 사용하여 작성함
  ```
  💡 JSX 프로퍼티가 객체의 키로 변환되기 때문에 대시를 사용하지 못한다.
  ```
- **중괄호(`{}`)를 사용해 변수, 함수, 객체 사용 가능**

## 3. props/state

# props/state

### Props

- **개념**
  - 커스텀 컴포넌트의 JSX attribute와 자식을 포함한 단일 객체
  - properties 라는 뜻
  - Props를 통해 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 수 있음
  - Props는 읽기 전용! 수정해선 안 됨

### **Props drilling**

- **개념**
  - 특정 컴포넌트로 Props를 전달하기 위해 해당 props를 필요로 하지 않는 컴포넌트에까지 props를 전달하게 되는 현상
  - Props가 마치 땅을 파고 내려가듯이 내려가서 drilling이라고 함
- **문제점**
  - 불필요한 Props 전달이 생김
  - 변경 사항이 생기면 Props를 전달하고 있는 모든 컴포넌트를 수정해야 함
  - 컴포넌트 간 의존성이 높아짐
- **해결 방안**
  - 필요한 Props을 전역으로 관리 ⇒ `Context API`나 상태 관리 라이브러리를 사용해 컴포넌트 트리 전체에 데이터를 제공할 수 있음
  - ReactNode를 전달하려는 경우 `children` props 사용 ⇒ 중간 컴포넌트들을 통해 내려가는 것은 동일하지만, 전달하고 있는 props를 중간 컴포넌트들이 몰라도 됨

### State

- **개념**
  - component-specific memory
  - 컴포넌트가 어떤 데이터를 기억할 수 있도록 데이터를 저장하는 지역 변수
  - 상태 변수에 데이터를 저장하고 setter 함수로 상태를 업데이트함
- **특징**
  - Props와 달리 **private** ⇒ 외부에서 접근 불가(local)
  - 상태는 컴포넌트마다 독립적임(isolated)
  - `setState`로 상태를 업데이트하면 렌더링이 일어남
- **컴포넌트 생성 방법에 따른 상태 제어 방법**
  - 클래스 컴포넌트: `constructor` 안에서 `this.state={...}`으로 상태 변수 지정 & `this.setState()`로 상태 업데이트
  - 함수 컴포넌트: `useState` 훅 사용

## 4. A 부모 컴포넌트, B/C 자식 컴포넌트가 있을 때:

- ❓ B 컴포넌트와 C 컴포넌트가 상태 공유를 하려면?
  - ✅ A 컴포넌트에서 상태를 관리하고 B, C 컴포넌트에 Props으로 상태를 전달한다.
  - ✅ 공유하려는 상태를 전역으로 관리한다.
- ❓ C 컴포넌트가 다른 곳으로 옮겨졌을 때는 상태를 어떻게 공유하는가?
  - ✅ 공유하던 상태를 전역으로 관리하여, 항상 접근 가능하게 한다.

## 5. Virtual DOM
