## 1. 브라우저의 렌더링 과정

**IP 주소 취득**

1. 검색창에 www.google.com을 입력하면 입력한 URL 주소 중, 도메인 이름에 해당하는 google.com가 캐싱 되어있나 확인
   1-1. 도메인 이름에 맞는 IP 주소가 존재하면 바로 IP 주소를 반환(IP 주소를 캐싱함)
   1-2. 도메인 이름에 맞는 IP 주소가 존재하지 않는다면 DNS 서버에 IP 주소 요청
2. 전달받은 IP 주소를 이용해 웹 브라우저는 웹 서버에게 해당 웹 사이트에 맞는 HTML 문서 요청
   2-1. 이때, 웹서버는 정적인 데이터를 클라이언트로 바로 돌려줄 수 있으나, 동적인 데이터는 was로 요청함

**렌더트리 생성**

1. 브라우저 렌더링 엔진은 응답받은 HTML 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM 형태로 전환
   - 바이트 -> 문자 -> 토큰 -> 노드 -> 객체
2. 브라우저 렌더링 엔진은 HTML을 한 줄씩 파싱하다가 CSS를 로드하는 link 태그를 만나면 해당 리소스(CSS파일)을 요청한다. CSS 또한 HTML과 동일한 방식으로 파싱하여 CSSOM 트리로 전환된다. 이 과정에서 DOM 생성이 중단되지는 않지만 스타일시트는 렌더링에 영향을 미치기 때문에 렌더링 차단 리소스로 간주되고, 브라우저의 렌더링은 블로킹된다.
3. DOM 트리와 CSSOM 트리를 결합해 렌더트리 생성
   - 렌더트리는 페이지 렌더링에 필요한 노드만 포함한다. 따라서 **`display : none`** 이거나, `meta` 태그인 경우 렌더트리에 포함되지 않음
   - DOM과 CSSOM이 모두 완성되어야 다음 단계로 넘어가므로 CSSOM 생성속도가 웹사이트의 성능에 중요한 역할을 한다.

**AST 생성**

1. 브라우저 렌더링 엔진은 HTML을 한 줄씩 파싱하다가 자바스크립트 코드를 로드하는 script 태그를 만나면 **DOM 생성을 중단**하고 자바스크립트 파일을 서버에 요청하여 받아온 뒤 자바스크립트 엔진에게 제어권을 넘김
2. 자바스크립트 엔진은 DOM 과 CSSOM을 생성하는것처럼 JS를 해석해 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성
3. JS 파싱과 실행이 완료되면 렌더링 엔진에게 제어권이 넘어와 DOM 생성을 재개한다.
4. 결론적으로 JS 구문 분석이 DOM 생성을 막기때문에 async 나 defer 키워드를 도입해 돔 생성과 병렬로 ast를 생성할 수 있다.

**렌더링**

화면이 바뀔 때마다 아래 과정이 반복 수행되어 변경 사항이 반영되는 것

1. **Layout(렌더트리 배치)**
   1. 생성된 렌더트리를 참고하여 각 객체들의 정확한 위치와 크기를 계산
      - 이 과정에서 **`%`** 단위가 **`PX`** 로 변환됨
   2. 만약 AST를 생성하는 과정에서 DOM이나 CSS를 바꾸는 DOM API가 사용 됐다면 렌더트리가 변경되어 레이아웃을 다시하는 **`reflow`** 가 진행
2. **Paint(렌더트리 그리기)**
   1. 확정된 렌더트리를 기반으로 **`repaint`** 하여 실제 화면에 출력
3. **Composite**
   1. 레이어를 하나로 합성하는 단계

---

**요약**

![rendering](img/rendering.png)

- 브라우저의 렌더링 과정은 위와 같으며 AST를 구축한은 과정에서 DOM에 영향을 미친다면 위 과정이 다시 일어난다.
- 이러한 과정을 **Critical Rendering Path(CRP, 중요 렌더링 경로)** 라고 한다.

**리플로우(reflow)**

- Layout 단계에서 수정이 있을 때 발생
- `Layout` → `Paint` → `Composite` 단계가 실행되는 것
- 요소에 기하학적인 영향을 주는 CSS 속성값을 변경할때 발생
- ex) 최초 렌더링, **DOM 노드의 추가/제거, DOM 노드의 위치/크기 변경 (`width`, `margin`, `border`등), Window 창 크기 조절** (위치/크기 값이 상대 값일 경우), **CSS 애니메이션, 계산된 css 정보 (offset, scrollTop 등)**

**리페인트 (repaint)**

- `Paint` → `Composite` 단계가 실행되는 것으로 `Paint` 단계에서 수정이 있을 때 발생
- 리플로우가 발생하면 리페인트가 필연적으로 실행됨
- 요소에 기하학적인 영향을 주지 않는 CSS 속성값을 변경할 때 발생
- **ex) `background`, `color`, `text-decoration`, `border-style`, `border-radius`**

**리플로우 최적화 방법**

- 애니메이션이 들어간 노드는 가급적 **`position : fixed`** 또는 **`position : absolute`** 로 지정하여 전체 노드에서 분리
- 안쓰는 노드의 속성은 **`display : none`** 해 렌더 트리에서 제외

<br/>

## 2. BOM(Browser Object Model)이란?

![alt text](img/window.png)

**DOM(Document Object Model, 문서 객체 모델)**

- HTML 문서의 구조를 브라우저가 이해할 수 있도록 구성한 트리자료구조
- 웹 페이지를 제어할 수 있는 프로퍼티들과 메서드(API)를 제공한다.

**BOM(Browser Object Model, 브라우저 객체 모델)**

- 표준은 아니지만 문서 이외에 브라우저, 윈도우를 제어하기위해 브라우저가 제공하는 추가적인 객체들의 집합
- **`location`** , **`navigator`** , **`document`** , **`screen`** , **`history`** 를 하위 객체로 갖는다.

<br/>

## 3. SPA, MPA, CSR, SSR의 차이

**TTV/TTI**

- TTV(Time To View) : 사용자가 웹브라우저에서 내용을 **볼 수 있는** 시점
- TTI(Time To Interact) : 사용자가 웹브라우저에서 **인터랙션** 할 수 있는 시점

**MPA/SPA : 웹 어플리케이션이 구성된 형태**

- **MPA(Multi Page Application)**
  - 다수의 페이지로 구성되어 요청마다 정해진 페이지를 반환함
  - 화면 깜빡임이 생기며 라우팅할 때마다 서버에게 HTML 요청
- **SPA(single Page Application)**
  - 단일페이지로 구성되어 요청마다 화면을 재구성한다.(수정한다)
  - 화면 깜빡임 등이 없어 UX가 우수

**SSR/CSR : 렌더링방식**

- **SSR(Server Side Rendering)**
  - HTML 문서가 서버에서 렌더링되는 방식.
  - 서버에 웹사이트 요청을 하면 서버는 JS와 CSS를 적용한 정적페이지를 렌더링한 후 만들어진 문서를 브라우저에게 전달하여 화면에 띄워준다
  - 장점 : 첫 페이지 로딩시간이 상대적으로 짧고, 완성된 HTML 문서가 전달되므로 SEO를 적용하기에 좋고, 사용자의 정보를 서버에서 관리하므로 보안에 좋음
  - 단점 : 각 페이지별로 매번 로딩시간이 생기고 새로고침되며, 서버에 부하가 있음
  - Time To View ≠ Time To Interactive
- **CSR(Client Side Rendering)**
  - HTML 문서가 Client에서 렌더링 되는 방식.
  - 서버에 웹사이트 요청을 하면 브라우저는 서버로부터 빈 HTML파일을 전달받아 렌더링에 필요한 요소(js나 css)들을 렌더링한다.
  - 장점 : 초기 로딩 속도를 제외하면 매우 빠른 인터렉션 속도를 보여줌(이미 다운받은 번들링된 JS파일에 렌더링에 필요한 모든 로직이 들어있기 때문), 새로고침이나 화면 깜빡임이 발생하지 않으며 서버단과 일이 분리됨
  - 단점 : 첫 화면 로딩 속도가 느려 사용자가 빈 화면을 오래 볼 수도 있음
  - Time To View = Time To Interactive

<br/>

## 4. CORS 정의 및 목적

**Origin(출처)**

![alt text](img/origin.png)

- 프로토콜, 도메인, 포트번호 3가지를 합쳐 Origin이라고 한다.
- 브라우저 개발자 도구 콘솔에서 console.log(location.origin) 로 출처를 알아낼 수 있다.

**SOP(Same Origin Policy, 동일 출처 정책)**

- 브라우저가 보안을 위해 서로 같은 출처끼리만 리소스를 공유할 수 있도록 하는 정책

**CORS(Cross-Origin Resource Sharing)**

- 교차 출처 리소스 공유 정책으로 서로 다른 출처에서 리소스를 공유하는 것에 대한 정책으로 브라우저에 의해 실행됨
- 악의를 가진 모방 사이트가 접근하는것을 막기 위해 만들어졌다.

**CORS 동작과정**

1. 다른 출처의 리소스를 요청하기 위해 HTTP 프로토콜을 사용하여 요청을 보낼 때, 브라우저는 요청 헤더의 `Origin` 필드에 출처를 담아 함께 보낸다.
2. 서버에서 응답을 보낼 때 응답 헤더의 `Access-Control-Allow-Origin` 필드에 접근이 허용된 출처를 함께 담아 보낸다.
3. 요청 헤더의 `Origin`과 `Access-Control-Allow-Origin`을 비교하여 응답이 유효한지 결정한다.

**CORS 에러 대응하는법**

1. **서버에서 `Access-Control-Allow-Origin` 응답 헤더 세팅하기**
2. 프론트에서 프록시 서버 사용하기

<br/>

## 5. 웹 접근성을 높이기 위한 방법은 어떤 것들이 있을까요?

**웹접근성이란?**

- 장애인이나 고령자 등이 웹 콘텐츠나 웹 기술에 대해 비장애인과 동등하게 접근하고 이용할 수 있도록 보장하는 것
- 여기서 장애인은 일시적인 장애(ex. 팔이 부러진 사람)이나 환경적 제약(ex. 밝은 햇빛)도 포함된다.

**웹 접근성을 높이는 방법**

- 콘텐츠의 의미, 용도를 나타내는 텍스트를 제공한다 (ex. 레이블, 대체 텍스트, 제목)
- alt, role 등의 속성을 부여하여 각 요소의 역할을 명시한다.
- 의미가 있는 이미지를 배경 이미지(background-image)로 제공하지 않는다
- **콘텐츠 내용은 색상에 의존하지 않는다** (ex. 그래프, 차트, 필수 입력 사항 등)
- 소리가 있는 콘텐츠에 **자막/수화/원고**을 제공한다
- 소리가 있는 콘텐츠는 **자동 재생을 금지하고**, 사용자가 의도했을 때 재생되게 한다
- 모든 기능은 **키보드만으로 조작**이 가능해야 한다 (마우스 커서 궤적이 중요한 콘텐츠 제외)
- 사용자 입력과 버튼 등의 조작은 충분한 크기로 서로 여백을 두고 제공한다
- 시간 제한이 있는 콘텐츠가 있다면, 사전에 알리고, **시간 연장 수단을 제공**한다.

<br/>

## 6. 검색 엔진 최적화(Search Engine **O**ptimization, SEO)에 대해 알고 있나요?

**검색 엔진 최적화(Search Engine Optimization, SEO)**

검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 최적화하는 과정

**검색엔진 최적화를 위해 개발자가 해야할 작업**

- SSR 도입하기
- 메타 태그 잘 활용하기(description, og, robots)
- 크롤링 봇이 인지하기 쉬운 적절한 시멘틱 태그를 사용
- 표준적인 하나의 URL 설정

<br/>

## 7. 이벤트

**이벤트 객체**

- 이벤트에 관련된 다양한 정보를 가진 객체
- 이벤트가 발생하면 생성되며, 이벤트 핸들러의 첫번째 인수로 전달된다.
- `type`, `target`, `currentTarget`, `bubbles` 등의 프로퍼티를 갖는다.

**이벤트 핸들러**

이벤트가 발생했을 때 호출될 함수

**이벤트 바인딩**

이벤트가 발생했을 때 브라우저가 이벤트 핸들러를 호출을 할 수 있도록 어떤 요소의 이벤트에 이벤트 핸들러 함수를 연결하는 것

**이벤트 바인딩 방법**

- 인라인 이벤트 핸들러 : HTML 요소의 이벤트 속성 값을 이벤트 핸들러의 호출 결과로 지정해주기
- 이벤트 핸들러 프로퍼티 : DOM 요소의 이벤트 프로퍼티 값에 이벤트 핸들러를 사용하는 함수를 지정해주기
- `addEventListener()` 메서드 : `EventTarget` 인터페이스를 구현하는 DOM 요소 객체들의 `addEventListener` 함수에 이벤트 핸들러를 인수로 전달하기(제일 많이 사용됨)

**이벤트 타입**

- 이벤트의 종류를 나타내는 문자열
- 마우스, 키보드, 포커스, 폼 등이 있다.

**이벤트 타겟**

- `e.target` : 실제로 이벤트를 발생시킨 엘리먼트
- `e.currentTarget` : 이벤트 핸들러가 등록된 요소이며, `event.target`에서부터 이벤트 버블링이 일어나기 때문에 `event.target`과 서로 다른 값일 수 있음( == 이벤트 핸들러 내의 `this`)

**이벤트 전파(Propagation)**

브라우저는 특정 화면 요소(DOM 요소 노드)에서 이벤트가 발생했을 때 그 이벤트객체가 DOM 트리를 통해 전파되는 것

**이벤트 전파의 단계**

- 캡쳐링 단계(capturing phase) : 이벤트가 최상위 요소에서 선택된 요소까지 전파
- 타깃 단계(target) : 이벤트가 이벤트 타깃에 도달
- 버블링 단계(bubbling phase) : 이벤트가 선택된 요소부터 최상위 요소까지 전파

**이벤트 전파를 막는법**

- `e.preventDefault()` : 브라우저 고유의 동작을 중단시킴 즉 기본 이벤트를 막아줌( ex) a 태그의 href 이동, form 태그의 새로고침)
- `e.stopPropagation()` : 해당 이벤트가 다음 상위 요소로 전파되는 것을 막아줌(사용자가 발생한 이벤트를 막음)
- `e.stopImmediPropagation()` : `e.stopPropagation()` 와 동일하나 이벤트가 발생한 동일한 요소의 다른 이벤트들까지 막아줌

**이벤트 위임(delegation)**

버블링의 특성을 활용하여 자식 요소마다 이벤트를 등록하지 않고 부모 요소에 이벤트를 등록하여 이벤트를 위임하는 방법.

- 위임 사용 이유
  DOM 요소가 동적으로 추가되거나 삭제될 때마다 이벤트 리스너를 추가하거나 삭제한다면, 코드의 효율성이 떨어지므로 이벤트 위임 사용.
  단 버블링이 되지 않는 이벤트는 사용불가. 버블링이 되지 않는 이벤트는 캡쳐링 단계에서 이벤트를 처리하는 요소들인데 보통 잘 사용 안함

<br/>

## 8. 쿠키/세션/토큰

## 9. 성능
