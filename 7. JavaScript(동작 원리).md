## 1. 자바스크립트 엔진의 동작 방법

**자바스크립트 엔진**

- JavaScript 코드를 주로 코드를 해석하고 실행하는 역할
→엔진은 코드를 평가단계와 실행단계로 나눠서 처리함
- 주로 브라우저나 서버 측 환경에서 사용되며, 각각의 환경에서 동작하는 방식은 약간씩 다를 수 있다.
    
    ⇒ 자바스크립트는 싱글 스레드 방식으로 한번에 하나의 태스크만 실행한다. 이때 **싱글 스레드 방식으로 동작하는 것은 브라우저가 아니라 브라우저에 내장된 자바스크립트 엔진**이다. 
    
    즉, 자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작한다.
    
- **힙**(변수나 상수들이 사용되는 메모리가 저장되는 부분) & **콜스텍**(함수 호출의 전반적인 상태를 추적하여 프로그램의 실행 흐름을 관리하는 스텍 자료구조)으로 구성
※ 콜스텍을 실행컨텍스트 스텍이라고 부르기도 한다.
- 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다.

**동작방법**

코드를 구문 분석하여 추상 구문 트리(AST)를 생성→  바이트 코드로 변환 → 바이트 코드가 실행되어 JavaScript 코드의 동작을 수행→ 마지막으로 더이상 사용하지 않는 메모리를 해제하는 과정을 통해 메모리 누수를 방지

**↔ 런타임 환경**

코드가 실행되는 환경을 제공하는 소프트웨어

**⇒ 자바스크립트 엔진은 런타임 환경의 구성요소라고 볼 수있음**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/27f3b79e-a984-426e-ab6c-bff52ba81bd8/08891121-0d1a-4040-8563-40b6acbf9916/Untitled.png)

## 2. 이벤트 루프

> 브라우저가 제공하는 기능으로 현재 콜스텍과 태스크큐를 반복적으로 확인하면서 태스크큐에 대기중인 함수가 있다면 콜스텍이 비었을때 이동시키는 역할을 한다.
⇒ 비동기 처리를 할 수 있는 핵심적인 기능
> 
- Task queue란? (Micro vs. Macro)

> setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역
> 
- 마이크로태스크 큐
    - 태스크 큐와는 별도의 큐
    - 프로미스의 후속 처리 메서드의 콜백 함수 일시 저장
    - 마이크로태스크 큐는 태스크큐보다 우선순위가 높다.
    → 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수
    먼저 가져와 실행한다.

## 3. 호이스팅(hoisting)에 대해 설명해주세요

선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

- **발생하는 이유**
    
    앞서 언급했듯, 자바스크립트 엔진은 소스코드를 평가와 실행단계로 나눠 처리 한다. 전역 실행 컨텍스트가 생성되고 var키워드와 전역에 선언한 함수는 **런타임 이전에 실행과 초기화가 완료**돼 **선언문 이전에도 참조 할 수 있어**서 마치 선언문이 끌어올려진거 처럼 느끼게 됨
    let과 const로 선언된 변수와 표현식은 객체 환경 레코드가 아닌 선언적 환경 레코드라는 개념적인 블록에 저장돼, 전역객체의 프로퍼티로 참조 할 수 없다. 즉 런타임 실행 흐름이 선언문에 도달하기까지 일시적 사각지대(TDZ)에 빠지게 된다.  →모든 선언문은 런타임 이전 단계에서 먼저 실행되는것은 변함이 없어 호이스팅은 되지만 TDZ에 빠져 참조는 할 수 없다.
    

## 4. 실행 컨텍스트 ⭐⭐⭐

> **식별자(변수, 함수, 클래스 등의 이름)를 등록**하고 관리하는 **스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘**으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.
> 
> 
> 실행컨텍스트만 이해해도 스코프, 호이스팅, 클로저,비동기 처리 방식 등을 이해할 수 있다!
> 

**구성요소** 

- **실행컨텍스트 스택**
    
    코드의 실행순서를 스택 자료구조로 관리한다. 소스코드가 평가 되면 실행컨텍스트가 생성되고,최상위에 쌓인다. 즉, 스택의 최상위에 있는 것은 현재 실행중인 코드다. 실행이 완료되면 팝되어 스텍에서 제거 된다. 
    
    ⇒ 스텍에서 제거 된다고 해서 렉시컬 환경까지 소멸하는 것은 아니다 어딘가에서 참조되고 있다면 렉시컬 환경은 남아있다. (클로저의 원리)
    ⇒ 누군가에 의해 참조되지 않을때 렉시컬 환경은 비로소 가비지컬렉터에 의해 소멸한다.
    
- **렉시컬 환경**
    
    > 스코프 체인을 통해 식별자를 찾기 위한 환경
    > 
    
    환경레코드 : 식별자&바인딩된 값 관리 
    
    - 전역환경레코드
        - 객체 환경레코드 : 연결된 바인딩 오브젝트를 통해 var로 선언된 변수와 전역에 선언된 함수를 전역객체의 프로퍼티와 메서드가 됨
        - 선언적 환경레코드 : let, const로 선언한 변수와 함수 표현식을 등록하고 관리
        - [[GlobalThisValue]] : this바인딩하는 내부 슬롯
    - 함수환경레코드
        - 매개변수, arguments객체, 함수내부에서 선언한 지역변수와 중첩 함수를 등록하고 관리.
    
    외부렉시컬 환경에 대한 참조 : 상위스코프에 대한 참조를 기록 ⇒ 이를 통해 스코프 체인 구현
    
    - 전역에서는 스코프체인의 종점이라 null이 할당됨

## 5. 스코프

> 식별자가 유효한 범위
> 
- 스코프 체인 / 스코프 체이닝

> 함수의 중첩에 의해 계층적 구조를 갖는 것 :: 모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역스코프의 최상위 스코프는 전역스코프다
> 
- 렉시컬 스코프

> 자바스크립트에서 스코프는 렉시컬 스코프를 따른다. 이는 함수가 호출된 시점이 아니라 정의된 시점에 스코프를 결정하는 것을 말한다.
> 
- 블록 레벨 스코프

> ES6에서 **`let`** 및 **`const`** 키워드의 도입으로 생긴 스코프로 중괄호(**`{}`**)로 둘러싸인 코드 블록 내에서 변수가 유효한 스코프를 의미 
ex. if문, for문, while문 등
> 
- 함수 레벨 스코프

>함수 내에서 선언된 변수가 해당 함수 내에서만 유효한 스코프를 가지는 것을 의미

-> 함수 외부에서는 해당 변수에 접근할 수 없다.

-> ES6이전에도 있었음.

## 6. JS의 가비지 컬렉션(GC)에 대해 설명해주세요

> 가비지 콜렉터 11는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 메모리 누수를 방지한다
>

## 7. 배열에 값을 추가/삭제했을 때 메모리가 어떻게 변화하는지 과정을 설명해주세요.
