## 1. ES6에 추가된 문법
| 기능 | 설명 | 예제 |
| --- | --- | --- |
| let과 const | 블록 스코프를 가지는 변수 선언 | let variable = 10;<br>const constant = 20; |
| 화살표 함수 | 간단한 함수 표현식 | const add = (a, b) => a + b; |
| 템플릿 리터럴 | 문자열 템플릿 표현을 더욱 간단하게 백틱(`)을 사용해 적는다. | `Hello, ${name}!` |
| 디스트럭처링 할당 | 객체나 배열에서 원하는 값 추출 및 할당 | `const { name, age } = person;  const [a,b] = [1,2]` |
| 클래스 | 객체 지향 프로그래밍을 위한 클래스 선언 | javascript class Animal { ... } const cat = new Animal(); |
| 프로미스 | 비동기 처리를 위한 객체 | javascript const fetchData = () => new Promise((resolve, reject) => { ... }); |
| 모듈 | 코드 모듈화 및 재사용을 위한 기능 | javascript import { add, subtract } from './math'; export const multiply = (a, b) => a * b; |
| 나머지 매개변수와 전개 구문 | 가변 개수의 매개변수를 다룸 | const sum = (...numbers) => numbers.reduce((acc, num) => acc + num, 0); |
| 기본 매개변수 | 함수 매개변수에 기본 값을 설정 | const greet = (name = 'Guest') => Hello, ${name}!; |
| rest 파라미터 | 함수의 마지막 매개변수로 정의되며, 나머지 인자들을 배열로 받음 | javascript const sum = (initial, ...numbers) => initial + numbers.reduce((acc, num) => acc + num, 0); |

## 2. `var`, `const`, `let`의 차이점
var의 단점은 주로 함수 스코프를 가지고 있다는 점과 호이스팅이 발생하는 것 등이다.이러한 단점을 보완하고자 ES6에서 let과 const가 도입되었다.
재할당이 필요한 경우 let 그 외의 경우 const를 사용하길 권장하고 있다.

| 특징 | var (ES5) | let (ES6) | const (ES6) |
| --- | --- | --- | --- |
| 스코프 | 함수 스코프 | 블록 스코프 | 블록 스코프 |
| 호이스팅 | O (선언부만 호이스팅) | O (선언과 초기화 모두 호이스팅) | O (선언과 초기화 모두 호이스팅) |
| 재선언 가능 | O | X | X |
| 재할당 가능 | O | O | X (상수로 간주되므로) |
| 초기화 전 참조 불가 | undefined | ReferenceError | ReferenceError |
| 전역 변수로의 호이스팅 | 가능 | 불가능 | 불가능 |
| for 루프에서의 블록 스코프 활용 | 불가능 | 가능 | 가능 |
| 상수로 사용하기 | 불가능 | 불가능 | 가능 |
| 객체와 배열에서의 활용 | 내부 속성/요소 변경 가능 | 내부 속성/요소 변경 가능 | 내부 속성/요소 변 |

## 3. `null`, `undefined`?
```
둘 다 값이 없음을 나타내는 특별한 값으로 falsy하다.
'null'은 의도적으로 표현하는 값 => 의도적인 없음
'undefined'는 값이 없을 확인하는 값 => 처음부터 없음
```
📍참고

동등 연산(==) : null == undefined ⇒ true

일치 연산(===) :  null === undefined ⇒ false

## 4. `NaN`?
1. `NaN`은 전역 객체의 속성. 즉, 전역 범위의 변수로 Not a Number(숫자가 아님) 을 뜻함.
⇒`NaN`역시 JavaScript의 [falsy](https://developer.mozilla.org/ko/docs/Glossary/Falsy) 값 중 하나

`NaN` 을 return 하는 경우
- 숫자로 변환 실패 (예시: `parseInt("blabla")`, `Number(undefined)`와 같은 명시적인 것 또는 `Math.abs(undefined)`와 같은 암시적인 것)
- 결과가 허수인 수학 계산식 (예시: `Math.sqrt(-1)`)
- 정의할 수 없는 계산식 (예시: `0 * Infinity`, `1 ** Infinity`, `Infinity / Infinity`, `Infinity - Infinity`)
- 피연산자가 `NaN`이거나 `NaN`으로 강제 변환되는 메서드 또는 표현식 (예시: `7 ** NaN`, `7 * "blabla"`) - 이것은 `NaN`이 전염성 있다는 것을 의미합니다.
- 유효하지 않은 값이 숫자로 표시되는 기타 경우 (예시: 잘못된 [날짜](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date) `new Date("blabla").getTime()`, `"".charCodeAt(1)`)

특이한 점  :
`NaN === NaN` 은 `false`다

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.
```
세미콜론 자동 삽입(ASI, automatic semicolon insertion)이라는
인터프리터가 ‘문장의 끝이라고 생각되는 지점’에 
세미콜론을 자동으로 붙여주는 기능이 있기 때문이다. 
```
그렇다면 세미콜론 자동 삽입(ASI, automatic semicolon insertion) 기능이란 무엇인가?

1. 줄바꿈이 되는 행의 마지막에
2. 행의 마지막이 `}` 이고 줄바꿈이 되어 다음 행이 시작될때
3. 파일의 끝에 도달할 때
4. `return`이 있는 행의 마지막에
5. `break`가 있는 행의 마지막에
6. `throw`가 있는 행의 마지막에
7. `continue`가 있는 행의 마지막에

⇒ 이런 규칙으로 세미콜론을 자동으로 찍어준다 하지만 ‘자동’이란 키워드와 늘 붙어다니는 문제는 의도하지 않은 상황이 발생할 수 있다는 단점이 있다는 것이다. 결론적으로 의도한 바와 일치하게 하고 싶다면, 명시적으로 찍어주는게 좋지만 뭐 자유롭게 사용해도 될거 같다. 회사에 들어간다면 팀이나 프로젝트에 따라 다를 수 있으므로, 특정한 코딩 가이드 라인을 따라가면 될 것이다.

```
사담👀 학부시절 자바와 c++을 배울때 
`싫어하는 사람이 있으면 코드중에 세미콜론 하나를 그리스어 물음표? 바꿔라` 
(요즘은 어디가 틀렸는지 다 알려주지만) 이런 말이 있을정도로 
세미콜론은 골치(?)아프면서 당연하게 중요한 요소였던거 같다. 
잠시 코딩과 멀어졌다 다시 자바스크립트를 공부할 때 자연스럽게 코드마다 끝 지점에 
새미콜론을 찍었다. 근데 안찍어도 된다는게 좋았던거 같다.
(최소한 세미콜론 하나때문에 오류를 찾으려 밤새진 않아도 될테니!) 
여전히 습관처럼 찍곤 있지만 내가 까먹어도 알아서 챙겨준다는게 너무 매력있는거 같다.
⇒ 아마 기능을 만든 의도도 초보 프로그래머들의 실수를 교정해주려는 배려일 것 같다는 
말에 공감했다. 그만큼 자바스크립트가 유연한 언어라 좋은거 같다.
```

## 6. `Symbol`에 대해 설명해주세요.
- ES6에서 도입된 7번째 데이터 타입으로 **변경 불가능한 원시 타입의 값**이다.
- 프로퍼티 키로 사용될 수 있다.
- for in문에서 무시된다.

> 👉 심벌 값은 유일무이한 값이므로 심벌 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다. 
>

>👉 심벌을 사용하면 표준 빌트인 객체도 확장 하기에 안전하다. 미래에 생길 빌트인 객체와 이름 충돌할 일이 없어짐.
>
## 7. `==` 과 `===` 의 차이가 무엇인가요?
- `==` (동등비교 연산자, Equality Operator):
    - **`==` 연산자는 값을 비교할 때 타입 변환을 수행**합니다. 따라서 **타입이 다른 두 값의 비교를 할 때 타입 변환이 일어납니다.**
    - 타입 변환 규칙에 따라 값이 같은지 비교합니다.
        - **숫자와 문자열 비교:**
            
            `console.log(5 == "5"); // true` **문 자열 "5"를 숫자 5로 변환**하여 비교
            
        - **불리언과 숫자 비교:**
        ``console.log(true == 1); // true`` **불리언 true를 숫자 1로 변환**하여 비교
        - **null과 undefined 비교:** 
        `console.log(null == undefined);// true` null과 undefined는 서로 동등하다고 간주
        - **객체와 문자열 비교:** `console.log({} == "[object Object]"); // true` 객체를 문자열로 변환하여 비교
        - **문자열과 불리언 비교:** `console.log("true" == true); // false`, 문자열 "true"를 불리언 true로 변환하여 비교 ⇒ ??? 어렵
- `===` (일치비교 연산자, Strict Equality Operator):
    - `===` 연산자는 **값과 타입을 모두 비교**합니다. 타입 변환을 수행하지 않고 엄격하게 비교합니다.
    - 비교하는 값의 타입과 값이 정확히 일치하는지 확인합니다.
    
    ⇒ 특별한 경우가 아니라면 의도치 않은 실수를 막기 위해  `===` 를 사용하는것이 좋음
## 8. `for … of` / `for … in` 문
### `for … in` 문

객체의 모든 프로퍼티를 순회하며 열거하려면 for...in 문을 사용한다.

```jsx
for (변수선언문 in 객체) {...}
```

- for...in 문은 프로퍼티를 열거할 때 순서를 보장하지 않으므로 주의 ⇒ but,대부분의 모던 브라우저는 순서를 보장하고 숫자(사실은 문자열)인 프로퍼티 키에 대해서는 정렬을 실시
- 순회 대상 객체의 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거
⇒ 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다.
- `for...in`은 인덱스의 순서가 중요한 `Array`에서 반복을 위해 사용할 수 없다.
⇒ 순서가 중요한 배열의 반복시에는 숫자 인덱스를 사용할 수 있는 for, forEach, for of를 사용하는 것을 권장한다.

**장점**

- 쉽게 객체의 속성을 확인(콘솔이나 다른 방법으로 출력)할 수 있기 때문에 실질적으로 디버깅을 위해 사용될 수 있다.
- 키-값 쌍이 선호되는 데이터의 경우(속성이 "key"의 역할을 함) 특정 값을 가진 키가 있는지 확인하려는 경우에 for...in이 효과적이다.

### `for … of` 문

`for...of` 구문은 **컬렉션** 전용이다. 모든 객체보다는, `[Symbol.iterator]` 속성이 있는 모든 컬렉션 요소에 대해 이 방식으로 반복한다.

```jsx
for (변수선언문 of 이터러블) { ... }
```

- for...of문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 for...of 문의 변수에 할당한다.
- 이터레이터 리절트객체의 done 프로퍼티 값이 false이면 이터러블의 순회를 계속하고 true이면 이터러블의 순회를 중단한다.

| 특성 | for...of | for...in |
| --- | --- | --- |
| 사용 목적 | 이터러블 객체 순회 (배열, 문자열 등) | 객체의 프로퍼티 순회 |
| 구문 | for (const value of iterable) { /* code */ } | for (const key in object) { /* code */ } |
| 반복 대상 | 이터러블 객체 (Array, Set, Map, 문자열 등) | 객체 (프로토타입 체인의 상속된 프로퍼티도 포함) |
| 순회 대상 | 값 (요소, 문자 등) | 키 (프로퍼티 이름) |
| 상속된 프로퍼티 | 미포함 | 포함 |
| 순서 보장 여부 | 보장됨 | 보장되지 않음 |
| 반복 변수 값 | 값 복사 (immutable) | 키 값 |
## 9. `reduce` 사용법
배열을 하나의 값으로 축소하는 고차 함수. 
주로 배열의 모든 요소를 하나의 값으로 합치거나 변환할 때 사용.
    
  ``` 
  	array.reduce((누적값, 현재값, 현재인덱스, 호출한배열) => {
      // 처리 로직
    }, 초기값);
  
  ```
  빈 요소를 제외하고 배열 내에 존재하는 각 요소에 대해 `callback` 함수를 한 번씩 실행
  요소를 돌면서 현재값과 누적값을 계산해 누적값을 반환한다.
  
  초기 값이 없다면 첫번째 요소를 누적값에 넣고, 두번째 값을 현재 값에 넣어서 진행한다.
  → 이는 **예상치 못한 실수를 발생하게 할 수 있으니 초기값은 항상 넣어 두는 것이 안전**하다.
  
  reduce는 가독성이 상대적으로 안좋기 때문에 map,filter로 충분히 해결 할 수 있는 문제들은 reduce사용을 하지 않는것이 좋다고 생각한다.
## 10. `splice`, `slice`,`split`차이
### **`splice()`:**

- 배열 메서드로 배열의 요소를 추가 또는 제거,교체 할 수 있다.
- 첫 번째 매개변수는 시작 인덱스이며, 두 번째 매개변수는 제거할 요소의 개수다.
- 나머지 매개변수는 배열에 추가될 요소다.
- 원본배열을 수정한다.
- 제거한 배열을 반한다.

### **`slice()`:**

- 배열 메서드로 배열의 일부분을 추출하여 새로운 배열을 반환
- 첫 번째 매개변수는 시작 인덱스이며, 두 번째 매개변수는 끝 인덱스(끝 인덱스는 제외)이다.
- 원본 배열을 변경하지 않고, 새로운 배열을 반환한다.

### **`split()`:**

- 문자열 메서드로 문자열을 지정된 구분자를 기준으로 나누어 배열로 반환합니다.
- 첫 번째 매개변수로는 구분할 문자열을 넣고 두번째 매개변수 환할 배열의 최대 길이이다.(선택사항)
- 원본 배열을 변경하지 않고, 새로운 배열을 반환한다.
- 문자열을 배열로 만들 때 많이 사용. ex. `str.split(””)`

| 메서드 | 사용 대상 | 동작 | 반환값 | 원본 변경 여부 |
| --- | --- | --- | --- | --- |
| splice | 배열 | 요소를 추가 또는 제거하고, 제거된 요소를 반환 | 제거된 요소들의 배열 | 원본 배열 변경 |
| slice | 배열 | 일부분을 추출하여 새로운 배열을 반환 | 추출된 배열 | 원본 배열 변경 안됨 |
| split | 문자열 | 구분자를 기준으로 나누어 배열로 반환 | 구분된 문자열로 이루어진 배열 | 원본 문자열 변경 안됨 |
## 11. 옵셔널 체이닝

옵셔널 체이닝 연산자는 **`?.`** 으로 표현되며, 좌항의 피연산자가 **`null` 또는 `undefined`(Nullish)**인 경우 **`undefined`를 반환**하고, 그렇지 않으면 **우항의 프로퍼티 참조** 를 이어간다. 
→ 간단하게 평가 대상이 존재하는지, 안 하는지를 체크해주고 존재할 경우 다음 평가를 진행하고 아니면 undefined를 반환한다.

- 중첩된 객체 구조에서 속성이 존재하지 않을 경우에 발생하는 오류를 방지하는 데 사용.
- 주로 객체의 속성이나 메소드에 **안전하게 접근**하기 위해 사용된다.
- 조건문이나 변수 할당 없이도 중첩된 속성에 **간편하게 접근**가능하다.
- 옵셔널 체이닝은 존재하지 않아도 괜찮은 대상에만 사용하는 것이 좋다.
⇒ 어떤 경우에는 값이 반드시 있어야 하는 경우를 구분하기 어려울 수 있기 때문. (에러가 안나니까)
[참고](https://mine-it-record.tistory.com/631)

## 12. NULL 병합 연산자(`??`)는 무엇인가요?

Null 병합 연산자는 **`??`**으로 표현되며, 왼쪽 피연산자가 **`null` 또는 `undefined`(Nullish)**일 때만 오른쪽 피연산자를 반환합니다. 그 외의 경우에는 왼쪽 피연산자를 반환
→ 평가 대상이 null이나 undefined인 경우에 오른쪽 피연산자 반환

- 주로 옵셔널 체이닝과 함께 사용
- **기본값을 설정**할 때 유용

## 13. 단축평가

논리 연산자를 사용할 때, 연산의 결과가 확정되면 나머지 연산을 수행하지 않고 바로 평가를 멈추는 동작

### **1. 논리곱 AND (`&&`)의 단축 평가:**

예전에 배울때 true=1, false=0으로 치환해서 곱했을때 0이나오면 false, 그 외엔 true이렇게 외웠던 거 같다.

| A | &&(*) | B | A &&(*) B |
| --- | --- | --- | --- |
| false(0) | &&(*) | false(0) | false(0) |
| true(1) | &&(*) | false(0) | false(0) |
| false(0) | &&(*) | true(1) | false(0) |
| true(1) | &&(*) | true(1) | true(1) |
- 조건이 Truthy값일 때 무언가를 해야한다면 논리곱 연산자 표현식으로 if문을 대체할 수 있다.

### **2. 논리합 OR (`||`)의 단축 평가:**

마찬가지로 덧셈해서 0이나오면 false, 그 외엔 true

| A |  \|\|(+) | B | A  \|\|(+) B |
| --- | --- | --- | --- |
| false(0) | \|\|(+) | false(0) | false(0) |
| true(1) |  \|\|(+) | false(0) | false(0) |
| false(0) |  \|\|(+) | true(1) | false(0) |
| true(1) |  \|\|(+) | true(1) | true(1) |

- 조건이 Falsy값일 때 무언가를 해야한다면 논리합 연산자 표현식으로 if문을 대체할 수 있다.

## 14. Promise

JavaScript는 단일 스레드 언어로, 한 번에 한 작업만 처리할 수 있다. 이로 인해 오랜 시간이 걸리는 작업이나 네트워크 요청과 같은 비동기 작업이 발생할 때 기다리면서 다른 작업을 수행할 수 없는 문제가 있었다. 이를 해결하기 위해 비동기 작업을 처리하기 위한 패턴이 필요했고, 그 중 하나가 Promise다.

## 14-1. Promise란 무엇이며, async/await과 어떻게 다른지, 왜 async/await이 등장했는지?

```markdown
🎯Promise는 비동기 작업을 다루기 위한 객체로 
1️⃣비동기 처리 상태 2️⃣처리 결과를 관리 하는 객체이다.
**주로 콜백 지옥을 방지하고 가독성**을 높이기 위해 도입됐다. 
```

Promise는 생성자 함수를 통해 new 와 함께 호출하여 생성한다. 콜백 함수인 resolve와 reject함수를 인수로 전달받고 콜백함수 내부에서 비동기 처리를 수행 한다.

- 생성방법 :  `new promise(resolve, reject)`
- Promise 객체의 세 가지 상태:
    - 프로미스 생성 직후 ⇒ **pending** : 대기 상태, 비동기 작업이 아직 완료되지 않은 상태
    - resolve함수가 호출되면 ⇒ **fulfilled** : 완료 상태,비동기 작업이 성공적으로 완료된 상태
    - reject함수가 호출 되면 ⇒ **rejected** : 실패 상태, 비동기 작업이 실패한 상태
- 후속처리 : 상태가 변하면 이에 따른 후속 처리를 한다.
    - **`.then()`**  : 두가지 콜백 함수를 인수로 받을 수 있아 암묵적으로 프로미스로 반환한다.
        - **fulfilled** → (resolve함수가 호출된 상태)가 되면 처리 결과를 인수로 받는다. ⇒ 값처리
        - **rejected → (**reject함수가 호출된 상태**)**가 되면 프로미스의 에러를 인수로 받는다. ⇒에러처리
    - `**.catch()` :** 한가지 콜백 함수를 인수로 받음 **rejected 인 상태만 호출 됨**
    - `.**finally()` :** Promise가 이행되던, 거부되던 항상 실행되는 콜백 함수를 등록
    - 이 밖에도 여러가지 후속 처리 메서드들이 있음

그러나 Promise 자체는 여전히 콜백을 사용하기 때문에, 여러 개의 비동기 작업을 연결하거나 순차적으로 실행하는 등의 상황에서도 복잡성이 발생할 수 있다.

## 14-2. Promise나 async/await를 es5로 트랜스파일하면 어떻게 되나요?

**Promise**는 **ES5로** 바뀌더라도 그대로이고 polyfill을 통해 **Promise** 객체**를** 추가해주어야한다. **async await**는 polyfill을 추가해주지 않아도 바뀌며 알아서 따로 **async** 관련 함수**를** 만들어주고 while, switch 문 등을 활용해서 만들어준다.

## 15. 클로저(Closure)란 무엇인가요?

```markdown
클로저는 주로 캡슐화, 정보 은닉, 비동기 작업에서의 상태 유지 등 다양한 상황에서 활용되며, 
제대로 사용할 경우 코드의 가독성과 유지보수성을 높일 수 있다.
```

- 정의 :
    
    함수와 그 함수가 선언된 렉시컬 스코프(lexical scope)의 조합으로, 함수가 외부 스코프의 변수에 접근 가능하게 하는 개념
    
- 발생 조건 :
    - 함수는 다른 함수 내에서 선언되어야 하며(중첩함수)
    - 내부 함수는 반환되거나 매개변수로 전달되어 외부 함수 외부에서 사용되어야 함.
- 특징 :
    - 렉시컬 스코프를 기반으로 동작하여 선언 시점에 외부 스코프의 변수에 대한 참조를 유지
    
    ⇒ 함수는 자신이 선언된 스코프 외부의 변수에 접근할 수 있고, 해당 변수가 사라진 이후에도 사용할 수 있다
    
- 장점 :
    - **캡슐화:** 변수와 함수를 외부에서 보호하고 접근을 제어할 수 있다.
    - **상태 유지:** 외부 변수의 상태를 유지하므로 함수 호출 간에 정보를 전달할 수 있다.
- 단점 :
    - **메모리 누수:** 클로저가 외부 스코프의 변수에 계속 접근하는 경우 메모리 누수가 발생할 수 있다.
    - **복잡성:** 오용 시 코드를 이해하고 유지보수하기 어려울 수 있다.

## 16. 구조 분해 할당(Destructuring assignment)이란?

## 17. 전개 구문(Spread syntax)이란?

## 18. 나머지 매개변수(Rest parameters)란?

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

## 20-1. `bind`를 `apply`, `call`로 어떻게 구현할 수 있을까요? 구현해보세요.
