## 1. 함수 컴포넌트/클래스 컴포넌트 차이점, 장단점

|  | 클래스 컴포넌트 | 함수 컴포넌트 |
| --- | --- | --- |
| 선언 방식 | `React.Component`를 상속한 `Class`로 선언 | 일반적인 함수 문법으로 선언 |
| State 사용 | `this.state`와 생명주기 메서드 | `useState`, `useReducer`, `uesEffect` 등 Hooks |
| Props 사용 | `this.props`로 접근 | 매개변수로 받은 `props`로 접근 |
| 렌더링 방식 | `render()` 메서드로 렌더링할 요소를 반환함 | 렌더링할 요소를 직접 반환함 |
| 코드 복잡도 | 복잡하고 코드가 긺 | 간결하고 코드가 짧음 |
| 코드 응집도 | 코드 구조가 생명주기에 맞춰짐 | 코드 구조가 관심사별로 분리됨 |
| 코드 가독성 | 렌더링 요소를 한눈에 파악하기 어려움 | 렌더링 요소를 한눈에 파악하기 쉬움 |
| 러닝커브 | 높음 (`Class`, `this` 이해 필요) | 낮음 |
| 재사용성 | stateful 로직 재사용이 어려움 (HOC로 해결 but 코드가 계속 중첩돼 복잡해짐) | 커스텀 훅을 통한 높은 재사용성 |

- [클래스 컴포넌트 사용 예시 참고](https://react.vlpt.us/basic/24-class-component.html)

## 2. React의 라이프사이클에 대해 설명해주세요.

```
💡 모든 컴포넌트는 `mount`, `update`, `unmount`의 생명주기를 갖는다.
클래스 컴포넌트는 이를 생명주기 메서드로 제어하고, 함수 컴포넌트는 Effect로 생명주기 메서드를 대체한다.
```

- **컴포넌트의 생명주기**
  - 컴포넌트가 화면에 추가되면, `mount`됨
  - 컴포넌트가 상호작용의 결과로 새 props나 state를 받으면, `update`됨
  - 컴포넌트가 화면에서 제거되면, `unmount`됨
- **Effect의 생명주기**
  - Effect 종속성이 없으면, 렌더링될 때마다 Effect를 실행함
  - Effect 종속성이 빈 배열이면, 컴포넌트가 `mount`될 때 Effect를 실행함
  - Effect 종속성이 특정 데이터를 원소로 하는 배열이면, 컴포넌트가 `mount`되거나 종속성의 값이 변경될 때 Effect를 실행함
  - 컴포넌트가 `unmount`되면, `cleanUp` 함수를 수행함
- **참고**
  - [Lifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)

## 3. 생명주기 메서드

- **클래스 컴포넌트에서 일반적인 생명주기**
  - [생명주기 도표](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)
- **생명주기 메서드 (클래스 컴포넌트에서 사용)**
  - `constructor`: 메서드 바인딩, state 초기화 등 수행
  - `render`: 화면에 그릴 ReactNode를 반환
  - `componentDidMount`: 컴포넌트가 mount된 직후 호출됨. 주로 초기화 작업 수행
  - `componentDidUpdate`: 컴포넌트가 update된 직후 호출됨. 최초 렌더링에선 호출 X
  - `componentWillUnmount`: 컴포넌트가 unmount되기 직전 호출됨. 주로 정리 작업 수행

## 4. 고차 컴포넌트

## 5. 상태 관리 라이브러리 종류를 아는 대로 말해주세요.

## 6. 클라이언트 상태와 서버 상태의 차이?

## 7. 에러 바운더리

## 8. Suspense
