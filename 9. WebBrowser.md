## 1. 브라우저의 렌더링 과정
### 중요 렌더링 경로(Critical Rendering Path, CRP)

중요 렌더링 경로는 브라우저가 서버로부터 받은 HTML, CSS, JavaScript를 화면에 그려내는 일련의 단계를 의미하며, 크게 다음의 여섯 가지 단계를 거치게 된다:

| 단계 | 작업 |
| :-: | :-: |
| DOM Tree(문서 객체 모델 트리) 생성 | 응답으로 받은 HTML을 파싱하여 DOM 노드들을 만들고, 만들어진 DOM 노드들을 병합하여 DOM Tree를 만든다. |
| CSSOM Tree(CSS 객체 모델 트리) 생성 | 응답으로 받은 CSS를 파싱하여, DOM을 스타일링하기 위한 모든 스타일 정보를 포함하는 CSSOM Tree를 만든다. |
| JavaScript 적용 | DOM 또는 CSSOM을 변경하는 JavaScript 코드를 적용한다. |
| Render Tree 생성 | DOM Tree와 CSSOM Tree를 결합하여, 페이지를 렌더링하는 데 필요한 노드만 포함된 Render Tree를 만든다. |
| Layout | 생성된 렌더 트리와 화면의 크기, 뷰포트 등을 활용해 요소들이 페이지 내에서 배치되는 위치와 방법, 각 요소의 너비와 높이, 그리고 서로 관련된 위치를 결정한다. 최초 실행 이후 Layout 과정은 Reflow 또는 Relayout이라고도 부른다. |
| Paint | 렌더 트리의 각 노드를 실제로 브라우저 화면에 그린다. 다른 용어로는 Rasterizing이라고도 한다. 최초 실행 이후의 Painting 과정은 Repainting이라고도 부른다. |

### 리페인팅과 리플로우의 차이점과 실행되는 시점
|  | Reflow | Repaint |
| :-: | :-: | :-: |
| 실행 시점 | 요소의 레이아웃, 즉 높이/너비나 위치가 바뀌는 경우 트리거됨 | 요소의 레이아웃이 바뀌지 않는 변경이 있을 때 트리거됨 |
| 트리거시키는 속성 변경 예시 | `width`, `height`, `font-size` 등 | `color`, `background` 등 |
- **⚠️ Reflow 이후에는 항상 Repaint가 일어난다!**

## 2. BOM(Browser Object Model)이란?
브라우저 객체 모델은 DOM(문서 객체 모델)과는 달리 W3C의 표준 객체 모델은 아니지만, 문서 이외에 브라우저의 모든 것을 자바스크립트로 제어하기 위해 브라우저가 제공하는 추가적인 객체들을 지칭한다. 브라우저 객체의 예시로는 `location`, `history`, `navigator` 등이 있으며, 이 객체들은 모두 `window` 객체의 하위에 존재한다.

## 3. SPA, MPA, CSR, SSR의 차이
### SPA vs. MPA
| SPA(Single Page Application) | MPA(Multi Page Application) |
| :-: | :-: |
| 하나의 페이지로 구성된 웹 애플리케이션 | 여러 개의 페이지로 구성된 웹 애플리케이션 |
| 초기 동작에 필요한 모든 정적 리소스를 최초에 한 번 다운로드받음 | 새로운 페이지를 요청할 때마다 정적 리소스가 다운로드됨 |
| 새로운 페이지 요청이 있을 때, 페이지 갱신에 필요한 데이터만 전달받아 페이지를 갱신함 | 매번 전체 페이지가 갱신됨 |
| 전체 페이지를 갱신하지 않고 필요한 부분만 갱신하기 때문에 flickering 없이 자연스러운 UX를 제공할 수 있음 | 완성된 형태의 HTML 파일을 전달받기 때문에 검색 엔진이 페이지를 크롤링하기 적합하여 SEO 관점에서 유리함 |
| 서버와의 결합도가 비교적 낮음 | 서버와의 결합도가 비교적 높음 |

### CSR vs. SSR
| CSR(Client Side Rendering) | SSR(Server Side Rendering) |
| :-: | :-: |
| 웹 페이지에 표시해야 하는 모든 내용이 클라이언트, 즉 브라우저에서 처리되어 그려짐 | 웹 페이지에 표시해야 하는 내용이 서버에서 처리되어 HTML에 담긴 채로 클라이언트에 전달됨 |
| Time To View = Time To Interactive | Time To View ≠ Time To Interactive |
| 사용자 상호작용 중심인 웹 애플리케이션에 적합 | SEO 성능을 요구하는 컨텐츠 제공 중심 웹 사이트에 적합 |
| 애플리케이션의 성능이 클라이언트의 하드웨어/소프트웨어에 크게 의존 | 애플리케이션의 성능이 서버의 하드웨어/소프트웨어에 크게 의존 |

## 4. CORS 정의 및 목적
### 출처(Origin)

서버의 위치를 의미하는 URL에서 `Protocol(Scheme)`과 `Host(Domain)`를 합친 것, 즉 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 정보이다. HTTP, HTTPS 프로토콜의 기본 포트 번호가 80, 443으로 정해져 있기 때문에 생략이 가능하다.

### SOP(Same Origin Policy, 동일 출처 정책)

브라우저는 보안을 위해, 서로 같은 출처끼리만 리소스를 공유할 수 있는 정책을 적용하고 있는데, 이 정책을 동일 출처 정책이라고 한다. SOP 정책은 다른 출처에서 로드된 리소스에 대한 일기 접근을 막음으로써, 민감한 정보가 허가받지 않은 출처에 노출되지 않도록 한다.

### CORS(Cross-Origin Resource Sharing, 교차 출처 리소스 공유)

웹과 같이 열린 환경에서 다른 출처의 리소스를 가져와서 사용하는 것은 굉장히 흔한 일이기 때문에, CORS 정책을 지킨 리소스 요청은 출처가 다르더라도 허용한다. CORS의 동작을 간단히 정리하면 다음과 같다:

1. 다른 출처의 리소스를 요청하기 위해 HTTP 프로토콜을 사용하여 요청을 보낼 때, 브라우저는 요청 헤더의 `Origin` 필드에 출처를 담아 함께 보낸다.
2. 서버에서 응답을 보낼 때 응답 헤더의 `Access-Control-Allow-Origin` 필드에 접근이 허용된 출처를 함께 담아 보낸다.
3. 요청 헤더의 `Origin`과 `Access-Control-Allow-Origin`을 비교하여 응답이 유효한지 결정한다.

### CORS가 동작하는 세 가지 시나리오

| Simple Requests | Preflight | Requests with credentials |
| :-: | :-: | :-: |
| GET, POST, HEAD 중 하나의 메소드를 사용하며, [CORS에 사용 가능한 헤더](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)만을 가지고 있다면 예비 요청을 보내지 않고 바로 본 요청을 보낼 수 있다. | 본 요청을 보내는 것이 안전한지 확인하기 위해, OPTIONS 메소드를 사용하여 예비 요청을 보낸다. | 모든 요청에 인증 정보를 포함하고 싶은 경우, 브라우저에 CORS 정책 위반 여부를 검사하는 규칙이 몇 가지 더 추가된다. |

### CORS를 해결하는 방법

백엔드에서 `Access-Control-Allow-Origin` 헤더를 설정해주는 것이 정석이며, 웹 서버에서 추가해줄 수도 있지만 웹 프레임워크의 미들웨어를 사용하는 방법도 있다. 프론트엔드 개발 환경에서 CORS 문제가 발생할 경우, 프록시 기능을 사용해 CORS 정책을 우회할 수도 있다.

## 5. 웹 접근성을 높이기 위한 방법은 어떤 것들이 있을까요?

## 6. 검색 엔진 최적화(Search Engine **O**ptimization, SEO)에 대해 알고 있나요?

## 7. 이벤트

## 8. 쿠키/세션/토큰

## 9. 성능
