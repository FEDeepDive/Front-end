## 1. `this`

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

✔ this는 자바스크립트 엔진에 의해 암묵적으로 생성

✔ 코드 어디서든 참조할 수 있다

✔ this가 가리키는 값, 즉 this 바인딩(식별자와 값을 연결하는 과정)은 **함수 호출 방식에 의해 동적으로 결정**된다.

🎈아래 표만 외워도 this가 뭘 가리키는지 정도는 쉽게 알아챌 수 있을것이다.

| 호출 방식 | this 바인딩 | 예시 |
| --- | --- | --- |
| 일반 함수 호출 | 전역 객체 | javascript regularFunction(); |
| 메서드 호출 | 메서드를 호출한 객체 | javascript obj.methodFunction(); |
| 생성자 함수 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 | javascript new ConstructorFunction(); |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | 첫 번째 인수로 전달한 객체 | javascript someFunction.apply(someObject); |
| Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 | 전달한 객체에 바인딩 | javascript someFunction.call(someObject); |

## 2. 클래스

자바스크립트는 프로토타입 기반 언어라서 클래스 기반 언어에 익숙한 프로그래머에겐 익숙하지 않아 다소 혼란스럽거나 어렵게 느낄 수 있었다. 때문에 ES6에서 도입된 클래스는 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 **새로운 객체 생성 메커니즘**을 제시한다.

✔ 클래스 몸체에서 정의할 수 있는 메서드는 **constructor(생성자), 프로토타입 메서드, 정적 메서드** 세가지가 있다.

**constructor**

- constructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
- constructor 내부의 this는 클래스가 생성한 인스턴스를 가르킨다.
- 클래스 내에 최대 한 개
- 생략 가능 -> 빈 constructor 암묵적 생성
- 내부에서 return 문 반드시 생략

**프로토타입 메서드**

- 클래스 몸체에서 정의한 메서드는 기본적으로 프로토타입 메서드가 된다.
- 클래스는 프로토타입 기반의 객체 생성 메커니즘

**정적 메서드**

- static이라는 키워드를 붙이면 정적 메서드
- 정적 메서드는 클래스에 바인딩된 메서드
- 정적 메서드는 인스턴스로 호출 불가

```jsx
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello!');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello!
```

✔ 클래스는 함수다. 자바스크립트에서 함수는 일급 객체다. 그러므로 클래스도 일급 객체다!

✔ 클래스는 재정의될 수 없다. 재정의를 시도하면 `SyntaxError` 가 발생한다.

✔  클래스는 호이스팅이 발생하지만, 정의 이전에 참조 할 수 없다. ⇒ 클래스 선언문 이전에 일시적 사각지대(TDZ)에 빠지게 되기 때문에 호이스팅이 발생하지 않는 것처럼 동작

💬 클래스 선언문은 소스코드 평가 단계에서 이미 함수 객체를 생성하는데 일반 함수 선언문과 같이 소스코드 순서 상 이전에 호출할 수 없는 이유는?

✅ 클래스 함수 객체는 런타임 이전에 생성이 되는건 맞지만 내부 메서드들은 new 연산자로 생성한 인스턴스가 생성될 때 유효한 것이므로 클래스 선언 이후에 사용가능하다.

✔ 생성자 함수와의 차이점

| 특징 및 차이점 | 생성자 함수 | 클래스 |
| --- | --- | --- |
| 구문 | function Car(make, model) { ... } | class Car { constructor(make, model) { ... } } |
| 호출 방식 | new Car()로 호출 | new Car()로 호출 |
| 프로토타입 기반 | 지원 | 내부적으로 지원 (명시적 설정 불가능) |
| 프로토타입 메서드 추가 | Car.prototype.drive = function() { ... } | 메서드 정의 구문 사용 (자동으로 프로토타입에 추가됨) |
| this 바인딩 | 호출한 객체에 바인딩 | 항상 인스턴스에 바인딩 |
| 상속 | 프로토타입 체인 사용 | extends 키워드 사용 |

**클래스 필드**

클래스 내에서 선언되는 변수를 의미, 클래스의 인스턴스가 아닌 클래스 자체에 속하는 속성이며, 각 인스턴스에서 독립적인 값을 갖지 않고 모든 인스턴스가 공유한다.

- **정적클래스 필드**
    
    정적 클래스 필드는 클래스의 모든 인스턴스에서 공유되며, 클래스 자체에 속한다. 정적 필드는 **`static`** 키워드를 사용하여 정의된다.
    
- **프라이빗 클래스 필드**
프라이빗 클래스 필드는 클래스 내에서만 접근 가능한 필드로, 클래스 외부에서는 직접 접근할 수 없다. 프라이빗 필드는 **`#`** 접두어를 사용하여 정의된다.

```jsx
class Example {
  // 클래스 필드
  static staticField = 'I am a static field'; // 특징: 정적 필드
  instanceField = 'I am an instance field'; // 특징: 인스턴스 필드

  // 프라이빗 필드
  #privateField = 'I am a private field'; // 특징: 프라이빗 필드

  constructor() {
    // 생성자 내부에서 인스턴스 변수 정의
    this.anotherInstanceField = 'I am another instance field';
  }

  // 프라이빗 메서드
  #privateMethod() {
    console.log('I am a private method');
  }

  // 공개 메서드
  publicMethod() {
    console.log('I am a public method');
    
    // 특징: 프라이빗 필드 및 메서드 사용
    console.log(this.#privateField);
    this.#privateMethod();
  }
}

const instance = new Example();

// 특징: 정적 필드는 인스턴스에서 직접 접근 가능
console.log(instance.staticField);

// 특징: 인스턴스 필드는 인스턴스에서 직접 접근 가능
console.log(instance.instanceField);

// 에러 - 특징: 프라이빗 필드에 직접 접근 불가
console.log(instance.#privateField);
// 에러 - 특징: 프라이빗 메서드에 직접 접근 불가
instance.#privateMethod();

// 특징: 프라이빗 필드와 메서드를 간접적으로 접근
instance.publicMethod();
```

**클래스 상속**

- **`extends`** 키워드를 사용하여 부모 클래스 지정해 자식 클래스가 부모 클래스의 특성을 상속받아 사용할 수 있는 특징이 있다.
- 자식 클래스의 생성자에서 **`super()`** 를 사용해 부모 클래스의 생성자를 호출할 수 있다.

→ 코드의 재사용성을 높이고 유지보수를 쉽게해준다.

## 3. 불변성

**원시 데이터 타입의 불변성:**

- 원시 데이터 타입(숫자, 문자열, 불리언, null, undefined, Symbol)은 불변합니다. 이 값들은 변경 불가능하며, 변수에 새로운 값을 할당하면 이전 값이 변경되는 것이 아니라 새로운 메모리에 새로운 값이 할당됩니다.

**불변성을 유지하는 객체나 배열 생성:**

- 객체나 배열을 생성할 때, 불변성을 유지하는 방법으로 **`Object.freeze()`**, **`Object.seal()`**, **`Object.assign()`**, 혹은 불변성 라이브러리들을 사용할 수 있습니다.

| 구분 | 메서드 | 프로퍼티
추가 | 프로퍼티
삭제 | 프로퍼티
값 읽기 | 프로퍼티
값 쓰기 | 프로퍼티 어트
리뷰트 재정의 |
| --- | --- | --- | --- | --- | --- | --- |
| 객체 확장 금지 | Object.preventExtensions | ✕ | ◯ | ◯ | ◯ | ◯ |
| 객체 밀봉 | Object.seal | ✕ | ✕ | ◯ | ◯ | ✕ |
| 객체 동결 | Object.freeze | ✕ | ✕ | ◯ | ✕ | ✕ |

**불변성의 이점:**

- 예측 가능한 코드: 값이 변경되지 않으므로 코드 실행 결과를 예측하기 쉽다.
- 효율성: 변경이 없는 데이터는 캐싱이나 메모이제이션과 같은 최적화 기법에 활용될 수 있다.
- 병렬 처리: 불변 데이터는 여러 스레드나 워커 간에 안전하게 공유될 수 있다.

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

**자바스크립트의 타입**

| 데이터 타입 | 구분 | 설명 |
| --- | --- | --- |
| 숫자(number) | 원시 타입 | 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
| 문자열(string) | 원시 타입 | 문자열 |
| 불리언(boolean) | 원시 타입 | 논리적 참(true)과 거짓(false) |
| undefined | 원시 타입 | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
| null | 원시 타입 | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
| 심벌(symbol) | 원시 타입 | ES6에서 추가된 7번째 타입 |
| 객체(object) | 객체 타입 | 객체, 함수, 배열 등 |

데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유?

✔ 원시 타입의 값, 즉 **원시 값은 변경 불가능한 값immutable value**이다. 이에 비해 **객체(참조) 타입의 값, 즉 객체는 변경 가능한 값mutable value**이다.
✔ 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.
✔ 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

| 특성 | 원시 타입 | 객체 타입 |
| --- | --- | --- |
| 변경 가능성 | 변경 불가능(immutable) | 변경 가능(mutable) |
| 저장 방식 | 값 자체가 변수에 직접 저장 | 참조 값이 변수에 저장 |
| 할당과 전달 | 값 복사 (값에 의한 전달) | 참조 값 복사 (참조에 의한 전달) |
## 5. 프로토타입

- 프로토타입이란 무엇인가요?

> 프로토타입은 JavaScript에서 객체 간 **상속을 구현하는 메커니즘 중 하나.** 모든 객체는 자신의 프로토타입에 대한 링크를 가지고 있다. 객체의 속성을 찾을 때 해당 객체에 속성이 없으면 **프로토타입 체인**을 따라 **부모 객체의 프로토타입에서 속성**을 찾는다. 이런 식으로 계속 올라가면 최종적으로 null을 가리키는 프로토타입에 도달하게 된다.
> 
- 프로토타입의 장단점은 무엇인가요?

**장점:**

1. **유연성과 동적성:** 프로토타입 상속 모델은 동적이고 유연하다. 런타임에 객체의 프로토타입을 변경하거나 새로운 속성을 추가할 수 있어서 코드의 변경이 쉽다.
2. **메모리 효율성:** 프로토타입을 사용하면 여러 객체 간에 속성이나 메서드를 공유할 수 있어 메모리를 효율적으로 사용할 수 있다. 모든 인스턴스가 동일한 프로토타입을 참조하기 때문에 중복된 데이터가 생성되지 않는다.
3. **상속의 간편함:** 객체 간의 상속을 간단하게 처리할 수 있다. 부모 객체의 프로토타입에 정의된 메서드와 속성은 하위 객체에서 쉽게 상속받을 수 있다.

**단점:**

1. **복잡성 및 이해 어려움:** 프로토타입 체인이 복잡해질수록 코드를 이해하고 디버깅하기 어려울 수 있습니다. 특히 큰 프로젝트에서는 체인을 파악하기 어려울 수 있다.
2. **속도에 대한 우려:** 프로토타입 체인을 따라 속성을 찾는 데에는 시간이 걸릴 수 있습니다. 체인이 길어질수록 속도에 영향을 미칠 수 있으므로 성능에 대한 고려가 필요하다.
3. **내장 프로토타입 확장의 위험성:** 내장 객체의 프로토타입을 확장하면 라이브러리 간의 충돌이나 예상치 못한 부작용이 발생할 수 있습니다. 이는 코드의 예측성을 낮출 수 있다.
4. **클래스 기반 언어와의 차이:** 클래스 기반 언어에서 익숙한 개발자들에게는 프로토타입 기반의 상속 모델이 혼란스러울 수 있다.
- 프로토타입을 실제로 사용해볼 일은 잘 없는데 어디에 사용할 수 있을까요?
    
    > 프로토타입은 JavaScript에서 객체 간의 상속을 구현하는 데 사용되며, 주로 상속, 동적 변경 및 확장, 프로토타입 기반의 디자인 패턴 구현, 그리고 라이브러리 및 프레임워크에서 모듈화와 재사용성을 향상시키기 위해 활용됩니다. 객체의 프로토타입을 통해 속성과 메서드를 공유하고, 런타임에 동적으로 변경하여 유연성을 제공하며, JavaScript 생태계에서 널리 사용되는 디자인 패턴과 라이브러리에서 중요한 역할을 합니다.
    > 

## 6. (Weak)Map vs. (Weak)Set

### **Map**

> **`Map`**은 키-값 쌍을 저장하는 자료구조이다. 일반객체와 다르게 **메소드를 통해서 값을 추가하거나 접근**할 수 있다. **중복된 키를 허용하지 않아 데이터를 빠르게 검색**할 수 있다. 보통 키-값 관리에 활용된다.
> 

**특징**

- **키는 중복될 수 없으며**, 각 키에 대응하는 값이 있다.
- 순서가 있는 컬렉션으로, 순회할 때 삽입된 순서대로 요소에 접근할 수 있다.
- **모든 자료형을 키**로 사용할 수 있다.

```jsx
// 다양한 자료형을 키와 값으로 사용한 Map
let myMap = new Map();

// 객체를 키로 사용
let objKey = {};
myMap.set(objKey, 'Value for Object Key');

// 함수를 키로 사용
let funcKey = function() {};
myMap.set(funcKey, 'Value for Function Key');

// 문자열을 키로 사용
myMap.set('stringKey', 'Value for String Key');

// 숫자를 키로 사용
myMap.set(42, 'Value for Numeric Key');

// **심지어 배열도 키로 사용 가능**
let arrayKey = [1, 2, 3];
myMap.set(arrayKey, 'Value for Array Key');

// 키에 대한 값들 출력
myMap.forEach((value, key) => {
  console.log(`${key} => ${value}`);
});

/* 출력 결과
[object Object] => Value for Object Key
function() {} => Value for Function Key
stringKey => Value for String Key
42 => Value for Numeric Key
1,2,3 => Value for Array Key
*/
```

**Map 메소드**

- **set(key, value):** 새로운 키-값 쌍 추가 또는 기존 키의 값 업데이트
- **get(key):** 주어진 키에 해당하는 값 반환
- **has(key):** 주어진 키의 존재 여부 확인
- **delete(key):** 주어진 키와 해당 값 삭제
- **clear():** 모든 키-값 쌍 삭제
- **forEach(callbackFn):** 각 키-값 쌍에 대해 콜백 함수 실행

**WeakMap**

- 키에 대한 **약한 참조**를 유지
- 키가 다른 곳에서 더 이상 사용되지 않을 때, 해당 **키-값 쌍이 자동으로 제거**될 수 있음
- 이터러블 하지 않음
- 키-값 쌍을 확인하는 메소드가 제공되지 않음

<aside>
💡 **`Map`**은 **메모리 관리에 주의**해야 한다. 때문에 특정상황에서 **`WeakMap`** 을 유용하게 사용될 수 있다. **`WeakMap`**은 주로 객체 간의 사적인(private) 상태를 저장하거나 메모리 누수를 방지하기 위해 사용된다고 한다.

</aside>

### Set

> Set은 **중복을 허용하지 않는 값의 집합을 저장**하는데 사용된다. 데이터 중복을 방지하고, 값의 존재 여부를 빠르게 확인하는 데에 유용하다.
> 

**Set메서드**

- **add(value):** 값 추가
- **has(value):** 값의 존재 여부 확인
- **delete(value):** 값 삭제
- **clear():** 모든 값 삭제
- **forEach(callbackFn):** 각 값에 대해 콜백 함수 실행

**WeakSet**

- 객체의 집합을 저장, 약한 참조를 사용하여 객체에 대한 참조가 사라지면 자동으로 삭제됨.
- 가비지 컬렉션에 영향을 주지 않고 메모리를 효율적으로 관리할 수 있음.
→객체의 일부분이라도 참조하면서 메모리 누수를 방지하면서 관리할 때 사용됨.
- 특정 객체가 어떤 작업을 완료했는지 추적하고 싶을 때 사용될 수 있음.

| - | Map | WeakMap | Set | WeakSet |
| --- | --- | --- | --- | --- |
| 자동 메모리 관리 | X | O (참조가 없으면 자동 삭제) | X | O (참조가 없으면 자동 삭제) |
| 이터러블 | O | X | O | X |
| 키/값 유무 | 키와 값 모두 저장 | 키와 값 모두 저장 | 값만 저장 | 값만 저장 |
| 사용 예시 | 키-값 관리, 중복 제거 | 객체에 대한 사적인(private) 상태 저장 | 중복 제거, 값 존재 여부 확인 | 객체에 대한 약한 참조 저장 |
| 주의사항 | 메모리 관리에 주의 필요 | 키가 객체에 대한 약한 참조를 유지하므로, 해당 객체에 대한 참조가 사라지면 값도 자동 삭제됨 | 메모리 관리에 주의 필요 | 키가 객체에 대한 약한 참조를 유지하므로, 해당 객체에 대한 참조가 사라지면 값도 자동 삭제됨 |

+일반객체와의 차이도 넣고 싶어서 표 추가 

| - | 일반 객체 | Map | Set | WeakMap | WeakSet |
| --- | --- | --- | --- | --- | --- |
| 자료형 | 모든 자료형 가능 (키-값 쌍) | 키와 값 모두 모든 자료형 가능 | 값만 모든 자료형 가능 | 키와 값 모두 모든 자료형 가능 | 값만 객체 가능 |
| 중복 허용 | 중복 허용 | 중복된 키 불가능 | 중복된 값 불가능 | 중복된 키 불가능 | 중복된 값 불가능 |
| 키와 값의 유지 여부 | 강한 참조를 유지 | 강한 참조를 유지 | 강한 참조를 유지 | 약한 참조로 인해 객체에 대한 참조가 사라지면 자동 삭제 | 약한 참조로 인해 객체에 대한 참조가 사라지면 자동 삭제 |
| 순서 | 순서가 보장되지 않음 | 키의 순서가 보장됨 | 값의 삽입 순서가 보장됨 | 키의 순서가 보장되지 않음 | 값의 삽입 순서가 보장됨 |
| 크기 속성 | 직접 확인 불가 (Object.keys 등 사용) | size 속성으로 직접 확인 가능 | size 속성으로 직접 확인 가능 | 없음 | 없음 |
| 값의 검색 | 객체[key] 형식 사용 | get 메서드로 키에 대한 값을 얻음 | has 메서드로 값의 존재 여부 확인 | get 메서드로 키에 대한 값을 얻음 | has 메서드로 값의 존재 여부 확인 |
| 메서드 사용 | 없음 | get, set, has, delete, clear, forEach | add, has, delete, clear, forEach | get, set, has, delete | add, has, delete |

## 7. `Date` 객체

> 날짜와 시간을 다루기 위한 내장 객체 중 하나다. 1970년 1월 1일 00:00:00 UTC(세계 협정 시간)를 기준으로 한 밀리초로 시간을 표현, 현재 시간이나 특정 날짜 및 시간을 나타내는 데 사용된다.  `new Date()` 로 객체를 생성해 사용한다.
> 

⇒ 요즘 웹 개발에서는 보통 반복적이고 복잡한 작업을 단순화하며, 개발자가 더 쉽게 기능을 구현하기 위해 라이브러리를 사용한다.