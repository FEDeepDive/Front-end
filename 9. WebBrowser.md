## 1. 브라우저의 렌더링 과정

### 주요 렌더링 과정 (Critical Rendering Path)

1. **`IP 주소` 획득**
   1. `DNS`를 통해 도메인 네임(ex. `www.naver.com`)과 매칭되는 `IP 주소`를 얻음
   2. 이 때 여러 `DNS`에게 물어물어 얻음 (`root DNS`에게 `www.naver.com`을 물어보고, 얘가 알려준 다른 `.com 담당 DNS`한테 갔다가 `naver 담당 DNS`에 갔다가 뭐 이런 식)
   3. 이렇게 얻은 `IP 주소`는 캐싱해서 씀
2. **`IP 주소`에 리소스 요청**
3. **리소스 파싱하여 `DOM`, `CSSOM` 생성** (바이트→문자→토큰→노드→객체모델)

   1. 파일을 **바이트**코드 형태로 받음 (ex. `3C 62 6F 79 64 6C 6C`)
   2. 바이트를 **문자**로 인코딩 (ex. `<span>Hi</span>`)
   3. 문자를 **토큰**화 (ex. `startTag: span`, `Hi`, `endTag: span`)
   4. 토큰에 의미를 부여하여 객체 **Node**로써 구조화 (ex. `{ tag: span, attribute: … }`)
   5. 문서의 Node(Object) 간 관계(Model)를 그린 **Object Model** 트리 구조 생성 ⇒ `DOM`, `CSSOM`

   ```
   💡 Parser가 문서를 읽다가 스타일 시트에 관한 `link` 태그를 발견하면, 즉시 해당 리소스, 즉 CSS 파일을 요청한다. `CSSOM`은 위와 동일한 과정을 거쳐 형성되며, `DOM` 파싱을 중단하지 않는다.
   `script` 태그를 발견하면 리소스를 요청하고 스크립트 파일을 받아와 실행한다. 실행하는 동안 `DOM` 파싱이 중단된다.
   ```

   - 참고: [async, defer 속성에 대해 설명해주세요](./1.%20HTML.md#11-async-defer속성에-대해-설명해주세요)

   ```
   💡 `DOM`, `CSSOM`이 모두 완성되어야 다음 단계로 넘어가므로, `CSSOM` 생성 속도가 웹사이트 성능의 중요한 역할을 한다. 스타일 시트에 관한 `link` 태그를 `script` 태그처럼 바디 섹션 맨 아래에 둘 수 없는 이유이기도 하다.
   ```

4. **`렌더 트리` 생성**
   - `DOM`, `CSSOM`을 결합해서 만든 최종 렌더링 설계도
   - 페이지 렌더링에 필요한 노드만 포함함 (ex. `display: none` 요소, `meta` 태그 등 제외)
5. **렌더링**
   1. `Layout`: 각 객체의 정확한 위치와 크기(pixel)를 계산하는 단계
   2. `Paint`: 그리기 호출 목록을 만들고, 레이어를 나누어 실제로 픽셀을 채우는 단계
   3. `Composite`: 레이어를 하나로 합성하는 단계

### Reflow vs. Repaint

|  | Reflow | Repaint |
| --- | --- | --- |
| 개념 | Layout → Paint → Composite 단계가 실행되는 것 | Paint → Composite 단계가 실행되는 것 |
| 실행 상황 | - 최초 렌더링 시<br>- 윈도우 리사이징 시 (viewport 크기 변경 시)<br>- 노드 추가/제거 시<br>- 요소 위치/크기 변경 시<br>- 폰트/이미지 크기 변경 시<br> | - 요소의 위치/크기가 아닌 외관 변경 시<br>(ex. `background-image`, `color`, `box-shadow`) |

## 2. BOM(Browser Object Model)이란?

- **개념**
  - 문서(Document) 외의 모든 것을 제어하기 위해 브라우저가 제공하는 객체들을 구조화한 것
  - 최상위 객체는 `window`
  - 표준이 없음

## 3. SPA, MPA, CSR, SSR의 차이

### 페이지 구성 방식: SPA vs. MPA

|  | SPA | MPA |
| --- | --- | --- |
| 뜻 | SinglePageApplication | MultiplePageApplication |
| 개념 | 하나의 페이지(html)로 앱을 구성 | 여러 페이지(html)로 앱을 구성 |
| 특징 | - 화면 깜빡임 등이 없어 UX가 우수 | - 화면 깜빡임이 생김<br>- 라우팅할 때마다 서버에게 HTML을 요청함 |

### 렌더링 방식: CSR vs. SSR

|  | CSR | SSR |
| --- | --- | --- |
| 뜻 | ClientSideRendering | ServerSideRendering |
| 개념 | 클라이언트(브라우저) 측에서 렌더링 수행 | 서버 측에서 렌더링 수행 |
| 렌더링 과정 | 1. 서버에 웹사이트 요청<br>2. 서버로부터 빈 html과 js 파일을 받음<br>3. 렌더링 과정 수행 (동적으로 DOM 생성) | 1. 서버에 웹사이트 요청<br>2. 서버가 데이터, CSS가 적용된 html을 만듦<br>3. 서버로부터 html을 받음 ⇒ `TTV`<br>4. 화면에 html 띄움 ⇒ `TTI` |
| 장점 | - 상호작용이 빠름 (렌더링이 필요한 부분만 요청하여 변경하니까)<br>- 서버 부하가 덜 함<br>- `TTV(Time-to-View)`, `TTI(Time-to-Interaction)`이 동일 | - 첫 화면 로딩 속도가 빠름 (즉각 렌더링 가능하니까)<br>- SEO에 유리 (서버에서 html을 완성해서 주니까) |
| 단점 | - 첫 화면 로딩 속도가 느림 (모든 파일을 한 번에 받고, 다 처리해야 화면에 뜨니까)<br>- SEO에 약함 (검색엔진 봇이 서치한 시점은 js가 실행되어 metadata가 생기기 전. 즉 html이 빈 껍데기니까) | - 상호작용이 느림 (상호작용할 때마다 서버에 요청하고 페이지를 렌더링해야 하니까)<br>- 서버 부하가 있음<br>- `TTV(Time-to-View)`, `TTI(Time-to-Interaction)`이 동일하지 않음 |

```
💡 SSG(Static Site Generation, Static Rendering)는 SSR처럼 서버가 HTML을 만들어준다는 점에서 비슷하지만, SSR은 요청 즉시(동적으로) HTML을 만들고, SSG는 미리 다 만들어놓고(정적으로) 요청 시 응답한다는 점에서 다르다.
```

## 4. CORS 정의 및 목적

- **개념**
  - 교차 출처 리소스 공유, Cross-Origin Resource Sharing
  - 즉 "\*출처가 다른(교차하는) 서버 간 리소스 공유"를 의미함
  - \*출처(origin) 구성 요소: `프로토콜/도메인/포트`
- **목적**
  - CORS 허용이란, 출처가 서로 달라도 리소스 요청/응답을 허용할 수 있게 함을 의미
- **CORS 에러 해결**
  - 서버에서 응답 헤더 세팅
  - 프록시 서버 사용
    - `http://example.com`에서 `http://api.example.com`로 요청 시, `http://example-proxy.com`라는 프록시 서버에 요청을 보냄
    - 프록시 서버가 `http://api.example.com`으로 요청을 전달하고, 응답을 다시 웹 애플리케이션에 반환

## 5. 웹 접근성을 높이기 위한 방법은 어떤 것들이 있을까요?

## 6. 검색 엔진 최적화(Search Engine **O**ptimization, SEO)에 대해 알고 있나요?

## 7. 이벤트

## 8. 쿠키/세션/토큰

## 9. 성능
