## 1. 브라우저의 렌더링 과정

### 주요 렌더링 과정 (Critical Rendering Path)

1. **`IP 주소` 획득**
   1. `DNS`를 통해 도메인 네임(ex. `www.naver.com`)과 매칭되는 `IP 주소`를 얻음
   2. 이 때 여러 `DNS`에게 물어물어 얻음 (`root DNS`에게 `www.naver.com`을 물어보고, 얘가 알려준 다른 `.com 담당 DNS`한테 갔다가 `naver 담당 DNS`에 갔다가 뭐 이런 식)
   3. 이렇게 얻은 `IP 주소`는 캐싱해서 씀
2. **`IP 주소`에 리소스 요청**
3. **리소스 파싱하여 `DOM`, `CSSOM` 생성** (바이트→문자→토큰→노드→객체모델)

   1. 파일을 **바이트**코드 형태로 받음 (ex. `3C 62 6F 79 64 6C 6C`)
   2. 바이트를 **문자**로 인코딩 (ex. `<span>Hi</span>`)
   3. 문자를 **토큰**화 (ex. `startTag: span`, `Hi`, `endTag: span`)
   4. 토큰에 의미를 부여하여 객체 **Node**로써 구조화 (ex. `{ tag: span, attribute: … }`)
   5. 문서의 Node(Object) 간 관계(Model)를 그린 **Object Model** 트리 구조 생성 ⇒ `DOM`, `CSSOM`

   ```
   💡 Parser가 문서를 읽다가 스타일 시트에 관한 `link` 태그를 발견하면, 즉시 해당 리소스, 즉 CSS 파일을 요청한다. `CSSOM`은 위와 동일한 과정을 거쳐 형성되며, `DOM` 파싱을 중단하지 않는다.
   `script` 태그를 발견하면 리소스를 요청하고 스크립트 파일을 받아와 실행한다. 실행하는 동안 `DOM` 파싱이 중단된다.
   ```

   - 참고: [async, defer 속성에 대해 설명해주세요](./1.%20HTML.md#11-async-defer속성에-대해-설명해주세요)

   ```
   💡 `DOM`, `CSSOM`이 모두 완성되어야 다음 단계로 넘어가므로, `CSSOM` 생성 속도가 웹사이트 성능의 중요한 역할을 한다. 스타일 시트에 관한 `link` 태그를 `script` 태그처럼 바디 섹션 맨 아래에 둘 수 없는 이유이기도 하다.
   ```

4. **`렌더 트리` 생성**
   - `DOM`, `CSSOM`을 결합해서 만든 최종 렌더링 설계도
   - 페이지 렌더링에 필요한 노드만 포함함 (ex. `display: none` 요소, `meta` 태그 등 제외)
5. **렌더링**
   1. `Layout`: 각 객체의 정확한 위치와 크기(pixel)를 계산하는 단계
   2. `Paint`: 그리기 호출 목록을 만들고, 레이어를 나누어 실제로 픽셀을 채우는 단계
   3. `Composite`: 레이어를 하나로 합성하는 단계

### Reflow vs. Repaint

|  | Reflow | Repaint |
| --- | --- | --- |
| 개념 | Layout → Paint → Composite 단계가 실행되는 것 | Paint → Composite 단계가 실행되는 것 |
| 실행 상황 | - 최초 렌더링 시<br>- 윈도우 리사이징 시 (viewport 크기 변경 시)<br>- 노드 추가/제거 시<br>- 요소 위치/크기 변경 시<br>- 폰트/이미지 크기 변경 시<br> | - 요소의 위치/크기가 아닌 외관 변경 시<br>(ex. `background-image`, `color`, `box-shadow`) |

## 2. BOM(Browser Object Model)이란?

- **개념**
  - 문서(Document) 외의 모든 것을 제어하기 위해 브라우저가 제공하는 객체들을 구조화한 것
  - 최상위 객체는 `window`
  - 표준이 없음

## 3. SPA, MPA, CSR, SSR의 차이

### 페이지 구성 방식: SPA vs. MPA

|  | SPA | MPA |
| --- | --- | --- |
| 뜻 | SinglePageApplication | MultiplePageApplication |
| 개념 | 하나의 페이지(html)로 앱을 구성 | 여러 페이지(html)로 앱을 구성 |
| 특징 | - 화면 깜빡임 등이 없어 UX가 우수 | - 화면 깜빡임이 생김<br>- 라우팅할 때마다 서버에게 HTML을 요청함 |

### 렌더링 방식: CSR vs. SSR

|  | CSR | SSR |
| --- | --- | --- |
| 뜻 | ClientSideRendering | ServerSideRendering |
| 개념 | 클라이언트(브라우저) 측에서 렌더링 수행 | 서버 측에서 렌더링 수행 |
| 렌더링 과정 | 1. 서버에 웹사이트 요청<br>2. 서버로부터 빈 html과 js 파일을 받음<br>3. 렌더링 과정 수행 (동적으로 DOM 생성) | 1. 서버에 웹사이트 요청<br>2. 서버가 데이터, CSS가 적용된 html을 만듦<br>3. 서버로부터 html을 받음 ⇒ `TTV`<br>4. 화면에 html 띄움 ⇒ `TTI` |
| 장점 | - 상호작용이 빠름 (렌더링이 필요한 부분만 요청하여 변경하니까)<br>- 서버 부하가 덜 함<br>- `TTV(Time-to-View)`, `TTI(Time-to-Interaction)`이 동일 | - 첫 화면 로딩 속도가 빠름 (즉각 렌더링 가능하니까)<br>- SEO에 유리 (서버에서 html을 완성해서 주니까) |
| 단점 | - 첫 화면 로딩 속도가 느림 (모든 파일을 한 번에 받고, 다 처리해야 화면에 뜨니까)<br>- SEO에 약함 (검색엔진 봇이 서치한 시점은 js가 실행되어 metadata가 생기기 전. 즉 html이 빈 껍데기니까) | - 상호작용이 느림 (상호작용할 때마다 서버에 요청하고 페이지를 렌더링해야 하니까)<br>- 서버 부하가 있음<br>- `TTV(Time-to-View)`, `TTI(Time-to-Interaction)`이 동일하지 않음 |

```
💡 SSG(Static Site Generation, Static Rendering)는 SSR처럼 서버가 HTML을 만들어준다는 점에서 비슷하지만, SSR은 요청 즉시(동적으로) HTML을 만들고, SSG는 미리 다 만들어놓고(정적으로) 요청 시 응답한다는 점에서 다르다.
```

## 4. CORS 정의 및 목적

- **개념**
  - 교차 출처 리소스 공유, Cross-Origin Resource Sharing
  - 즉 "\*출처가 다른(교차하는) 서버 간 리소스 공유"를 의미함
  - \*출처(origin) 구성 요소: `프로토콜/도메인/포트`
- **목적**
  - CORS 허용이란, 출처가 서로 달라도 리소스 요청/응답을 허용할 수 있게 함을 의미
- **CORS 에러 해결**
  - 서버에서 응답 헤더 세팅
  - 프록시 서버 사용
    - `http://example.com`에서 `http://api.example.com`로 요청 시, `http://example-proxy.com`라는 프록시 서버에 요청을 보냄
    - 프록시 서버가 `http://api.example.com`으로 요청을 전달하고, 응답을 다시 웹 애플리케이션에 반환

## 5. 웹 접근성을 높이기 위한 방법은 어떤 것들이 있을까요?

- **웹 접근성이란?**
  - 장애인, 고령자 등이 웹사이트에서 제공하는 정보를 비장애인과 동등하게 접근하고 이용할 수 있도록 보장하는 것
  - 여기서 장애인이란, 일반적으로 생각하는 장애뿐만 아니라, 웹에 접근하는 데 영향을 주는 일시적인 장애 상태(ex. 팔이 부러진 사람)와 환경적 제약(ex. 밝은 햇빛)을 포괄함
- **웹 접근성을 높이는 방법**
  - 콘텐츠의 의미, 용도를 나타내는 텍스트를 제공한다 (ex. 레이블, 대체 텍스트, 제목)
  - 미디어 콘텐츠에는 **대체 텍스트**를 제공한다
  - 마크업의 **오타, 오류를 방지**한다
  - 의미가 있는 이미지를 배경 이미지(background-image)로 제공하지 않는다
  - **콘텐츠 내용은 색상에 의존하지 않는다** (ex. 그래프, 차트, 필수 입력 사항 등)
  - 소리가 있는 콘텐츠에 **자막/수화/원고**을 제공한다
  - 소리가 있는 콘텐츠는 **자동 재생을 금지하고**, 사용자가 의도했을 때 재생되게 한다
  - 모든 기능은 **키보드만으로 조작**이 가능해야 한다 (마우스 커서 궤적이 중요한 콘텐츠 제외)
  - 사용자 입력과 버튼 등의 조작은 충분한 크기로 서로 여백을 두고 제공한다
  - 시간 제한이 있는 콘텐츠가 있다면, 사전에 알리고, **시간 연장 수단을 제공**한다
- 참고
  - [주니어 디자이너가 꼭 알아야 할 '웹 접근성'](https://yozm.wishket.com/magazine/detail/1942/)
  - [네이버 널리](https://nuli.navercorp.com/)

## 6. 검색 엔진 최적화(Search Engine Optimization, SEO)에 대해 알고 있나요?

```
💡 검색 엔진 최적화(SEO)는 검색 엔진이 자료를 수집하는 방식에 맞게 웹 페이지를 구성하는 것을 말합니다. 검색 엔진 최적화를 통해 사용자가 원하는 콘텐츠를 쉽게 찾을 수 있게 하고, 웹 페이지가 검색 결과 상위에 나올 가능성을 높일 수 있습니다.
```

- **개념**
  - 검색 엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성하는 것
- **목적**
  - 사용자(+검색 엔진)가 원하는 콘텐츠를 쉽게 찾을 수 있도록 함
  - 웹 페이지가 검색 결과의 상위에 나올 가능성을 높이기 위함
- **최적화 방법**
  - 유의미한 URL 사용
    - good: `https://www.example.com/pets/cats`
    - bad: `https://www.example.com/2/6772756D`
  - 유용한 콘텐츠 제공
    - 시맨틱 태그 사용
    - 탐색에 도움이 되는 텍스트 제공 (ex. 대체 텍스트, 캡션 등)
    - 고유한 콘텐츠 (다른 사람이 이미 게시하지 않은)
    - 최신 콘텐츠
    - \*신뢰 가능한 콘텐츠
  ```
  💡 구글 검색 엔진 봇은 출처 링크가 포함되어 있으면 신뢰 가능한 콘텐츠로 판단하지만, 네이버는 오히려 스팸으로 간주한다.
  ```
  ```
  💡 검색엔진 봇이 모든 `meta` 태그를 유의미하다고 인식하는 것은 아니다.
  ```

## 7. 이벤트

### 이벤트 바인딩

- 어떤 요소의 이벤트에 이벤트 핸들러 함수를 연결하는 것
- 바인딩 방법

  - 1️⃣인라인 이벤트 핸들러

    ```html
    <div onclick="handleClick()"></div>

    <script>
      function handleClick() {
        console.log(this); // window
        console.log(event.currentTarget); // <div onclick='handleClick()'></div>
      }
    </script>
    ```

    - `html`과 `javascript`의 관심사가 분리되지 않는 문제
    - 이벤트 핸들러 내부 `this`가 `window`를 가리킴 ⇒ 의도하지 않은 문제가 발생할 수 있음
    - 🚨더이상 쓰이지 않음!

  - 2️⃣이벤트 핸들러 프로퍼티

    ```html
    <div></div>

    <script>
      const div = querySelector('div');
      div.onclick = function handleClickA() {}; // 무시됨
      div.onclick = function handleClickB() {}; // 덮어씀
    </script>
    ```

    - 마지막에 등록한 프로퍼티가 기존 값을 덮어씀
    - 크로스 브라우저 호환성이 높음 (IE 8만큼 옛날 브라우저에서도 지원됨)

  - 3️⃣`addEventListener()` 메서드

    ```html
    <div></div>

    <script>
      const div = querySelector('div');
      div.addEventListener('click', handleClickA);
      div.addEventListener('click', handleClickB);

      div.removeEventListener('click', handleClickB);
    </script>
    ```

    - 깉은 타입에 대한 여러 리스너를 하나의 요소에 등록할 수 있음
    - `removeEventListener()`를 이용해 연결된 이벤트 리스너를 해제할 수 있음

### 이벤트 전파: 캡처링 vs. 버블링

같은 이벤트 타입의 두 이벤트 핸들러가 한 요소에 작동했을 때 일어나는 메커니즘

- **캡처링**: `최상위 요소`부터 `실제로 선택된 요소`까지, 발생한 이벤트에 대한 핸들러가 동작
- **버블링**: `실제로 선택된 요소`부터 `최상위 요소`까지, 발생한 이벤트에 대한 핸들러가 동작
- **이벤트 전파 막기**: `event.stopPropagation()`을 이용해 이벤트 전파를 막을 수 있음

```
💡 버블링과 캡처링 이벤트가 동시에 존재하는 경우, 캡처링이 먼저 실행되고 그 후 버블링이 실행된다.
```

```
💡 거의 모든 이벤트는 버블링 되지만, `focus` 이벤트와 같이 버블링되지 않는 이벤트도 있다.
캡처링을 강제로 발생시키려면 `addEventListener`의 `capture` 옵션을 `true`로 설정해야 한다.
```

```html
<div>
  <button>
    <span>Click Me!</span>
  </button>
</div>

<script>
  const div = document.querySelector('div');
  const btn = document.querySelector('button');

  div.addEventListener('click', (e) => alert('div 캡처링'), true); //-----(a)
  div.addEventListener('click', (e) => alert('div 버블링')); //-----------(b)
  btn.addEventListener('click', (e) => alert('button 캡처링'), true); //--(c)
  btn.addEventListener('click', (e) => alert('button 버블링')); //--------(d)
</script>
```

예를 들어 위 코드에서 `<button>` 클릭 시, 이벤트 캡처링이 먼저 일어나고, 그 다음 버블링이 일어나, (a) → (c) → (d) → (b) 순서로 실행된다. 등록된 이벤트가 없는 `<span>`을 클릭해도 마찬가지이다.

### `event.target` vs. `event.currentTarget`

- `event.target`: 이벤트가 시작되게끔 트리거 역할을 한 요소
- `event.currentTarget`: 이벤트 핸들러가 할당된, 실질적으로 이벤트를 발생시킨 요소(=이벤트 핸들러 내의 `this`)

### 이벤트 위임 (Event Delegation)

- 여러 개의 자식 요소에 동일한 구조의 이벤트 핸들러를 할당하고 싶을 때, 모든 자식 요소에 이벤트 핸들러를 할당하지 않는 대신 **부모 요소에 이벤트 핸들러를 할당**하고 **`event.target`으로 자식 요소를 컨트롤**하는 방법
- 이벤트 위임은 이벤트 버블링에 의한 이벤트 전파를 이용한 디자인 패턴임

## 8. 쿠키/세션/토큰

## 9. 성능
