## 1. `this`
JavaScript의 `this` 예약어는 다른 언어와 달리, 함수의 호출 방식에 따라 `this`에 연결될 객체가 동적으로 결정될 수 있다.

### 일반적인 함수 호출
함수의 이름 뒤에 소괄호 쌍이 오는 ‘일반적인’ 형태로 함수가 호출되는 경우, 어떠한 실행 컨텍스트에서 실행되더라도 항상 전역 객체를 가리킨다.

전역 객체는 JavaScript가 실행되는 환경에 따라서 달라지는데, 브라우저에서 실행되는 경우 `window` 객체, Node.js 같은 서버사이드 런타임에서는 `global` 객체가 된다. 어떠한 경우에서든 전역 객체에 접근하고 싶은 경우, `globalThis` 프로퍼티에 접근하면 된다. 

### 메소드 형식 호출
어떠한 객체의 특정 프로퍼티가 함수일 경우, 속성 접근자를 활용해 함수명에 접근한 후 소괄호 쌍을 붙여주어 해당 객체의 메소드로 호출할 수 있다. 이 경우, `this`의 값은 해당 객체를 사용한다.

```js
const obj = { f: function() { console.log(this); } };

// 속성 접근자 두 가지: 점 표기법, 괄호 표기법
// result: Object { f: f() }
obj['f']();
obj.f();
```

### 생성자로써 호출
`new` 키워드를 사용하여 함수를 생성자로 사용하는 경우 함수 실행 전에 빈 객체가 생성되며, 해당 함수 내에서 `this`는 해당 객체에 연결된다. 이후 `this`를 통해 만든 프로퍼티나 메소드 또한 해당 객체에 추가된다.

### 화살표 함수
화살표 함수는 JS의 일반적인 함수와 다르게 정적으로 `this`에 연결될 객체가 결정된다. 즉, 자기 자신만의 `this` 값을 가지지 않으며 항상 자신의 상위 스코프에서 `this`를 상속받아 사용한다.

### `call()`, `apply()`, `bind()`
함수가 가지고 있는 `call()`, `apply()`, `bind()` 메소드를 사용하면 어떠한 값이 `this`에 연결될지 명확하게 지정해줄 수 있다. 해당 메소드들의 첫 번째 인자로 제공한 객체가 함수의 `this`에 연결된다.

## 2. 클래스
JavaScript는 프로토타입 기반 객체지향을 채택하고 있는 언어였지만, ES6에서 `class` 예약어와 함께 클래스 기반 객체지향을 사용할 수 있게 되었다. JavaScript에서의 클래스는 프로토타입을 이용하여 구현되었기 때문에 클래스는 프로토타입의 문법 설탕이라는 의견이 있으며, 클래스를 사용할 경우 프로토타입을 사용하는 것보다 좀 더 많은 일이 내부적으로 일어나기 때문에 그렇지 않다는 의견 또한 존재한다.

### 클래스를 정의하는 방법
`class` 키워드를 사용하여 클래스를 정의할 수 있으며, 함수를 함수 선언문과 함수 표현식으로 정의할 수 있듯 class 선언문과 class 표현식 두 가지 방법이 제공된다.

```js
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}

const Square = class {
  constructor(side) {
    this.side = side;
  }

  area() {
    return this.side * this.side;
  }
}

// result: 15
console.log(new Rectangle(3, 5).area());
// result: 49
console.log(new Square(7).area());
```

### `new`
클래스는 `constructor`라는 이름을 가진 특별한 메소드를 딱 하나씩 가질 수 있는데, `new` 키워드와 함께 해당 클래스명에 소괄호 쌍을 붙여 호출하는 경우 `constructor`를 호출하게 된다. 소괄호 쌍 안에 제공한 인자는 `constructor`의 매개변수를 통해 접근할 수 있다.

## 3. 불변성
JavaScript에는 `string`, `number`, `bigint`, `boolean`, `undefined`, `null`, 그리고 `symbol`까지 총 7개의 원시 자료형이 있으며, 모든 원시 자료형은 변경이 불가능하다. 원시 자료형 이외의 모든 값은 객체 타입이며, 객체 타입은 변경 가능하다. 

### `Object.seal()`
객체에 프로퍼티를 추가하거나 삭제할 수 없게 만드는 메소드이다.

### `Object.freeze()`
`Object.seal()`의 동작에 더하여, 존재하는 프로퍼티의 변경을 막는 메소드이다. 해당 메소드를 사용하여도 객체 내부의 객체는 변경 가능하며, 내부 객체까지 변경 불가능하게 만들기 위해서는 해당 객체가 가지고 있는 모든 객체에 대해 깊이 우선 탐색을 수행하여 `Object.freeze()`를 적용해주어야 한다.

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?
1. 객체는 원시 자료형과 달리 변경 가능하다는 특징이 있다.
2. 원시 자료형은 값으로 비교되기 때문에, 서로 같은 값을 가지고 있다면 동등하다고 말할 수 있다. 그러나 객체는 값으로 비교되지 않으며, 이는 곧 서로 같은 이름의 프로퍼티를 같은 순서와 같은 값으로 가지고 있다고 해도 서로 동등하다고 말할 수 없다. 서로 같은 메모리 공간에 위치하는 객체들끼리만 서로 동등하다고 말할 수 있다.
3. `typeof (function(){}) !== 'object'`이기 때문에 헷갈리기 쉽지만, `(function(){}) instanceof Object === true`이기 때문에, 함수 또한 일종의 객체라는 사실을 알 수 있다.

## 5. 프로토타입

### 1. 프로토타입이란 무엇인가요?
프로토타입은 자바스크립트가 객체지향을 지원하기 위해 채택한 방식이다. 자바스크립트의 모든 객체는 프로토타입 객체를 가지며, 프로토타입 객체로부터 메서드와 속성들을 상속받는다. 상위 프로토타입 객체 또한 그 자신의 상위 프로토타입 객체로부터 상속받으며, 이렇게 이어지는 형태를 프로토타입 체인이라고 한다. 객체에서 프로퍼티에 접근할 때, 해당하는 프로퍼티가 없다면 프로토타입 체인을 따라 상위 프로토타입을 거쳐가며 프로퍼티를 찾는다.

### 2. 프로토타입의 장단점은 무엇인가요?
프로토타입 기반 객체지향은 클래스 기반 객체지향에 비해 메모리 측면에서 효율적일 수 있다. 클래스 기반 객체지향의 경우, 부모 클래스의 모든 속성과 메서드가 자식 클래스에 복사되어 각각 메모리에 올라가는 반면 프로토타입 기반 객체지향의 경우 상위 프로토타입에 대한 참조만 가지고 있어도 되기 때문이다.

그러나 프로토타입 기반 객체지향은 동적으로 프로퍼티를 변경할 수 있기 때문에, 정적으로 속성과 메서드를 결정해야 하는 클래스 기반 객체지향에 비해 예측성과 신뢰성 측면에서 부족한 부분이 있을 수 있다. 또한 프로토타입에 비해 클래스에 익숙한 작업자가 프로토타입을 이해하기 힘들 수 있다는 단점도 존재한다.

### 3. 프로토타입을 실제로 사용해볼 일은 잘 없는데 어디에 사용할 수 있을까요?
프로토타입의 장점인 메모리 효율을 고려하자면, 수많은 개수의 자식 객체를 만들어야 할 때 메모리를 아끼기 위해 프로토타입 사용을 고려할 수 있다. 또한, 프로토타입은 이미 존재하는 객체에 큰 변경을 가하지 않고도 새로운 기능을 추가할 때 유용하게 사용할 수 있다. 

## 6. (Weak)Map vs. (Weak)Set
### Map
ES6에서 도입된 키-값 쌍을 저장할 수 있는 자료구조다. `@@iterator` 메서드를 구현하고 있기 때문에 `for … of` 문을 통해 순회 가능하고, 삽입된 순서를 기억하며. 각 `Map`의 모든 키는 고유하다는 특징이 있다.

ES6 이전에는 일반적인 객체를 `Map`과 비슷하게 사용하곤 하였다. 객체는 프로퍼티라는 이름의 키-값 쌍을 가질 수 있기 때문에 그러한 접근이 가능하지만, 키의 타입을 문자열 또는 `symbol` 타입밖에 사용할 수 없고, 프로토타입이 있기 때문에 기본 키(기본값 속성)가 존재하여 의도치 않은 동작의 원인이 될 수 있는 등의 문제점이 존재한다. `Map`은 어떠한 타입의 키든 사용할 수 있으며, 메서드를 통해 현재 저장된 아이템의 수를 쉽게 얻을 수 있는 등의 장점이 있다.

### Set
ES6에서 도입된 집합 자료구조로, 중복된 데이터를 허용하지 않는다는 특징이 있다. `Map`과 마찬가지로 `@@iterator` 메서드를 구현하고 있기 때문에 `for ... of` 문을 통해 순회 가능하며, 삽입된 순서를 기억한다. 흔히 배열의 중복된 값을 제거할 때 주로 사용되는 경우가 많다.

### Weak{Map | Set}
Weak 접두어가 붙은 각 자료구조들은 가비지 컬렉션될 수 있는 것들, 즉 객체 타입 또는 전역 심볼 레지스트리에 등록되지 않은 `symbol` 타입만을 키로 사용할 수 있다. 키가 가비지 컬렉션될 수 있기 때문에, 해당 키에 연결된 값 또한 가비지 컬렉션될 수 있다. Weak한 자료구조들은 순회가 불가능하며, `keys()`, `values()`, `entries()` 등 반복자를 반환하는 메서드를 가지고 있지 않다. Weak한 자료구조들은 부수적인 데이터, 예를 들어 서드파티 라이브러리 객체나 캐시를 저장하는 데 유용하게 사용될 수 있다.

## 7. `Date` 객체
`Date`는 자바스크립트에서 특정한 날짜 및 시각을 표현할 때 사용하는 빌트인 객체이다. 생성된 `Date` 객체는 1970년 1월 1일 00시 00분부터 현재까지의 시간 차이를 밀리초로 나타내는 정수값을 내부적으로 가진다. `Date` 객체는 날짜 또는 시각을 얻거나 시간대끼리 변환하는 메서드를 많이 가지고 있다.