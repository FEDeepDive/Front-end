## 1. React의 장점, 사용 이유
### 선언형
React는 개발자가 보여주고 싶은 UI의 형태만을 ‘선언’하고, 해당 UI를 실제로 화면에 그리기 위해 필요한 DOM 조작은 내부에서 처리하는 선언적 UI 방식을 따른다. 이전의 명령형 UI에 비해 더 적은 코드로 직관적인 UI를 구성할 수 있기 때문에 생산성이 높으며, 특정 상황에 UI가 어떠한 상태일지 추론할 수 있는 예측 가능성을 높여준다.

### 컴포넌트
React 컴포넌트는 사용자 인터페이스의 구조, 스타일과 기능을 하나의 재사용 가능한 단위로 관리할 수 있게 해준다. React 이전에 HTML/CSS/JS를 각각의 파일로 분리하여 관리하던 때와 비교하여, 코드가 기술적 기준이 아닌 논리적 단위로 나누어지기 때문에 재사용하기 좋다는 장점이 있다. 

### 생태계
`[npm trends](https://npmtrends.com/@angular/core-vs-react-vs-vue)`에 따르면 사용자 인터페이스를 만들기 위한 다른 자바스크립트 라이브러리/프레임워크보다 다운로드 수가 많으며, 그에 비례하는 규모의 생태계와 커뮤니티가 존재하며, 덕분에 여러 문제를 해결할 수 있는 라이브러리들이나 동일한 문제를 위해 고민하는 개발자들이 많다.

---

- [React의 사용 이유에 대해 정리해본 글](https://hatchery.pages.dev/react-a-high-level-perspective/)
- 추천 영상(영어) - [The Future of React is Us](https://www.youtube.com/watch?v=DRebGnDxgFs)

## 2. JSX
JSX는 XML과 비슷한 형태의 자바스크립트 확장 문법이다. 일종의 문법적 설탕이며, `Babel`, `SWC` 등의 트랜스파일러를 통해 기존 JSX와 비슷한 구조의 중첩된 자바스크립트 함수 호출로 변환되어 실행된다. JSX를 통해, 자바스크립트를 사용하여 DOM 트리 구조를 표현할 수 있다. JSX는 React 사용에 필수적이지는 않지만, 거의 모든 React 코드베이스에서 사용되고 있다.

### 문법
JSX는 자바스크립트로 변환되어 실행되기 때문에, HTML과 비교해봤을 때 지켜야 되는 규칙이 많다.

1. 컴포넌트는 한 번에 하나의 JSX 엘리먼트만을 반환해야 한다. 자바스크립트 함수는 한 번에 하나의 반환값을 가져야만 하기 때문이다.
2. HTML의 경우 닫는 태그를 생략해도 동작하는 엘리먼트들이 있지만, JSX에서는 모든 태그를 명시적으로 닫아야 한다.
3. JSX의 속성(attribute)은 대부분 `camelCase`로 작성되어야 한다. 예외적으로 `data-*` 속성과 `aria-*` 속성은 HTML과 동일하게 대시를 사용하여 작성된다.
4. 중괄호(`{}`) 안에 자바스크립트 표현식을 작성할 수 있다.

## 3. props/state
### Props
React 컴포넌트는 자바스크립트 함수와 유사하며, `props`라는 임의의 자바스크립트 객체를 입력으로 받아 화면에 그려질 React 엘리먼트를 반환한다. HTML 요소에 속성(attribute)를 제공하는 것처럼, 사용자 정의 컴포넌트 또는 JSX 요소에 `propName={value}`의 형태로 값을 제공해주면 해당 컴포넌트 내에서 동일한 `prop` 이름으로 전달된 값을 사용할 수 있다. 컴포넌트 내에서 `props`의 값은 불변하게 유지되어야 하며, 매번 렌더링될 때마다 새로운 값을 전달받게 된다.

하위 컴포넌트는 상위 컴포넌트에게서 `props`를 전달받는 형태로만 데이터를 제공받을 수 있다. 데이터를 제공할 수 있는 부모 컴포넌트가 실제로 데이터를 필요로 하는 컴포넌트로부터 멀어져 조상 컴포넌트가 될 경우 데이터가 필요없는 중간 컴포넌트들도 `props`를 받아 아래로 전달하게 되는데, 이러한 현상을 ‘props drilling’이라고 한다. ‘props drilling’이 이루어지는 컴포넌트의 개수가 적을 경우 데이터가 어디서부터 시작하여 전달되는지 명시적으로 보인다는 장점이 있지만, 컴포넌트의 개수가 많을 경우 해당 `prop`을 추적하기 어려워진다는 단점이 있다.

### State
정보 기술과 컴퓨터 과학에서 어떠한 시스템이 이전에 일어난 사건이나 사용자 상호작용을 기억하도록 설계되었다면 stateful(상태를 유지함)이라고 하며, 기억된 정보를 시스템의 state(상태)라고 한다. 컴퓨터가 실행 중에 저장하는 정보는 일반적으로 주 메모리에 저장되기 때문에, ‘상태’라는 단어는 ‘메모리에 저장된 정보’를 의미한다고 볼 수 있다. 상태는 특정 시점에 다른 값으로 변경될 수 있다.

React 컴포넌트는 기본적으로 상태를 가지고 있지 않지만, 상호작용의 결과로 화면의 내용을 변경해야 하는 경우가 많기 때문에 상태를 가져야 하는 경우가 많다. React는 컴포넌트가 자신만의 상태를 관리할 수 있도록 하는 API(`useState`, `useReducer` hook)를 지원하고 있으며, 해당 hook들이 반환하는 변수와 함수를 통해 상태에 접근하고 값을 변경할 수 있다.

## 4. A 부모 컴포넌트, B/C 자식 컴포넌트가 있을 때:
### B 컴포넌트와 C 컴포넌트가 상태 공유를 하려면?
B 컴포넌트와 C 컴포넌트 모두 A 컴포넌트를 부모로 두고 있으므로, 공유하고 싶은 상태를 A 컴포넌트로 이동시킨 후 해당 상태를 `prop`으로 전달받으면 된다. 이렇게 자식 컴포넌트가 가지고 있던 상태를 부모 컴포넌트로 이동시키는 것을 ‘상태를 끌어올린다(lifting state up)’고 말한다.

### C 컴포넌트가 다른 곳으로 옮겨졌을 때는 상태를 어떻게 공유하는가?
C 컴포넌트가 B 컴포넌트와 동일한 레벨, 즉 ‘형제 관계(sibling)’가 아닐 경우, 두 컴포넌트의 조상 컴포넌트 중 가장 가까운 컴포넌트를 찾아 해당 컴포넌트까지 상태를 끌어올릴 수 있으며 이 때 `props drilling`이 발생할 수 있다.

`props drilling`이 너무 깊게 이루어져 추적하기 어려워질 경우 `Context API`를 사용하여 부모 컴포넌트로부터 명시적으로 `props`를 전달하지 않고 아래 트리 전체에 데이터를 전달하는 방식을 고려할 수 있으며, 각종 서드파티 상태 관리 라이브러리 도입을 검토할 수도 있다.

## 5. Virtual DOM
React의 중심 아이디어는 상태가 변경되었을 경우 화면을 처음부터 다시 그리는 것이지만, 성능 상 실제로 모든 요소를 처음부터 다시 그릴 수는 없다. 따라서 사용자 인터페이스의 구조를 나타내는 실제 자료 구조의 복사본 JavaScript 객체를 일시적으로 저장해두었다가, 이를 해석하는 렌더러가 이전 상태와 현재 상태를 비교하여 달라진 부분을 다시 그리는 방식을 채택하였다.

이때 일시적으로 저장되는 JavaScript 객체를 가상 DOM이라고 부르며, **가상 DOM**이라는 표현은 React가 브라우저에서만 사용될 당시 붙여진 이름이다(새로운 공식 문서에 해당 내용은 없다). React가 적용되는 플랫폼(브라우저, Android, iOS 등)에 따라 그 세부 구조는 약간씩 다르며, 이를 해석하는 **렌더러**가 별도로 존재한다.

### 주목할 만한 렌더러

1. [Satori](https://github.com/vercel/satori) - SVG
2. [react-three-fiber](https://github.com/pmndrs/react-three-fiber) - 3D 장면
3. [Ink](https://github.com/vadimdemedes/ink) - CLI 애플리케이션
4. [react-pdf](https://github.com/diegomura/react-pdf) - PDF
5. [react-email](https://github.com/resend/react-email) - E-Mail

### 재조정(**Reconciliation**)

UI의 상태는 트리 구조로 표현되는데, 한 트리를 다른 트리로 변환하는 데에 드는 최소 연산을 구하는 알고리즘은 $O(n^3)$의 높은 시간 복잡도를 가지기 때문에 React에 적용할 수 없다. 그 대신, **서로 다른 종류의 요소는 서로 다른 트리를 만들 것**이라는 가정 하에 $O(n)$의 시간 복잡도를 가지는 React만의 재조정 알고리즘을 사용한다.

1. 두 트리의 최상위 요소부터 비교해나간다.
2. 두 요소의 종류가 서로 다를 경우, 기존 트리를 제거하고 새로운 트리를 만들어 붙인다.
3. 두 요소의 종류가 서로 같을 경우, 변경된 속성만을 갱신한다.
4. 만약 두 요소가 같은 `key` 속성 값을 가질 경우, 변경되지 않았다고 판단하고 넘어간다.
5. 해당 과정을 재귀적으로 진행해나간다.

이렇게 새로운 트리가 만들어졌다면, 변경 사항을 실제 자료 구조에 반영하여 화면에 표시한다. 이 작업은 React가 처리해주기 때문에, (예를 들어) DOM 요소에 직접 접근하여 값을 변경하는 것은 일반적으로 권장되지 않는다. 해당 값의 변경을 React가 감지할 수 없기 때문에 상태와 화면이 불일치하게 될 가능성이 높기 때문이다. 그러나 몇몇 경우에 한해서 `useRef` hook을 이용해 DOM 요소에 직접 접근해야 하는 상황도 있다.