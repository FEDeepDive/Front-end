## 1. 함수 컴포넌트/클래스 컴포넌트 차이점, 장단점

|  | 클래스 컴포넌트 | 함수 컴포넌트 |
| --- | --- | --- |
| 선언 방식 | `React.Component`를 상속한 `Class`로 선언 | 일반적인 함수 문법으로 선언 |
| State 사용 | `this.state`와 생명주기 메서드 | `useState`, `useReducer`, `uesEffect` 등 Hooks |
| Props 사용 | `this.props`로 접근 | 매개변수로 받은 `props`로 접근 |
| 렌더링 방식 | `render()` 메서드로 렌더링할 요소를 반환함 | 렌더링할 요소를 직접 반환함 |
| 코드 복잡도 | 복잡하고 코드가 긺 | 간결하고 코드가 짧음 |
| 코드 응집도 | 코드 구조가 생명주기에 맞춰짐 | 코드 구조가 관심사별로 분리됨 |
| 코드 가독성 | 렌더링 요소를 한눈에 파악하기 어려움 | 렌더링 요소를 한눈에 파악하기 쉬움 |
| 러닝커브 | 높음 (`Class`, `this` 이해 필요) | 낮음 |
| 재사용성 | stateful 로직 재사용이 어려움 (HOC로 해결 but 코드가 계속 중첩돼 복잡해짐) | 커스텀 훅을 통한 높은 재사용성 |

- [클래스 컴포넌트 사용 예시 참고](https://react.vlpt.us/basic/24-class-component.html)

## 2. React의 라이프사이클에 대해 설명해주세요.

```
💡 모든 컴포넌트는 `mount`, `update`, `unmount`의 생명주기를 갖는다.
클래스 컴포넌트는 이를 생명주기 메서드로 제어하고, 함수 컴포넌트는 Effect로 생명주기 메서드를 대체한다.
```

- **컴포넌트의 생명주기**
  - 컴포넌트가 화면에 추가되면, `mount`됨
  - 컴포넌트가 상호작용의 결과로 새 props나 state를 받으면, `update`됨
  - 컴포넌트가 화면에서 제거되면, `unmount`됨
- **Effect의 생명주기**
  - Effect 종속성이 없으면, 렌더링될 때마다 Effect를 실행함
  - Effect 종속성이 빈 배열이면, 컴포넌트가 `mount`될 때 Effect를 실행함
  - Effect 종속성이 특정 데이터를 원소로 하는 배열이면, 컴포넌트가 `mount`되거나 종속성의 값이 변경될 때 Effect를 실행함
  - 컴포넌트가 `unmount`되면, `cleanUp` 함수를 수행함
- **참고**
  - [Lifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)

## 3. 생명주기 메서드

- **클래스 컴포넌트에서 일반적인 생명주기**
  - [생명주기 도표](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)
- **생명주기 메서드 (클래스 컴포넌트에서 사용)**
  - `constructor`: 메서드 바인딩, state 초기화 등 수행
  - `render`: 화면에 그릴 ReactNode를 반환
  - `componentDidMount`: 컴포넌트가 mount된 직후 호출됨. 주로 초기화 작업 수행
  - `componentDidUpdate`: 컴포넌트가 update된 직후 호출됨. 최초 렌더링에선 호출 X
  - `componentWillUnmount`: 컴포넌트가 unmount되기 직전 호출됨. 주로 정리 작업 수행

## 4. 고차 컴포넌트

- **개념**
  - HOC(Higher Order Component)
  - 컴포넌트 **로직 재사용**을 위해, 해당 컴포넌트를 감싼 **새로운 컴포넌트**를 반환하는 함수
  - Hooks의 등장으로 로직 재사용이 간편해져 과거에 비해 잘 사용되지 않지만, 여전히 유용함
- **특징**
  - 컴포넌트를 인자로 받아 새로운 컴포넌트로 반환함
  - 원본 컴포넌트를 수정하지 않고 기능을 추가함 (순수 함수)
  - props로 컴포넌트에 데이터나 동작을 주입 가능
- **예시**
  - 특정 권한이 필요한 모든 컴포넌트에서 권한 확인하기 번거로움 (Hook을 사용해도 되지만, 그러면 컴포넌트 내부에 권한 확인 로직이 추가되는 단점) ⇒ `withAuthorization`라는 HOC를 만들어 컴포넌트를 인자로 받고, 권한이 있을 때만 컴포넌트를 렌더링하게 함. 권한이 필요한 컴포넌트는 권한이 있는 경우의 동작만 코드로 적고, `withAuthorization(component)`를 export

## 5. 상태 관리 라이브러리 종류를 아는 대로 말해주세요.

- Redux
  - ✅ 많이 쓰임 ⇒ 레퍼런스 많음
  - ✅ 미들웨어가 많음 ⇒ 어떤 작업을 직접 제어하기 유용함 (⇒ 큰 프로젝트에서 많이 사용)
  - ❌ 보일러플레이트 코드가 많이 필요
- Zustand
  - ✅ 가벼움
  - ✅ 러닝커브가 낮음
  - ✅ 코드가 간단함
  - ❌ 레퍼런스가 비교적 적음
- Recoil
  - ✅ JS 라이브러리가 아니라, React 전용 라이브러리 ⇒ React와 호환 굿
- Jotai
- React Query (TanStack Query)
  - ✅ 서버 상태 관리 (위 다른 라이브러리는 클라이언트 상태 관리)
  - ✅ 데이터 페칭, 캐싱, 최적화 등을 간편하게 사용할 수 있도록 지원함

## 6. 클라이언트 상태와 서버 상태의 차이?

- **클라이언트 상태**
  - 개념
    - 클라이언트(브라우저/기기)가 제어권을 가지고 있으며, 동기적으로 동작하는 상태
    - ⇒ 항상 최신 값을 가짐
  - 범위에 따른 분류
    - `로컬 상태`: 컴포넌트 내부에서 관리하는 상태
    - `글로벌 상태`: 상태관리 라이브러리, contextAPI 등을 사용해 전역적으로 관리하는 상태
  - 예시
    - UI 상태
    - 브라우저 쿠키
- **서버 상태**
  - 개념
    - 서버(DB)에서 관리되어, 비동기적으로 동작하는 상태
    - ⇒ 데이터 조회 시점의 상태(스냅샷)이므로, 최신 값과 다를 수 있음
  - 예시
    - 로딩중, 에러, 성공 등 API 응답 상태

## 7. 에러 바운더리

- **개념**
  - 하위 컴포넌트에서 일어난 에러를 포착하고, 대신 fallback UI를 보여주는 컴포넌트
  - UI 에러로 인해 앱 자체가 중단되지 않도록 함
  - React 16에서 추가됨
- **특징**
  - 클래스 컴포넌트로만 선언할 수 있음
  - 다음 메서드를 사용해야 함
    - `static getDerivedStateFromError()`: fallback UI를 렌더링
    - `componentDidCatch()`: 에러 정보를 기록
  - `try-catch`와 비슷하지만, 에러 바운더리는 React의 선언적인 특성을 보존하고, 예상한 대로 동작함
- **에러 바운더리에 포착되지 않는 에러**
  - 종류
    - 이벤트 핸들러 (따라서 `try-catch` 사용하여 에러 포착)
    - 비동기 코드
    - 서버 사이드 렌더링
    - 에러 바운더리 컴포넌트 자체에서 발생하는 에러
  - 위 에러 발생 시 전체 React 컴포넌트 트리가 언마운트됨
    - 손상된 UI를 그대로 남겨두는 게, 아무 것도 렌더링하지 않는 것보다 더 치명적일 수 있기 때문
- **예시**

  - 에러 바운더리 없이 오류 처리

    ```jsx
    const MyComponent = () => {
      const { data, error } = useFetch(...);

      if (error) {
        return <p>오류가 발생했어요!</p>
      }

      return (
        <div>
          {data.data.map(...)}
        </div>
      );
    }
    ```

    - 명령형 코드 ⇒ 코드 라인이 길어짐
    - 관심사 분리의 문제

  - 에러 바운더리로 오류 처리

    ```jsx
    class ErrorBoundary extends React.Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true };
      }

      render() {
        if (this.state.hasError) {
          return this.props.fallback;
        }

        return this.props.children;
      }
    }

    function App() {
      return (
        <ErrorBoundary fallback={<ErrorUI />}>
          <MyComponent />
        </ErrorBoundary>
      );
    }
    ```

    - 클래스 컴포넌트 및 `getDerivedStateFromError()` 메서드를 오버라이딩해야 함 (함수로 선언 불가)
    - `fallback` props로 에러에 따라 다른 fallback UI를 보여줄 수 있음

- **참고**
  - [Error Boundary, React-Query와 함께 사용해보기](https://yiyb-blog.vercel.app/posts/error-boundary-with-react-query)
  - [React의 Error Boundary를 이용하여 효과적으로 에러 처리하기](https://fe-developers.kakaoent.com/2022/221110-error-boundary/)
  - [ErrorBoundary 가 포착할 수 없는 에러와 그 이론적 원리 분석](https://happysisyphe.tistory.com/66)

## 8. Suspense

- **예시**
  ```jsx
  <ErrorBoundary fallback={<ErrorPage />}>
    <Suspense fallback={<Loading />}>
      <MyComponent />
    </Suspense>
  </ErrorBoundary>
  ```
  - 자세한 예시는 [공식 문서](https://react.dev/reference/react/Suspense) 참고
- **개념**
  - 하위 컴포넌트가 로딩되는 동안 fallback을 표시하는 컴포넌트
  - React 16에서 등장, React 18에서 보완됨
- **등장 배경**

  - 기존 비동기 처리의 문제점

    - 명령형임 (명령형이 나쁜 게 아니라 React의 선언형의 장점을 살리지 못함)
    - 비동기 로직이 많아질수록 비즈니스 로직 파악이 어려움
    - 데이터 페칭이 끝나야 렌더링이 시작됨 (페칭 시작 → 페칭 끝 → 렌더링 시작)(`Fetch-on-render`)

      ```jsx
      const MyComponent = () => {
        const { data, error, loading } = useFetch(...);

        if (loading) {
          return <Loading />
        }

        if (error) {
          return <ErrorPage />
        }

        return (
          <div>
            {data.data.map(...)}
          <div>
        );
      }
      ```

  - `Suspense`를 사용하면 **선언형**으로 비동기 처리가 가능
  - `Suspense`에 **로딩 상태를 위임**함으로써, 컴포넌트는 비즈니스 로직만 다룰 수 있음
  - 데이터 페칭과 렌더링을 **동시에** 수행할 수 있음 (페칭 시작 → 렌더링 시작 → 페칭 끝)(`Render-as-you-fetch`)

- **동작 원리**
  - 뭔가를 `throw`하면 그것의 _제어권이 상위 컴포넌트로 넘어가는 성질_ 을 이용
    - 하위 컴포넌트에서 `Promise`를 `throw`
    - ⇒ 상위 컴포넌트에서 `Promise`의 상태를 감지
    - ⇒ `Promise`의 상태가 `pending`일 때, `Suspense`의 fallback UI를 렌더링
    - ⇒ `Promise`가 resolve되면, fiber work loop가 스케쥴러에 다시 등록해 하위 컴포넌트를 렌더링
- **참고**
  - [Suspense for Data Fetching의 작동 원리와 컨셉 (feat.대수적 효과)](https://maxkim-j.github.io/posts/suspense-argibraic-effect/)
  - [토스 | SLASH 21-프론트엔드 웹 서비스에서 우아하게 비동기 처리하기](https://www.youtube.com/watch?v=FvRtoViujGg)
