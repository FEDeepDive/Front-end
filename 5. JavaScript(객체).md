## 1. `this`
JavaScript의 `this` 예약어는 다른 언어와 달리, 함수의 호출 방식에 따라 `this`에 연결될 객체가 동적으로 결정될 수 있다.

### 일반적인 함수 호출
함수의 이름 뒤에 소괄호 쌍이 오는 ‘일반적인’ 형태로 함수가 호출되는 경우, 어떠한 실행 컨텍스트에서 실행되었는지에 따라, 또 엄격 모드 여부에 따라 `this`에 연결되는 객체가 달라진다.

| this? | 전역 실행 컨텍스트 | 함수 실행 컨텍스트 |
| :-: | :-: | :-: |
| 엄격모드 | 전역 객체 | undefined |
| 비 엄격모드 | 전역 객체 | 전역 객체 |

전역 객체는 JavaScript가 실행되는 환경에 따라서 달라지는데, 브라우저에서 실행되는 경우 `window` 객체, Node.js 같은 서버사이드 런타임에서는 `global` 객체가 된다. 어떠한 경우에서든 전역 객체에 접근하고 싶은 경우, `globalThis` 프로퍼티에 접근하면 된다. 

### 메소드 형식 호출
어떠한 객체의 특정 프로퍼티가 함수일 경우, 속성 접근자를 활용해 함수명에 접근한 후 소괄호 쌍을 붙여주어 해당 객체의 메소드로 호출할 수 있다. 이 경우, `this`의 값은 해당 객체를 사용한다.

```js
const obj = { f: function() { console.log(this); } };

// 속성 접근자 두 가지: 점 표기법, 괄호 표기법
// result: Object { f: f() }
obj['f']();
obj.f();
```

### 생성자로써 호출
`new` 키워드를 사용하여 함수를 생성자로 사용하는 경우 함수 실행 전에 빈 객체가 생성되며, 해당 함수 내에서 `this`는 해당 객체에 연결된다. 이후 `this`를 통해 만든 프로퍼티나 메소드 또한 해당 객체에 추가된다.

### 화살표 함수
화살표 함수는 JS의 일반적인 함수와 다르게 정적으로 `this`에 연결될 객체가 결정된다. 즉, 자기 자신만의 `this` 값을 가지지 않으며 항상 자신의 상위 스코프에서 `this`를 상속받아 사용한다.

### `call()`, `apply()`, `bind()`
함수가 가지고 있는 `call()`, `apply()`, `bind()` 메소드를 사용하면 어떠한 값이 `this`에 연결될지 명확하게 지정해줄 수 있다. 해당 메소드들의 첫 번째 인자로 제공한 객체가 함수의 `this`에 연결된다.

## 2. 클래스
JavaScript는 프로토타입 기반 객체지향을 채택하고 있는 언어였지만, ES6에서 `class` 예약어와 함께 클래스 기반 객체지향을 사용할 수 있게 되었다. JavaScript에서의 클래스는 프로토타입을 이용하여 구현되었으며, 

### 클래스를 정의하는 방법
`class` 키워드를 사용하여 클래스를 정의할 수 있으며, 함수를 함수 선언문과 함수 표현식으로 정의할 수 있듯 class 선언문과 class 표현식 두 가지 방법이 제공된다.

```js
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}

const Square = class {
  constructor(side) {
    this.side = side;
  }

  area() {
    return this.side * this.side;
  }
}

// result: 15
console.log(new Rectangle(3, 5).area());
// result: 49
console.log(new Square(7).area());
```

### `new`
클래스는 `constructor`라는 이름을 가진 특별한 메소드를 딱 하나씩 가질 수 있는데, `new` 키워드와 함께 해당 클래스명에 소괄호 쌍을 붙여 호출하는 경우 `constructor`를 호출하게 된다. 소괄호 쌍 안에 제공한 인자는 `constructor`의 매개변수를 통해 접근할 수 있다.

## 3. 불변성
JavaScript에는 `string`, `number`, `bigint`, `boolean`, `undefined`, `null`, 그리고 `symbol`까지 총 7개의 원시 자료형이 있으며, 모든 원시 자료형은 변경이 불가능하다. 원시 자료형 이외의 모든 값은 객체 타입이며, 객체 타입은 변경 가능하다. 

### `Object.seal()`
객체에 프로퍼티를 추가하거나 삭제할 수 없게 만드는 메소드이다.

### `Object.freeze()`
`Object.seal()`의 동작에 더하여, 존재하는 프로퍼티의 변경을 막는 메소드이다. 해당 메소드를 사용하여도 객체 내부의 객체는 변경 가능하며, 내부 객체까지 변경 불가능하게 만들기 위해서는 해당 객체가 가지고 있는 모든 객체에 대해 깊이 우선 탐색을 수행하여 `Object.freeze()`를 적용해주어야 한다.

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?
1. 객체는 원시 자료형과 달리 변경 가능하다는 특징이 있다.
2. 원시 자료형은 값으로 비교되기 때문에, 서로 같은 값을 가지고 있다면 동등하다고 말할 수 있다. 그러나 객체는 값으로 비교되지 않으며, 이는 곧 서로 같은 이름의 프로퍼티를 같은 순서와 같은 값으로 가지고 있다고 해도 서로 동등하다고 말할 수 없다. 서로 같은 메모리 공간에 위치하는 객체들끼리만 서로 동등하다고 말할 수 있다.
3. `typeof (function(){}) !== 'object'`이기 때문에 헷갈리기 쉽지만, `(function(){}) instanceof Object === true`이기 때문에, 함수 또한 일종의 객체라는 사실을 알 수 있다.

## 5. 프로토타입

1. 프로토타입이란 무엇인가요?
2. 프로토타입의 장단점은 무엇인가요?
3. 프로토타입을 실제로 사용해볼 일은 잘 없는데 어디에 사용할 수 있을까요?

## 6. (Weak)Map vs. (Weak)Set

## 7. `Date` 객체
