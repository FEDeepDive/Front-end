## 1. 얕은 복사와 깊은 복사의 차이

**얕은 복사(Shallow Copy)**

- 객체를 복사할 때 원본 값과 복사된 값이 같은 참조(=메모리 주소)를 가리키는 것
- 단순한 객체에서 얕은 복사 사용 가능
- 예시 : **`Object.assign()`** , **`전개 연산자(...)`** , **`Array.prototype.slice()`**

**깊은 복사(Deep Copy)**

- 객체를 복사할 때 원본 값을 새로운 참조값에 복사하는 것
- 중첩된 객체에서 깊은 복사 사용 가능
- 예시 : 재귀 함수, **`Lodash`** 의 **`\_.cloneDeep()`**, **`JSON.parse()`** 로 눈속임, **`structuredClone`**

**`structuredClone` 란?**

- 기존에 깊은 복사를 하려면 로대시 같은 라이브러리를 사용했으나, 2022년쯤 HTML5에서 새롭게 정의된 알고리즘으로 주어진 값의 깊은 복사를 한다.
- 단 클래스나 인스턴스의 경우 프로토타입이 폐기되고 일반 객체가 반환된다.
- DOM, 함수의 경우에는 복사에 실패하고 에러가 발생한다.

**[원본 객체와 별개의 주소 값을 가진 객체를 반환하는 함수]**

- **`map()`** : 배열의 각 요소에 대해 주어진 함수를 호출한 결과로 이루어진 새로운 배열을 반환합니다.
- **`filter()`** : 주어진 함수의 반환값이 참인 요소로 이루어진 새로운 배열을 반환합니다.
- **`slice()`** : 지정한 시작 인덱스부터 끝 인덱스 바로 전까지의 요소로 이루어진 새로운 배열을 반환합니다.
- **`concat()`** : 원본 배열과 다른 배열 또는 값들을 연결한 새로운 배열을 반환합니다.

**[원본 객체와 같은 주소 값을 가진 객체를 반환해서 원본 객체가 변하게 하는 함수]**

- **`splice()`** : 배열의 특정 위치에서 요소를 제거하거나 삽입하고, 수정된 배열을 반환합니다.
- **`sort()`** : 배열을 정렬하고, 정렬된 배열을 반환합니다.
- **`reverse()`** : 배열의 요소 순서를 뒤집고, 변경된 배열을 반환합니다.
- **`pop()`** : 배열의 마지막 요소를 제거하고, 제거된 요소를 반환합니다.
- **`shift()`** : 배열의 첫 번째 요소를 제거하고, 제거된 요소를 반환합니다.

<br/>

## 2. 문(statement)과 표현식(expression)의 차이

**문(statement)**

- 프로그램을 구성하는 최소 실행단위
- ASI는 문의 끝이라고 예측되는 지점에 세미콜론을 삽입

**표현식(expression)**

- 값으로 평가될 수 있는 문

**값(value)**

- 표현식이 평가되어 생성된 결과
- 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 **`undefined`** 를 출력한다. 이를 완료 값이라고 한다.

<br/>

## 3. JavaScript Module System

**모듈시스템**

- 애플리케이션 규모가 커지면서 코드가 복잡해지기 때문에 공통된 기능이나 특별한 목적에 따라 코드를 여러 파일로 나누고 재사용 가능한 모듈로 나누는 시스템

**CJS(CommonJS)**

- Node.js 에서 원래 사용되던 모듈 시스템
- **`require`** 을 통해 가져온 값의 복사본을 제공한다. 따라서 내보낸 쪽에서 값을 변경해도 가져온 쪽에 반영되지 않음
- 서버사이드에서 사용하며 동기적으로 작동한다. 따라서 모듈이 모두 다운로드 되기 전까지 아무것도 못함

**ESM**

- ES6 에서 추가된 모듈 시스템으로 JS의 표준 모듈 시스템이다.
- **`export-import`** 문을 사용해 분리되어 있는 JS 파일간의 접근을 가능하게 만들어 준다.
- **`import`** /**`export`** 가 컴파일 시점에 결정되는 정적 구조이다.
- 비동기적으로 모듈을 로드하고 구조분해 할당 등의 다양한 기능 제공
- 모듈은 항상 strict mode에서 작동한다.

**동적 모듈 로딩 (Dynamic import)**

- 코드가 실행되는 도중에 모듈을 동적으로 불러오는 것
- 동적 가져오기를 사용하면 초기 로드 속도를 향상시키고 필요하지 않은 모듈의 로드를 지연시킬 수 있다.

```JS
const myModule = await import('./myModule');
```

**lazy-loading**

- 첫 페이지 진입시 필요한 최소한의 코드만 다운받고 사용자가 특정 지점에 도달할 때마다 필요한 코드를 로드하는 방식

<br/>

## 4. node.js와 그냥 js의 차이

**JS**

- 웹 브라우저에서 실행되는 프로그래밍 언어
- 웹 페이지에 동적인 기능을 추가할 수 있어 웹 프론트엔드 개발에 사용된다.

**Node.js**

- 브라우저 위에서만 동작하는 JS를 브라우저 외부 실행할 수 있도록 하는 런타임 환경
- 빠르고 효율적이웹 서버 개발에 사용된다.

<br/>

## 5. iterable, iterator, 유사 배열 객체

**순회 프로토콜(iteration protocol)**

- ES6에서 도입된 데이터 컬렉션을 순회할 수 있는 객체를 만드는 규칙
- 이터러블 프로토콜과 이터레이터 프로토콜이 있다.

**이터러블 (iterable)**

- 반복할 수 있는(이터러블 프로토콜을 준수하는) 객체
- 이터러블 객체는 **`Symbol.iterator`** 메서드를 프로퍼티 키로 사용한 메서드를 직접 구현하거나, 프로토타입 체인을 통해 상속받음
- **`for … of`** 문으로 순회 가능, **`스프레드 문법`** 의 대상, 배열 디스트럭처링 할당의 대상

**이터레이터 (iterator)**

- **`Symbol.iterator`** 메서드 호출시 리턴되는 객체
- **`next`** 메서드를 필수로 가지며, **`next`** 메서드를 호출시마다 **`iteratorResult`** 객체반환
- **`iteratorResult`** 객체는 **`done`**, **`value`** 프로퍼티를 갖는다
- 이터러블의 각 요소를 순회하는 포인터

**유사배열 객체**

- 인덱스로 프로퍼티 값에 접근 가능하며, **`length`** 프로퍼티를 갖는 객체
- **`Array.prototype`** 으로부터 상속받은 메서드가 없기 때문에 바로 배열처럼 사용할 수는 없음
- **`Symbol.iterator`** 메서드를 가지지 않아 **`for … of`** 문으로 순회할 수 없음

**이터러블이면서 유사 배열 객체인 객체**

- **`arguments`**
- **`HTMLCollection`**
- **`NodeList`**

<br/>

## 6. generator

**제너레이터란 ?**

- 중간에 원하는 부분에서 멈추었다가 그 부분부터 다시 실행할 수 있는 능력을 가진 함수
- **`function*`** 키워드로 정의한다.
- **`return`** 대신 **`yield`** 키워드를 사용헤 순회 가능한 객체를 반환한다.

**제너레이터 객체**

- 제너레이터 함수가 반환하는 이터레이터와 이터러블을 모두 준수하는 특별한 객체
- 이터러블이 가져야 하는 **`Symbol.iterator`** 메서드를 가짐
- 이터레이터가 가져야 하는 **`next`** 메서드를 가짐

<br/>

## 7. polyfill이란 무엇인가요?

**컴파일**

- 소스코드를 다른언어로 변환하는 것
- 보통 고수준언어를 저수준언어로 변환하는 것을 의미함
- ex) **`C → Assembly`**, **`Java → bytecode`**

**트랜스파일**

- 컴파일의 한 종류
- 보통 비슷한 수준의 언어로 변환
- ex) **`es6 → es5`**, **`c++ → c`**

**폴리필이란 ?**

- 자바스크립트의 최신 기능을 구형 브라우저에서도 사용할 수 있도록 구현한 코드 조각이나 플러그인
- 폴리필 스크립트가 많아질수록 UX는 나빠짐
- core-js, polyfill.io 라이브러리 사용

**바벨과 폴리필의 차이점**

- 바벨 : 최신 ES6+ 문법을 ES5로 바꾸어주는 것
- 폴리필은 브라우저가 이해할 수 없는 코드에 대하여, 이해할 수 있는 코드 소스로 바꿔주는 것
