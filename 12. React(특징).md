## 1. 함수 컴포넌트/클래스 컴포넌트 차이점, 장단점
### 클래스 컴포넌트
React가 처음 등장했을 때부터 사용된 컴포넌트 형태. `Component` 클래스를 상속받아 구현할 수 있으며, `render` 메소드를 오버라이딩하여 원하는 JSX를 반환하도록 구현한다. props와 state를 가지고 있으며, `this` 키워드를 통해 `props`에 접근할 수 있고 `state` 변수를 통해 상태에 접근하거나 `setState` 메소드를 통해 상태를 변경할 수 있다.

### 함수 컴포넌트
React 16.8 버전부터 등장한 컴포넌트 형태. React 18.2 버전이 최신 버전인 현재 가장 기본적인 형태로 받아들여지고 있다. `props`를 입력으로 받아 JSX를 반환하는 일반적인 JavaScript 함수이며, hooks를 통해 React의 여러 기능들을 사용할 수 있다.

### 장단…점?
클래스 컴포넌트는 하위 호환성 유지와 에러 경계 컴포넌트를 작성하기 위해 남아있을 뿐, 공식 문서에서도 함수형 컴포넌트를 작성하기를 권장하고 있다. 장단점을 논할 이유가 없다고 생각한다.

## 2. React의 라이프사이클에 대해 설명해주세요.
1. `Mount`: 컴포넌트가 화면에 ‘추가’된 상태
2. `Update`: 상호작용에 대한 응답으로 새로운 `props`나 `state`를 받아 ‘갱신’하는 상태
3. `Unmount`: 컴포넌트가 화면에서 ‘제거’된 상태

## 3. 생명주기 메서드
생명주기 메서드란 `Mount`, `Update`, `Unmount`되는 등, React 컴포넌트의 상태가 변경될 때 실행될 코드가 위치하는 특별한 메서드다.

### `constructor(props)`
컴포넌트가 `Mount`되기 전 호출된다. 주로 `state`를 초기화하거나 이벤트 핸들러를 바인딩하기 위해 사용된다.

### `componentDidMount()`
컴포넌트의 첫번째 렌더링이 완료된 후, 즉 `Mount` 상태일 때 호출된다. 

### `componentDidUpdate(prevProps, prevState, snapshot?)`
컴포넌트의 `props`나 `state`가 바뀌어 리렌더링이 일어났을 때, 즉 `Update` 상태일 때 호출된다.

### `componentWillUnmount()`
컴포넌트가 화면에서 제거되기 전에, 즉 `Unmount` 상태일 때 호출된다.

### `getSnapshotBeforeUpdate(prevProps, prevState)`
React가 DOM을 갱신하기 직전에 호출된다. 이 생명주기 메서드가 반환한 값은 `componentDidUpdate` 메서드의 `snapshot` 파라미터로 전달된다.

---

**React 생명주기 도표**

https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

## 4. 고차 컴포넌트
컴포넌트가 props를 입력으로 받아 UI를 반환하는 함수라면, 고차 컴포넌트는 컴포넌트를 입력으로 받아 새로운 컴포넌트를 반환하는 함수이다. 동일한 로직이 여러 컴포넌트에서 중복되는 경우, 이를 분리해내어 재사용할 수 있도록 하는 일종의 패턴이다.

계층적으로 나누어져 구성된 클라이언트 애플리케이션의 각 계층이 공통적으로 다루어야 하는 관심사를 해결하기 위해서 사용할 수 있다. 중복되는 로직의 재사용성을 높이고, 관심사 분리를 할 수 있다는 장점이 있지만 컴포넌트 계층 구조가 복잡해진다는 단점이 있다.

```jsx
// HOC에는 일반적으로 'with' 접두어가 붙음

// 클래스 컴포넌트 형태
function withConcern(WrappedComponent) {
  return class extends React.Component {
    constructor(props) {
      super(props);
    }
    
    componentDidMount() {
      const { propForThisConcern, ...propsForRender } = this.props;
      console.log('Log from mount');
      console.log(propForThisConcern);
    }
    
    render() {
      const { propForThisConcern, ...propsForRender } = this.props;
      return <WrappedComponent {...propsForRender} />
    }
  }
}

// 함수 컴포넌트 형태
const withConcern = (WrappedComponent) => (props) => {
  const { propForThisConcern, ...propsForRender } = props;
  
  useEffect(() => {
    console.log('Log from first render');
    console.log(propForThisConcern);
  }, []);

  return <WrappedComponent {...propsForRender} />
}
```

---

이해하기 좋았던 블로그 포스트: https://jeonghwan-kim.github.io/2022/05/28/react-high-order-component

## 5. 상태 관리 라이브러리 종류를 아는 대로 말해주세요.
### 클라이언트 상태 관리 라이브러리
Zustand, Jotai, Valtio, XState, Recoil, Redux, MobX

### 서버 상태 관리 라이브러리
Tanstack Query(React Query), SWR

## 6. 클라이언트 상태와 서버 상태의 차이?
### 클라이언트 상태
1. 내가 제어할 수 있는 위치(브라우저 또는 애플리케이션)에 존재함
2. 데이터를 쉽게 조회 및 수정할 수 있음
3. 데이터를 공유하지 않으며, 단일 사용자 환경에서만 유효함

### 서버 상태
1. 내가 제어하거나 소유하지 않는 위치에 존재함
2. 조회하거나 수정하기 위해 비동기 API를 필요로 함
3. 불특정 다수와 공유하며, 내가 모르는 사이에 변경될 수 있음
4. 최신 데이터가 아닐 수 있음

## 7. 에러 바운더리
React 16 버전에서 추가된 React만의 에러 처리 기능으로, 컴포넌트 렌더링 중에 일어나는 런타임 에러를 다루기 위해 작성하는 특수한 컴포넌트이다. 생명주기 메서드 중 `static getDerivedStateFromError()` 또는 `componentDidCatch()`를 구현하는 클래스 컴포넌트는 에러 경계 컴포넌트가 된다. 컴포넌트가 `Error`를 `throw`하면 컴포넌트 트리 상에서 가장 가까운 상위 에러 경계 컴포넌트가 해당 `Error`를 `catch`하며, 에러가 생긴 컴포넌트 트리 대신 ‘Fallback UI(대체 UI)’를 렌더링한다.

일일이 클래스 컴포넌트를 작성할 수도 있지만, `[react-error-boundary](https://github.com/bvaughn/react-error-boundary)` 패키지를 사용하는 것도 고려해볼 수 있다.

### 에러 경계 컴포넌트가 `catch`하지 않는 에러
1. 이벤트 핸들러에서 발생한 에러
2. 비동기 코드에서 발생한 에러
3. 서버 사이드 렌더링에서 발생하는 에러
4. 에러 경계 자체에서 발생하는 에러

## 8. Suspense
React 16 버전에서 추가된 React만의 로딩 상태 처리 기능으로, `children` 요소가 로드되기 전까지 해당 요소의 렌더링을 대기시키기 위해 사용하는 컴포넌트이다. Fallback UI를 제공하여 `children`이 로드되기 전까지 대신 렌더링될 Fallback UI를 제공할 수 있다.

에러 경계 컴포넌트에게 에러 처리 및 에러 발생 시 보여줄 UI에 대한 책임을 맡기는 것과 마찬가지로, 로딩 상태 처리 및 로딩 시 보여줄 UI에 대한 책임을 맡길 수 있기 때문에 컴포넌트가 정상적으로 데이터가 로드되었을 때의 UI 처리 책임만 가지도록 할 수 있게 된다.

`Suspense` 내부의 전체 트리는 하나의 단위로 취급되며, 같은 `Suspense` 아래에 그룹화된 컴포넌트들은 항상 동시에 그려지게 된다. 이때, 각 컴포넌트가 참조하는 `Suspense`는 자신에게서 가장 가까운 상위 `Suspense`이다.

### `Suspense`로 할 수 있는 것

1. **Code(JS Bundle) Splitting**
  - `React.lazy()`를 활용하면 컴포넌트를 동적으로 import하고 해당 컴포넌트가 렌더링되어야 할 때 비동기적으로 번들을 로드할 수 있으므로 초기 다운로드 번들의 크기를 줄일 수 있다.

2. **Data Fetching(Async Work)**
  - React가 18 버전으로 업데이트되며, `Suspense`를 사용해 코드 Lazy Loading 이외의 비동기 작업을 기다리는 데에도 사용할 수 있게 되었다.