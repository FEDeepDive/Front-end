## 1. 타입스크립트의 장점
### 정적 타입 언어

정적 타입 언어는 변수의 타입이 컴파일 타임에 결정되는 언어로 다음과 같은 장점이 있다.

1. 실행 시간에 변수의 타입을 결정하기 위한 작업을 하지 않아도 되며, 타입에 대한 정보를 미리 제공하기 때문에 더 나은 최적화가 가능해져 실행 시 효율적이다.
2. 컴파일 타임에 타입 관련 에러를 검출할 수 있기 때문에 디버깅이 용이하다.
3. 코드의 구조를 엄격하게 정의할 수 있기 때문에 깔끔하고 읽기 쉬운 코드를 작성할 수 있다.

### TypeScript?
TypeScript는 정적 타입 언어이기 때문에 위에서 언급한 장점들을 가진다. 또한 정적 타입 사용으로 인해 현대적인 IDE에서 지원 가능한 툴링(코드 힌팅, 자동 완성, 리팩토링 지원 등)의 종류가 많아 생산성이 높다는 장점도 있다.

## 2. type/interface 차이
|  | type | interface |
| --- | --- | --- |
| 명칭(번역) | Type alias(타입 별칭) | Interface(인터페이스) |
| 사용 가능 타입 | 어떤 타입이든 가능 | 객체 타입만 가능 |
| 확장하는 법 | & 기호를 사용 | extends 키워드를 사용 |
| 이미 있는 타입에 필드 추가 | 불가능 | 가능(선언 병합) |

공식 문서에서는 ‘타입 별칭이 필요해지기 전까지 인터페이스를 사용하라’고 한다.

Union 타입이나 Intersection 타입을 활용해 두 개 이상의 타입을 조합해야 하는 경우에는 타입 별칭이 더 유용할 수 있고, 타입을 쉽게 확장하거나 병합해야 하는 경우에는 인터페이스가 더 유용할 수 있다.

## 3. enum/object 차이
### `enum`
`enum`은 서로 연관된 상수의 집합으로, 흔히 ‘열거형’으로 번역된다. TypeScript에서 `enum`은 크게 숫자형과 문자열형의 두 가지로 구분된다. 그 자체가 타입으로 사용될 수 있어 별도로 타입 지정을 해줄 필요가 없다. 객체와 비슷하게 `Object.keys`와 `Object.values`를 이용한 순회가 가능하다.

### `object as const`
할당된 값 그 자체를 타입으로 취급하는 것을 리터럴 타입이라고 부르는데, 객체 선언 시 `as const`를 붙여줄 경우 해당 객체의 각 프로퍼티는 선언 시에 사용된 값과 동일한 리터럴 타입을 가지게 된다.

|  | `enum`  | `object as const` |
| --- | --- | --- |
| 사용되지 않는 코드 컴파일 타임에 삭제(Tree-shaking) | 불가능(`const`로 선언 시 가능) | 가능 |
| 컴파일 후 코드 크기 | 비교적 큼 | 비교적 작음 |

## 4. JS의 `any`와 TS의 `unknown`의 차이
### 상위/하위 타입
TypeScript는 타입의 내부 구조에 따라 호환성과 동등성이 결정되는 ‘구조적 타입 시스템(Structural Type System)’을 채택하였다. 구조적 타입 시스템에서는 두 객체가 동일한 프로퍼티를 가지고 있을 경우 두 객체의 타입이 적어도 서로 호환되며, 프로퍼티의 이름과 개수가 같을 경우 두 객체의 타입이 서로 같다고 정의할 수 있다. 이때 B 타입이 처리할 수 있는 모든 작업을 A 타입이 처리할 수 있다면 ‘A 타입은 B 타입의 `하위 타입`’, ‘B 타입은 A 타입의 `상위 타입`’이라고 하며 ‘B 타입은 A 타입을 포함한다’고 이야기한다.

```ts
// SubType의 모든 값은 SuperType의 값이기도 하므로...
// SuperType은 SubType을 포함한다!

type SuperType = { x: boolean; }
type SubType = { x: boolean; y: number; }
```

`any`와 `unknown`은 TypeScript의 모든 타입에 대해 상위 타입이며, 타입 시스템으로 표현 가능한 그 어떤 타입의 값이라도 할당할 수 있다. 이 둘을 묶어 ‘최상위 타입(Top Type)’이라고 부르지만, 둘은 서로 명확히 구분된다.

### `any`
최상위 타입은 모든 타입의 값을 가질 수 있지만, 그렇기 때문에 모든 타입의 값에 대해 공통적으로 적용할 수 있는 연산만이 가능하다. 그러나 `any`는 타입을 검사하지 않는 방식으로 에러를 잠재우기 때문에, 어떠한 연산을 적용하든 에러가 발생하지 않는다. `any` 타입의 값은 `never` 타입 이외의 모든 타입에 할당될 수 있다.

### `unknown`
`unknown`은 `any`의 타입 안전한 버전으로, 타입 시스템에서 표현 가능한 모든 값을 할당할 수 있지만 자기 자신과 `any`를 제외하고는 다른 타입에 바로 할당할 수 없다. 타입을 별도로 지정해주거나 타입 좁히기 등을 통해 구체적인 타입이 정해지고 난 후 비로소 해당 타입에 적용 가능한 연산을 수행할 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/637c457f-6134-4a8f-9161-1d9b4f4e20aa/31e54f9b-f9e0-4d5b-a2dd-f547a042d208/Untitled.png)

(초록색 ✓의 경우, **`strictNullChecks`** 옵션이 꺼져 있는 경우에만 호환됨)

`any`는 타입을 검사하지 않겠다고 컴파일러에게 말하는 것과 같기 때문에, 기존에 JavaScript로 작성된 코드베이스를 TypeScript로 옮기는 과정이 아니라면 `unknown`을 쓰는 것이 더 좋다.

## 5. `never` 타입에 대해 알고 있나요?
`never`는 TypeScript의 모든 타입에 대해 하위 타입이며, 타입 시스템에서 표현 가능한 값이 없다는 것을 의미한다. 흔히 최하위 타입(또는 바닥 타입, Bottom Type)으로 부르며, 타입 시스템을 집합으로 보았을 때 원소가 없는 공집합과 같다고 볼 수 있다.

`never`는 최하위 타입이기 때문에 모든 타입의 변수에 할당할 수 있지만, `never` 타입에는 `never`밖에 할당할 수 없다.

제어 흐름 분석 결과 도달할 수 없는 구문이 있을 경우 `never` 타입을 반환하는 것으로 이를 나타낼 수 있다. 이는 `never`가 표현 가능한 값이 없다는 의미를 가지기 때문에 가능하다.

```ts
function error(message: string): never {
  throw new Error(message);
}

function move(direction: "up" | "down" | "left" | "right") {
  switch (direction) {
    case "up": {
      return [0, 1];
    }
    case "down": {
      return [0, -1];
    }
    case "left": {
      return [-1, 0];
    }
    case "right": {
      return [1, 0];
    }
  }

  return error("Unreachable");
}
```

## 6. 배열과 튜플의 차이
일반적으로 ‘배열’은 같은 메모리 크기를 가지는(즉, 같은 타입의) 요소들의 모음으로, 각 요소가 적어도 하나의 인덱스(또는 키)에 대응되는 자료구조를 뜻한다. 각 요소는 자신을 가리키는 인덱스를 일정한 수학적 공식에 대입하여 얻어낼 수 있는 위치에 저장된다. 해당 인덱스에 접근하여 값을 읽거나 수정할 수 있다.

일반적으로 컴퓨터과학에서 ‘튜플’은 순서가 정해져 있으며 여러 개의 데이터 타입을 가지는 값들의 집합을 나타낸다. 튜플의 값이나 순서는 변경할 수 없으며, 다른 값이나 순서를 가지는 튜플을 원한다면 새로운 튜플을 만들어야 한다. 흔히 ‘레코드 타입’이라는 이름으로도 불리며, 함수형 프로그래밍에서는 흔히 ‘곱 타입(product type)’이라는 이름으로 나타낸다. 관계형 데이터베이스에서는 흔히 ‘행(row)’으로도 나타낸다.

### TypeScript에서 배열과 튜플의 차이
TypeScript에서 배열은 `Array` 타입으로 나타낼 수 있다. `type[]`과 같이 나타낼 수도 있고, 제네릭 타입 파라미터를 사용하여 `Array<type>`과 같이 나타낼 수도 있다.

TypeScript에서 튜플은 배열을 나타내는 `Array` 타입의 일종으로, 고정된 길이를 가지며 `[type1, type2]`와 같이 특정 위치에 어떤 타입의 값이 오는지 명시되어 있는 타입이다.

## 7. 제네릭과 제네릭의 유틸리티 타입

## 8. 유니온 타입과 인터섹션 타입에 대해 각각 한 문장으로 설명해주세요.

## 9. '타입 좁히기'를 예시를 들어 설명해주세요.

## 10. namespace
