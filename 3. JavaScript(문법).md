## 1. ES6에 추가된 문법

- **`const`**, **`let`** 키워드
- Arrow function(화살표 함수)
- Template Literals(템플릿 리터럴)
- Import and export(가져오기 및 내보내기)
- Promises(프로미스)
- Default parameters(기본 매개 변수)
- Array and object destructing(배열 및 객체 비구조화)
- Rest parameter and Spread operator(나머지 매개 변수 및 확산 연산자)
- Classes(클래스)

<br/>

## 2. **`var`**, **`const`**, **`let`** 의 차이점

**`var`** 는 변수, ES6에 도입된 **`let`** 과 **`const`** 는 각각 변수와 상수를 의미하고 **`var`**, **`const`**, **`let`** 세가지 모두 호이스팅이 발생한다.

**`var`** 는 선언과 동시에 **`undefined`** 로 초기화가 진행되기 때문에 **`var`** 가 선언되기 이전에 **`undefined`** 값을 참조할 수 있다.

**`const`** 와 **`let`** 은 선언만 된 상태이고 초기화가 되지 않아 \*TDZ에 빠져 참조 에러가 발생한다.

\* **호이스팅** : 자바스크립트 엔진이 소스코드를 한 줄 씩 실행하기 전에 모든 선언문을 찾아서 스코프의 상단으로 이동시키는 과정

\* **TDZ(Temporal Dead Zone)** : 일시적 사각 지대. 변수가 선언된 시점에서 변수가 초기화(값 할당)되기까지의 구간

\* **정리**

|        | **`var`** | **`let`** | **`const`** |
| ------ | --------- | --------- | ----------- |
| 재선언 | O         | X         | X           |
| 재할당 | O         | O         | X           |
| 스코프 | 전역/함수 | 블록      | 블록        |

<br/>

## 3. **`null`**, **`undefined`** ?

- **`null`**
  : 어떤 값이 의도적으로 비어있음을 표현하는 원시 값<br/>
  : 변수를 선언하고 빈 값을 할당한 상태<br/>
  : **`typeof null`** -> **`object`** (빈 객체를 가리킴)<br/>
  : 🚨 **`Number(null)`** // 결과 0

- **`undefined`**
  : **`undefined`** 값을 갖는 원시 값<br/>
  : 변수를 선언하고 값을 할당하지 않은 상태<br/>
  : **`typeof undefined`** -> **`undefined`**<br/>
  : 🚨 **`Number(undefined)`** // 결과 **`NaN`**

<br/>

## 4. **`NaN`**?

Not a Number 로 숫자가 아님을 나타내는 객체로 자기 자신과 일치하지 않는 유일한 값(**`NaN`** === **`NaN`** // **`false`**)

**NaN을 반환하는 5가지 연산**

- 숫자로써 읽을 수 없음.(ex. **`parseInt('문자열')`**, **`Number(undefined)`**)<br/>
- 결과가 허수인 계산식 (ex. **`Math.sqrt(-1)`**`)<br/>
- 정의할 수 없는 계산식 (ex. **`0 * Infinity`**, **`Infinity/Infinit`**)<br/>
- 문자열을 포함하면서 덧셈이 아닌 계산식(ex. **`"가" / 3 `**`)<br/>
- 피연산자가 **`NaN`** 인 계산식 (ex. **`7 * NaN`**)<br/>
- 유효하지 않은 값이 숫자로 표시되는 경우 (ex. **`new Data('abc').getTime()`**)<br/>

**🚨 `isNaN()` 과 `Number.isNaN()`의 차이점**

- **`isNaN()`** 함수의 경우 인수가 **`Number`** 형이 아니라면 강제로 **`Number`** 로 변환하여 **`NaN`** 인지 아닌지 확인한다. 즉 현재값을 **`Number`** 형으로 변환했을때, 혹은 현재값 그 자체가 **`NaN`** 일때만 참을 리턴
- **`Number.isNaN()`** 스태틱 메서드의 경우 인수가 **`Number`** 형이 아니라면 거짓을 리턴한다. 즉 **`Number`** 형 **`NaN`** 인 식의 값만이 참을 리턴

<br/>

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.

자바스크립트 엔진이 소스코드를 해석할 때 선언문, 반복문, 조건문등 문의 끝이라고 생각되는 지점에 세미콜론을 자동으로 붙여준다.
이것을 **세미콜론 자동 삽입 기능(ASI, Automatic Semicolon Insertion)** 라고 한다.

**ASI 세미콜론 삽입 규칙**<br/>
: 줄바꿈이 되는 행의 마지막에<br/>
: 행의 마지막이 `}` 이고 줄바꿈이 되어 다음 행이 시작될때<br/>
: 파일의 끝에 도달할 때<br/>
: **`return`** 이 있는 행의 마지막에<br/>
: **`break`** 가 있는 행의 마지막에<br/>
: **`throw`** 가 있는 행의 마지막에<br/>
: **`continue`** 가 있는 행의 마지막에<br/>

<br/>

## 6. `Symbol`에 대해 설명해주세요.

ES6에서 추가된 7번째 타입으로 다른값과 중복되지 않는 **변경 불가능한 유일무이한 원시타입의 값**이다.
심벌 값은 충돌 위험이 없는 오브젝트의 **유일한 프로퍼티 키**를 만들수 있다는 장점이 있다.

심벌 값은 문자열이나 숫자 값으로 암묵적으로 변환되지 않으며, 내부 확인할 수 없으며, for … in 문이나 Object.keys 등으로 내부 값을 찾을 수 없다.

따라서 이름에 의미를 두는 상수 값에 사용하거나 심벌 값을 프로퍼티 키로 사용하여 프로퍼티를 은닉하는데에 사용한다.

<br/>

## 7. `==` 과 `===` 의 차이가 무엇인가요?

- **`== (동등 비교)`** : 좌항과 우항의 피연산자를 비교할 때 먼저 **암묵적 타입 변환**을 통해 타입을 일치시킨 후 같은 값인지 비교한다.
- **`=== (일치 비교)`** : 좌항과 우항의 피연산자의 타입과 값을 **엄격하게 비교**한다. 두 피연산자의 타입도 같고 값도 같은 경우에만 true를 반환한다.
- **`NaN`** 은 자신과 일치하지 않는 유일한 값(ex. **`NaN === NaN`** // false). 따라서 숫자가 **`NaN`** 인지 조사하려면 빌트인 함수 **`Number.isNaN`** 를 사용한다.

<br/>

## 8. `for … of` / `for … in` 문

- **`for … of`** : 이터러블 순환
  ```jsx
  for (변수 선언문 of 이터러블) { ... }
  ```
- **`for … in`** : 객체 순환
  ```jsx
  for (변수 선언문 of 이터러블) { ... }
  ```

<br/>

## 9. `reduce` 사용법

```jsx
Array.prototype.reduce(callback, initialVal);
callback = (acc, cur, idx, arr) => {};
```

**`reduce()`** 메서드는 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복 호출한다. 콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 **하나의 결과값을 만들어 반환**한다. 이때 원본 배열은 변경되지 않는다.

이 때 매개변수로 전달받은 콜백함수를 리듀서 함수 **`reducer()`** 라고 한다. 리듀서는 4개의 인수를 받는다.

- **`acc (누산기)`** : 콜백 함수의 반환 값
- **`cur (현재 값)`** : 처리할 현재 요소
- **`idx (현재 인덱스)`** : 현재 요소(**`cur`**)의 인덱스
- **`src (원본 배열)`**: **`reduce()`** 를 호출 한 배열

<br/>

## 10. `splice`, `slice` 차이

- **`Array.prototype.splice(start, deleteCount, )`
  배열 기존요소를 삭제하거나 새 요소를 추가하여** 원본 배열의 내용을 변경한다.
  - **`start`** : 배열의 변경을 시작할 인덱스. 음수로 지정한 경우 배열의 끝에서부터 요소를 센다.
  - **`deleteCount(option)`** : 배열에서 제거할 요소의 수
  - **`item1, item2(option)`** : 배열에 추가할 요소
- **`Array.prototype.slice(start, end)`**
  어떤 배열의 start부터 end까지에 대한 얕은 복사본을 **새로운 배열 객체**로 반환한다.
  - **`start(option)`** : 추출 시작점으로 빈 값일경우 0
  - **`end(option)`** : 추출 끝점으로 빈 값일 경우 배열의 끝까지 slice
- **`String.prototype.split(separator)`**
  구분자를 이용하여 여러개의 문자열로 나눈다.
  - **`separator(option)`** : 끊어야 할 부분을 나타내는 문자열

<br/>

## 11. 옵셔널 체이닝

## 12. NULL 병합 연산자(`??`)는 무엇인가요?

## 13. 단축평가

## 14. Promise

## 14-1. Promise란 무엇이며, async/await과 어떻게 다른지, 왜 async/await이 등장했는지?

## 14-2. Promise나 async/await를 es5로 트랜스파일하면 어떻게 되나요?

## 15. 클로저(Closure)란 무엇인가요?

## 16. 구조 분해 할당(Destructuring assignment)이란?

## 17. 전개 구문(Spread syntax)이란?

## 18. 나머지 매개변수(Rest parameters)란?

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

## 20-1. `bind`를 `apply`, `call`로 어떻게 구현할 수 있을까요? 구현해보세요.
