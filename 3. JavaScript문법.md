## 1. ES6에 추가된 문법

```
💡 `let`, `const`, 화살표 함수, 클래스, 모듈, 프로미스 등이 추가되었습니다. 템플릿 리터럴, 객체 리터럴 기능이 향상되었고, `String`, `Array`, `Object` 등의 객체에 메서드들이 추가되었습니다.
```

- **`let`, `const`**
- **화살표 함수(Arrow Function)**
- **매개변수 기본값, Spread 연산자, Rest 파라미터**
- **구조분해할당(Destructuring)**
- **클래스**
- **모듈**
- **프로미스**
- **`Symbol`**
- **`Map`, `Set`**
- **이터레이션(Iteration) + `for...of`**
  - 이터레이션 프로토콜을 준수한 객체는 `for...of` 순회 가능
  - `for...of`: 이터레이터의 `next()`를 호출하여 이터러블을 순회
  - 참고: [이터레이션과 for...of 문](https://poiemaweb.com/es6-iteration-for-of)
- **제너레이터(Generator)**
  - 이터러블을 생성하는 함수
  - 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편함
  - ES7의 `async/await`과 함께 사용 가능
- **향상된 템플릿 리터럴**
  - 문자열 보간 (ex. `변수는 ${variable}`)
  - 여러 줄의 문자열 O
- **향상된 객체 리터럴**
  - 프로퍼티 축약 표현 (프로퍼티 값으로 변수 사용 시, 프로퍼티 이름 생략 가능)
  - 메소드 축약 표현 (`function` 키워드 생략 O)
  - 프로퍼티 키 동적 생성 O (ex. `obj[i + '-th'] = i`)
  - 참고: [객체 리터럴 프로퍼티 기능 확장](https://poiemaweb.com/es6-enhanced-object-property)
- **`String`, `Array`, `Object` 등의 메서드 추가**

```
💡 이외에도 매우 많음. 자세한 건 [공식 문서](https://262.ecma-international.org/6.0/) 확인.
참고로, ES6(=ECMAScript2015) 이후부터는 ECMA2016처럼 년도로 표기함.
```

## 2. `var`, `const`, `let`의 차이점

```
💡 `var`는 재선언, 재할당이 불가능하고, 함수 또는 글로벌 스코프를 갖습니다. 반면 `let`, `const`는 재선언이 불가능하고, 블록 레벨 스코프를 갖습니다. `let`은 재할당이 가능하지만, `const`는 재할당이 불가능합니다.
```

|  | var | let | const |
| --- | --- | --- | --- |
| 재선언 | O | X | X |
| 재할당 | O | O | X |
| 스코프 | 함수 안 선언 시 함수 범위, 이외에는 전역 범위 | 블록({}) 범위 | 블록({}) 범위 |
| 호이스팅 | O, undefined로 초기화 | O, 초기화 X ⇒ 선언 전 사용 시 Reference Error | O, 초기화 X ⇒ 선언 전 사용 시 Reference Error |
| 기타 특성 | var 키워드 생략 가능 |  | 선언과 동시에 할당 필요 |

## 3. `null`, `undefined`?

```
💡 `null`은 빈 값이고, `undefined`는 값이 할당되지 않은 상태를 가리킵니다.
```

- `null`: 값이 비어있음
  - type: **object**
  - 빈 객체를 가리키는 객체 포인터
- `undefined`: 자료형이 지정되지 않음 (값이 할당되지 않아서)
  - type: undefined

## 4. `NaN`?

```
💡 `NaN`은 숫자가 아닌 값을 나타냅니다. 주로(항상이 아님) 숫자가 아닌 값을 숫자처럼 사용하려고 하는 경우에 `NaN`이 반환됩니다.
```

- **개념**
  - Not a Number, 즉 숫자가 아님을 나타냄
- **특징**
  - type: Number
  - 설정 불가능, 쓰기 불가능
  - `NaN === NaN` ⇒ `false`
    - [이유](https://velog.io/@eunbeann/Why-NaN-NaN-is-False): `NaN`은 다른 어떤 값과도 (자기 자신 포함) 같지 않음
    - 따라서 `NaN`인지 판별할 때 `isNaN()` 사용
- **`NaN`이 반환되는 상황**
  - 숫자로 변환 실패 (ex. `Number('abc')`)
  - 결과가 허수인 수학 계산식 (ex. `Math.sqrt(-1)`)
  - 정의할 수 없는 계산식 (ex. `0 * Infinity`, `Infinity/Infinity`)
  - `NaN` 연산 (ex. `7 * NaN`, `7 * 'abc'`) ⇒ `**NaN`은 전염성을 가짐\*\*
  - 유효하지 않은 값이 숫자로 표시되는 경우 (ex. `new Data('abc').getTime()`)

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.

```
💡 JavaScript 코드는 세미콜론이 없어도 에러가 나지 않으며, 세미콜론이 없을 경우 인터프리터가 자동으로 삽입해주기 때문입니다.
```

- **이유**
  - 세미콜론이 없어도 에러가 나지 않음
  - 세미콜론이 없을 경우, 인터프리터가 자동으로 삽입해주기 때문(=ASI (Automatic Semicolon Insertion, 자동 세미콜론 삽입))
- **번외**
  - **세미콜론 쓰면 좋은 점**
    - 가독성
    - 안전성
    - 범용성
  - **세미콜론 안 쓰면 좋은 점**
    - 코드 라인 위치 변경이 용이함
      ```jsx
      array
      	.map(...)
      	.filter(...) // 세미콜론이 없으면 라인 위치 변경이 간편함
      ```

## 6. `Symbol`에 대해 설명해주세요.

- **개념**
  - ES6에서 추가된 7번째 원시형 타입
  - 유일성이 보장됨
  - “심볼 이름”(또는 “심볼 설명”)을 가짐
    - 두 심볼이 서로 동일한 심볼 설명을 가져도 심볼값은 서로 다름
    - ⇒ 심볼 이름은 진짜 이름표 역할만 함
- **목적**
  - 숨겨진 프로퍼티, 유니크한 식별자를 만들기 위해 사용됨
- **특징**
  - `for..in` 반복문에서 배제됨 (non-Symbol이어야 순회함)
- **참고**
  - [심볼형](https://ko.javascript.info/symbol)

## 7. `==` 과 `===` 의 차이가 무엇인가요?

```
💡 엄격한 동등 연산자(`===`)는 피연산자의 타입이 서로 다른 경우 `false`를 반환합니다.
하지만 느슨한 동등 연산자(`==`)는 피연산자의 타입이 서로 다른 경우 타입 변환을 시도한 후 값을 비교합니다.
따라서 정확한 값 비교를 원한다면 엄격한 동등 연산자(`===`)를 사용하는 것이 좋습니다.
```

|  | 느슨한 동등 연산자(==) | 엄격한 동등 연산자(===, 일치 연산자) |
| --- | --- | --- |
| 비교 값 | 값 | 값 & 타입 |
| 연산 과정 | 타입이 다른 경우 타입 변환 후 비교 | 동등 연산자와 동일 but 타입이 다른 경우 바로 `false` 반환 |

**💡자세한 내용은 [MDN 동등 비교 및 동일성](https://developer.mozilla.org/ko/docs/Web/JavaScript/Equality_comparisons_and_sameness#loose_equality_using) 참고**

## 8. `for … of` / `for … in` 문

### `for...in`

- **순회 대상**
  - 모든 객체
  - 객체의 모든 \*열거가능(enumerable)하고 non-Symbol인 속성에 대해 반복
    - \*열거 속성: 내부의 열거 가능 플래그 `[[Enumerable]]`가 `true`인 속성
- **특징**
  - 객체의 key에만 접근 가능
  - 임의의 순서로 반복(=순서 보장 X)
  - 객체의 프로토타입까지 순회 가능
- **등장 시기**: ES1

### `for...of`

- **순회 대상**
  - 이터러블 객체(`[Symbol.iterator]` 속성을 갖고 있는 객체)
- **특징**
  - 객체의 key, value에 접근 가능
  - `await` 사용 가능 (`for-await-of`)
- **등장 시기**: ES6

### `Array.prototype.forEach`

- **순회 대상**: Array, Map
- **장점**
  - 배열의 요소와 인덱스에 접근 가능
  - 콜백 함수를 따로 짤 수 있음 & 화살표 함수 사용 가능
- **단점**
  - 루프 내부에서 `await` 사용이 불가
  - 반복 흐름을 제어하지 못함 (`break`, `continue` 불가능)
- **등장 시기**: ES5

### 참고

- [for...of와 for..in의 차이](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of#difference_between_for...of_and_for...in)
- [for vs for-in vs forEach vs for-of 무엇으로 자바스크립트 리스트를 돌아야 하나](https://yceffort.kr/2021/06/best-solution-for-looping-over-array)

## 9. `reduce` 사용법

```
💡 `reduce`는 배열의 각 요소에 대해 함수를 실행하고, 그 결과를 누산기에 누적하여 최종 누적 결과를 얻을 때 사용됩니다.
```

- **개념**

  - 배열을 순회하며 각 요소에 대한 함수를 실행 ⇒ 함수 반환값을 누적하여 하나의 결과값을 반환함

- **구문**

  ```jsx
  // 물음표(?)로 끝나는 변수는 Optional

  const 누적된결과값 = array.reduce(
    (누산기, 현재요소, 현재인덱스?, _호출한배열?) => {
      return 누산기에_누적할_값;
    },
    누산기초기값?,
  );
  ```

  - `array.reduce(콜백, 누산기초기값?)`
    - 콜백 매개변수
      - `누산기`: 콜백의 반환 값을 누적함
      - `현재요소`
      - `현재인덱스?`
      - `호출한배열?`: `reduce()`를 호출한 배열
    - `누산기초기값?`: 콜백 최초 호출 시 누산기 초기값으로 할당할 값. 없으면 배열의 첫 번째 요소 사용. (빈 배열 + 초기값도 없으면 오류 발생)
  - 반환값: 누산기의 최종 값

- **예시**
  ```jsx
  // 배열의 모든 원소 더하기
  const numbers = [1, 2, 3, 4];
  const sum = numbers.reduce((sum, num) => sum + num, 0);
  console.log(sum); // 10
  ```

## 10. `splice`, `slice`, `split` 차이

```
💡 `splice`와 `slice`는 배열의 특정 구간을 추출한다는 점에서 비슷합니다.
하지만 `splice`는 원본 배열을 변형하고, 배열 삭제와 추가 모두 가능한 반면,
`slice`는 원본을 변형하지 않고, 특정 부분을 획득하는 데 목적이 있다는 점에서 다릅니다.
`split`은 문자열을 구분자로 끊어 배열로 만들 때 사용됩니다.
```

|  | splice | slice | split |
| --- | --- | --- | --- |
| 목적 | 배열에 요소 삽입/삭제/교체를 통한 배열 내용 변경 | 배열/문자열의 특정 구간 획득 | 문자열을 특정 구분자로 나눔 |
| 원본변형 | O | X | X |
| 반환값 | 제거한 구간 배열 | 추출한 구간 배열 | 구분자로 나눈 결과 배열 |
| 매개변수(\*:옵셔널) | `시작 인덱스`, `*삭제할 요소 개수`, `*배열에 추가할 요소들` | `*시작 인덱스`, `*종료 인덱스(구간에 미포함)` | `*구분자`, `*끊어진 문자열의 최대 개수` |
| 매개변수 특징 | 인덱스가 음수(-n)면, 뒤에서 n번째로 계산 | 인덱스가 음수(-n)면, 뒤에서 n번째로 계산 |  |

## 11. 옵셔널 체이닝

## 12. NULL 병합 연산자(`??`)는 무엇인가요?

## 13. 단축평가

## 14. Promise

## 14-1. Promise란 무엇이며, async/await과 어떻게 다른지, 왜 async/await이 등장했는지?

## 14-2. Promise나 async/await를 es5로 트랜스파일하면 어떻게 되나요?

## 15. 클로저(Closure)란 무엇인가요?

## 16. 구조 분해 할당(Destructuring assignment)이란?

## 17. 전개 구문(Spread syntax)이란?

## 18. 나머지 매개변수(Rest parameters)란?

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

## 20-1. `bind`를 `apply`, `call`로 어떻게 구현할 수 있을까요? 구현해보세요.
