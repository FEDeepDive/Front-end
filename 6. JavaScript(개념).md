## 1. 얕은 복사와 깊은 복사의 차이
🚨 일반적으로 모든 프로퍼티가 원시 타입인 객체는 중첩된 프로퍼티가 없기 때문에, 그러한 객체의 복사에 대해서는 이야기하지 않는다!

### 얕은 복사
두 객체 `o1`, `o2` 가 서로 같은 객체가 아니면서 다음의 특징을 만족하는 경우, 해당 두 객체는 얕은 복사다.

1. `o1` 과 `o2` 의 각 프로퍼티가 서로 같은 이름과 순서를 가진다.
2. 두 객체의 프로토타입 체인이 동일하다.
3. 두 객체의 각 프로퍼티에 대한 값이 동일하다.

```js
const obj = { a: 42, b: { c: 42, d: () => 'Hello' } };

// 여러 가지 복사 방법
const obj2 = { ...obj };
const obj3 = Object.assign({}, obj);

// result: false
console.log(obj === obj2);

// result: false
console.log(obj === obj3);

// result: true
console.log(obj.b === obj2.b);

// result: true
console.log(obj.b === obj3.b);
```

### 깊은 복사
두 객체가 얕은 복사 조건 1과 2를 만족하는 상황에서, 두 객체의 각 프로퍼티에 대한 값이 동일하지는 않으나 그 구조가 같은 경우, 해당 두 객체는 깊은 복사다.

```js
const obj = { a: 42, b: { c: 'Hello' } };

// structuredClone() 이전의 깊은 복사 방법
const obj2 = JSON.parse(JSON.stringify(obj));

// result: false
console.log(obj.b === obj2.b);
```

### `structuredClone()`
기존에 자주 사용되던 `JSON.stringify`  후 `JSON.parse` 하는 방법은 순환 참조가 존재하거나, `Map` /`Set` 등의 객체에 대한 깊은 복사를 수행할 수 없었다. `structuredClone()` 을 사용하면 이러한 객체들에 대해서도 깊은 복사를 수행할 수 있다. 그러나 함수 또는 `symbol` , DOM 객체 등은 애초에 직렬화가 불가능한 객체이며, 따라서 `structuredClone()` 으로도 이러한 객체들은 깊은 복사를 수행할 수 없다.

## 2. 문(statement)과 표현식(expression)의 차이
### 문

자바스크립트 프로그램은 연속된 문으로 이루어지며, 각 문은 컴퓨터가 프로그램을 실행하며 처리해야 하는 동작에 대한 명령이다. 문은 표현식과 키워드로 구성되며, 세미콜론으로 끝난다. 자바스크립트 코드를 작성할 때, 문을 통해 프로그램의 구조를 잡는다고 생각할 수 있다.

### 표현식
표현식은 하나의 값을 생성하는 자바스크립트 코드이며, 다른 표현식의 일부가 되어 더욱 복잡한 표현식을 구성할 수 있다. 리터럴 또한 값을 생성하기 때문에 표현식이고, 연산자와 리터럴을 통해 표현된 코드 또한 표현식이다.

어떠한 자바스크립트 코드가 문인지 표현식인지 알기 위해서는 함수의 인자로 제공해볼 수 있다. 함수의 인자는 항상 표현식이어야 하기 때문에, 문을 인자로 제공하는 경우 오류가 발생한다.

## 3. JavaScript Module System
### 모듈 시스템의 등장 배경
초기 자바스크립트는 웹 페이지에 약간의 상호작용성을 부여하기 위해 사용될 뿐이었기에 일반적으로 큰 스크립트가 필요하지 않았지만, 현대의 자바스크립트는 브라우저 환경에서 실행 가능한 하나의 거대한 애플리케이션이나 서버/커맨드라인 프로그램을 작성하는 데에도 사용하게 되었다. 일정 규모 이상이 되면 하나의 파일로 모든 코드를 관리할 수 없어지기 때문에 관련있는 코드들끼리 모아서 분리하고 필요한 것들만 가져올 수 있게 하는 기능이 필요해졌으며, 그렇게 모듈 시스템이 등장하게 되었다.

### CommonJS
자바스크립트를 단순 브라우저용이 아닌 범용 언어로 쓰일 수 있도록 하겠다는 목표를 가진 CommonJS 그룹이 정의하는 방식의 모듈 시스템이다. 다른 모듈을 사용하기 위해서는 `require()` 문을, 외부에 공개하기 위해서는 `module.exports` 라는 속성을 사용한다. 동기 방식으로 작동하기 때문에, 모든 코드가 이미 로컬에 존재하는 서버 측에서 사용하기 편하다는 특징을 가지고 있다.

### ESM(ES Module)
자바스크립트는 ES6에서 공식적으로 문법 수준 모듈 시스템이 도입되었으며, 이를 ESM이라고 부른다. 다른 모듈을 사용하기 위해 `import` 문을, 외부에 공개하기 위해 `export` 문을 사용한다. CommonJS와 달리 각 모듈을 비동기적으로 가져오기 때문에, 브라우저에서도 사용하기 좋다는 특징이 있다.

### CommonJS vs. ES Module
CommonJS 방식은 가져오기와 내보내기가 동적으로 이루어질 수 있는 구조였으며, 때문에 실행 시간에만 모듈 관계를 파악할 수 있어 빌드 단계에 정적 분석을 적용하기 어렵다는 문제가 있었다. ESM에서는 정적인 구조로 모듈끼리 의존하도록 구성하여, 빌드 단계에서 정적 분석을 통해 모듈 간의 의존 관계를 파악할 수 있다.

### Dynamic import
ESM을 사용하는 경우, 일반적으로는 정적 import를 사용하면 되겠지만 모듈을 동적으로 불러와야 하는 경우가 생길 경우, `import(modulePath)`  **표현식**을 이용할 수 있다. 해당 표현식은 모듈이 내보내는 것들을 모두 포함하는 객체를 담은 Promise를 반환한다.

## 4. node.js와 그냥 js의 차이
Node.js는 Google Chrome을 만들기 위한 프로젝트인 Chromium Project에서 개발된 자바스크립트 엔진 V8에서 동작하는 자바스크립트 런타임 환경이다. 자바스크립트는 일반적으로 웹 브라우저에 내장되어 동적 웹페이지를 생성하는 데에 쓰이지만, Node.js를 통해 자바스크립트를 서버 측 스크립팅은 물론 커맨드라인 도구를 작성하는 데에 사용할 수 있게 되었다.

## 5. iterable, iterator, 유사 배열 객체
### 순회 프로토콜(iteration protocol)
ES6에서 도입된 순회 프로토콜은 데이터 컬렉션을 순회할 수 있도록 미리 약속된 규칙이다.

### 순회 가능 프로토콜(iterable protocol)
순회 가능 프로토콜은 `Symbol.iterator` 메서드를 구현하거나, 프로토타입 체인에 의해 상속받은 객체를 뜻한다. 이러한 객체를 순회 가능하다고 말하며, 순회 가능한 객체는 `for ... of` 문을 통해 순회하거나 전개 구문의 대상으로 사용할 수 있다.

### 반복자 프로토콜(iterator protocol)
반복자 프로토콜은 `value`, `done` 프로퍼티를 가지는 결과 객체를 반환하는 `next` 메서드를 구현한 객체를 뜻한다. `next` 메서드를 통해 데이터 컬렉션의 각 요소를 한 단계씩 순회할 수 있으며, 결과 객체의 `value` 프로퍼티는 반복자가 현재 가리키고 있는 데이터 컬렉션의 값, `done` 프로퍼티는 반복자의 순회 완료 여부를 나타낸다.

### 유사 배열 객체
유사 배열 객체는 숫자를 키로 가지는 프로퍼티(즉 인덱스)와 `length` 프로퍼티를 가지는 객체이다. 따라서 마치 배열처럼 인덱스를 통해 요소에 접근할 수 있지만, `Array.prototype`으로부터 상속받은 메서드가 없기 때문에 바로 배열처럼 사용할 수는 없으며 대신 `Object.apply`나 `Object.call` 등을 통해 배열의 메서드를 빌려와 사용하면 된다.

여러 DOM 객체(`NodeList`, `HTMLCollection` 등) 또는 `arguments` 객체 등을 예로 들 수 있다.

## 6. generator
일반적인 함수는 한 번의 호출로 끝까지 실행되어 하나의 값만을 반환(return)하지만, 제너레이터 함수는 실행을 일시적으로 중지했다가 필요한 시점에 다시 시작할 수 있으며 여러 개의 값을 필요에 따라 하나씩 반환(yield)할 수 있다. 즉, 제너레이터 함수는 순회 가능한 객체를 반환하는 특수한 함수라고 할 수 있다.

ES6에서 처음 도입된 제너레이터는 `function*` 키워드를 통해 정의할 수 있으며, `return` 대신 `yield` 키워드를 통해 값을 반환할 수 있다. 순회 가능한 객체를 생성하기 위해 순회 프로토콜을 준수하는 방식보다 간편하게 구현할 수 있으며, 지연 평가(lazy evaluation)되기 때문에 무한 자료구조를 사용할 수 있다는 장점이 있다.

```js
function* integers() {
  let i = 0;

  while (true) {
    i += 1;
    yield i;
  }
}

const int = integers();

// result: 1
console.log(int.next().value);
// result: 2
console.log(int.next().value);
// result: 3
console.log(int.next().value);
```

## 7. polyfill이란 무엇인가요?
폴리필은 최신 브라우저에서는 제공하지만 이전 브라우저가 지원하지 않는 기능을 구현한 별도의 코드를 뜻한다. 폴리필을 사용하면 폭넓은 브라우저를 지원할 수 있다는 장점이 있지만, 그만큼 불러와야 하는 자바스크립트 코드가 늘어난다는 단점이 있다.

특히, 최신 버전의 브라우저에는 이미 구현되어있기 때문에 내려받을 필요가 없는 코드도 내려받을 가능성이 있다. 이러한 문제를 해결하기 위해서 지원할 브라우저를 명시하여 꼭 필요한 폴리필만 포함시키거나, 사용 중인 브라우저에 따라 동적으로 폴리필 스크립트를 생성하는 방법 등을 사용할 수 있다.