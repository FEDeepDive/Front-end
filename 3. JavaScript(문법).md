## 1. ES6에 추가된 문법

- **`const`**, **`let`** 키워드
- Arrow function(화살표 함수)
- Template Literals(템플릿 리터럴)
- Import and export(가져오기 및 내보내기)
- Promises(프로미스)
- Default parameters(기본 매개 변수)
- Array and object destructing(배열 및 객체 비구조화)
- Rest parameter and Spread operator(나머지 매개 변수 및 확산 연산자)
- Classes(클래스)

<br/>

## 2. **`var`**, **`const`**, **`let`** 의 차이점

**`var`** 는 변수, ES6에 도입된 **`let`** 과 **`const`** 는 각각 변수와 상수를 의미하고 **`var`**, **`const`**, **`let`** 세가지 모두 호이스팅이 발생한다.

**`var`** 는 선언과 동시에 **`undefined`** 로 초기화가 진행되기 때문에 **`var`** 가 선언되기 이전에 **`undefined`** 값을 참조할 수 있다.

**`const`** 와 **`let`** 은 선언만 된 상태이고 초기화가 되지 않아 \*TDZ에 빠져 참조 에러가 발생한다.

\* **호이스팅** : 자바스크립트 엔진이 소스코드를 한 줄 씩 실행하기 전에 모든 선언문을 찾아서 스코프의 상단으로 이동시키는 과정

\* **TDZ(Temporal Dead Zone)** : 일시적 사각 지대. 변수가 선언된 시점에서 변수가 초기화(값 할당)되기까지의 구간

\* **정리**

|        | **`var`** | **`let`** | **`const`** |
| ------ | --------- | --------- | ----------- |
| 재선언 | O         | X         | X           |
| 재할당 | O         | O         | X           |
| 스코프 | 전역/함수 | 블록      | 블록        |

<br/>

## 3. **`null`**, **`undefined`** ?

- **`null`**
  : 어떤 값이 의도적으로 비어있음을 표현하는 원시 값<br/>
  : 변수를 선언하고 빈 값을 할당한 상태<br/>
  : 🚨 **`Number(null)`** // 결과 0

- **`undefined`**
  : **`undefined`** 값을 갖는 원시 값<br/>
  : 변수를 선언하고 값을 할당하지 않은 상태<br/>
  : 🚨 **`Number(undefined)`** // 결과 **`NaN`**

<br/>

## 4. **`NaN`**?

Not a Number 로 숫자가 아님을 나타내는 객체로 자기 자신과 일치하지 않는 유일한 값(**`NaN`** === **`NaN`** // **`false`**)

**NaN을 반환하는 5가지 연산**

- 숫자로써 읽을 수 없음.(ex. **`parseInt('문자열')`**, **`Number(undefined)`**)<br/>
- 결과가 허수인 계산식 (ex. **`Math.sqrt(-1)`**`)<br/>
- 정의할 수 없는 계산식 (ex. **`0 * Infinity`**, **`Infinity/Infinit`**)<br/>
- 문자열을 포함하면서 덧셈이 아닌 계산식(ex. **`"가" / 3 `**`)<br/>
- 피연산자가 **`NaN`** 인 계산식 (ex. **`7 * NaN`**)<br/>
- 유효하지 않은 값이 숫자로 표시되는 경우 (ex. **`new Data('abc').getTime()`**)<br/>

**🚨 `isNaN()` 과 `Number.isNaN()`의 차이점**

- **`isNaN()`** 함수의 경우 인수가 **`Number`** 형이 아니라면 강제로 **`Number`** 로 변환하여 **`NaN`** 인지 아닌지 확인한다. 즉 현재값을 **`Number`** 형으로 변환했을때, 혹은 현재값 그 자체가 **`NaN`** 일때만 참을 리턴
- **`Number.isNaN()`** 스태틱 메서드의 경우 인수가 **`Number`** 형이 아니라면 거짓을 리턴한다. 즉 **`Number`** 형 **`NaN`** 인 식의 값만이 참을 리턴

<br/>

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.

자바스크립트 엔진이 소스코드를 해석할 때 선언문, 반복문, 조건문등 문의 끝이라고 생각되는 지점에 세미콜론을 자동으로 붙여준다.
이것을 **세미콜론 자동 삽입 기능(ASI, Automatic Semicolon Insertion)** 라고 한다.

**ASI 세미콜론 삽입 규칙**<br/>
: 줄바꿈이 되는 행의 마지막에<br/>
: 행의 마지막이 `}` 이고 줄바꿈이 되어 다음 행이 시작될때<br/>
: 파일의 끝에 도달할 때<br/>
: **`return`** 이 있는 행의 마지막에<br/>
: **`break`** 가 있는 행의 마지막에<br/>
: **`throw`** 가 있는 행의 마지막에<br/>
: **`continue`** 가 있는 행의 마지막에<br/>

<br/>

## 6. `Symbol`에 대해 설명해주세요.

ES6에서 추가된 7번째 타입으로 다른값과 중복되지 않는 **변경 불가능한 유일무이한 원시타입의 값**이다.
심벌 값은 충돌 위험이 없는 오브젝트의 **유일한 프로퍼티 키**를 만들수 있다는 장점이 있다.

심벌 값은 문자열이나 숫자 값으로 암묵적으로 변환되지 않으며, 내부 확인할 수 없으며, **`for … in`** 문이나 **`Object.keys`**` 등으로 내부 값을 찾을 수 없다.

따라서 이름에 의미를 두는 상수 값에 사용하거나 심벌 값을 프로퍼티 키로 사용하여 프로퍼티를 은닉하는데에 사용한다.

<br/>

## 7. `==` 과 `===` 의 차이가 무엇인가요?

- **`== (동등 비교)`** : 좌항과 우항의 피연산자를 비교할 때 먼저 **암묵적 타입 변환**을 통해 타입을 일치시킨 후 같은 값인지 비교한다.
- **`=== (일치 비교)`** : 좌항과 우항의 피연산자의 타입과 값을 **엄격하게 비교**한다. 두 피연산자의 타입도 같고 값도 같은 경우에만 true를 반환한다.
- **`NaN`** 은 자신과 일치하지 않는 유일한 값(ex. **`NaN === NaN`** // false). 따라서 숫자가 **`NaN`** 인지 조사하려면 빌트인 함수 **`Number.isNaN`** 를 사용한다.

<br/>

## 8. `for … of` / `for … in` 문

- **`for … of`** : 컬렉션 순환, 순서 보장 O
  ```jsx
  for (변수 선언문 of 컬렉션) { ... }
  ```
- **`for … in`** : 객체 순환, 순서 보장 X
  ```jsx
  for (변수 선언문 of 객체) { ... }
  ```

<br/>

## 9. `reduce` 사용법

```jsx
Array.prototype.reduce(callback, initialVal);
callback = (acc, cur, idx, arr) => {};
```

**`reduce()`** 메서드는 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복 호출한다. 콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 **하나의 결과값을 만들어 반환**한다. 이때 원본 배열은 변경되지 않는다.

이 때 매개변수로 전달받은 콜백함수를 리듀서 함수 **`reducer()`** 라고 한다. 리듀서는 4개의 인수를 받는다.

- **`acc (누산기)`** : 콜백 함수의 반환 값
- **`cur (현재 값)`** : 처리할 현재 요소
- **`idx (현재 인덱스)?`** : 현재 요소(**`cur`**)의 인덱스
- **`src (원본 배열)?`**: **`reduce()`** 를 호출 한 배열

<br/>

## 10. `splice`, `slice` 차이

- **`Array.prototype.splice(start, deleteCount?, item1?, item2?)`**<br/>
  배열 기존요소를 삭제하거나 새 요소를 추가하여 원본 배열의 내용을 변경한다.
  - **`start`** : 배열의 변경을 시작할 인덱스. 음수로 지정한 경우 배열의 끝에서부터 요소를 센다.
  - **`deleteCount?`** : 배열에서 제거할 요소의 수
  - **`item1?, item2?`** : 배열에 추가할 요소
- **`Array.prototype.slice(start, end)`**<br/>
  어떤 배열의 start부터 end까지에 대한 얕은 복사본을 **새로운 배열 객체**로 반환한다.
  - **`start(option)`** : 추출 시작점으로 빈 값일경우 0
  - **`end(option)`** : 추출 끝점으로 빈 값일 경우 배열의 끝까지 slice
- **`String.prototype.split(separator)`**<br/>
  구분자를 이용하여 여러개의 문자열로 나눈다.
  - **`separator(option)`** : 끊어야 할 부분을 나타내는 문자열

<br/>

## 11. 옵셔널 체이닝

```jsx
const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah',
  },
};

// ? 앞의 dog가 undefined이므로 평가를 멈추고 undefined를 반환
const dogName = adventurer.dog?.name;
console.log(dogName);
// Expected output: undefined
```

**`?.`** **"앞"** 의 평가 대상이 **`undefined`** 나 **`null`** 이라면 평가를 멈추고 **`undefined`** 를 반환하고, 그렇지 않으면 오른쪽 프로퍼티 참조를 이어간다.

ES11(ECMAScript2020)에 도입되어 중첩 객체에서 특정 프로퍼티에 **`nullish`** 체크 없이 접근할 수 있다.

반드시 값을 필요로 하는 대상에 옵셔널 체이닝을 사용하게 되면 값이 필요로 하는 값이 할당되지 않는 오류가 발생할 수 있으므로 남용하면 안된다.

<br/>

## 12. NULL 병합 연산자(`??`)는 무엇인가요?

```jsx
const foo = null ?? 'default string';
console.log(foo);
// Expected output: "default string"

const baz = 0 ?? 42;
console.log(baz);
// Expected output: 0
```

왼쪽 피연산자가 **`null`** 또는 **`undefined`** 일 경우 오른쪽 피 연산자를 반환하고 그렇지 않으면 왼쪽 피연산자를 반환한다.

ES11(ECMAScript2020)에 도입되어 변수에 **기본값을 설정할 때 유용** 하다.

<br/>

## 13. 단축평가

**표현식을 평가하는 도중에 평가결과가 확정된 경우 나머지 평가 과정을 생략**하는 것

- **논리곱(`&&`) 연산자**
  두 개의 피연산자가 모두 true로 평가 될 때 true 를 반환한다.
  ```jsx
  true && anything; // anything
  false && anything; // false
  ```
- **논리합(`||`) 연산자**
  **두 개의 피연산자 중 하나만 true로 평가 되어도 true를 반환**한다.
  ```jsx
  true || anything; // true
  false || anything; // anything
  ```
- **옵셔널 체이닝 연산자**
- **null 병합 연산자**

<br/>

## 14 Promise

**`promise`란 ?** <br/>

- **`fetch`** 등으로 서버에 데이터를 요청한 후 받아오거나 파일을 읽고 쓰는 등의 작업, 사용자의 이벤트 처리 작업등의 비동기 처리에 사용되는 객체이다.
- **`Promise`** 는 현재 비동기 처리가 어떻게 진행되고 있는지를 나타내는 상태(state) 정보를 가지고, 처리 결과를 관리한다.

<br/>

**`Promise`의 3가지 상태** <br/>
| 프로미스 상태 정보 | 의미 | 상태 변경 조건 |
| ------------------ | ------------------------------------- | -------------------------------- |
| pending(대기) | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 |
| fulfilled(성공) | 비동기 처리가 수행된 상태(성공) | resolve 함수 호출 |
| rejected(실패) | 비동기 처리가 수행된 상태(실패) | reject 함수 호출 |

<br/>

**`Promise`객체의 후속 처리 메서드** <br/>

**`Promise`** 객체의 후속 처리 메서드는 프로미스를 반환하여 체이닝이 가능하다.

- **`Promise.prototype.then`**

  **`then`** 메서드는 두 개의 콜백 함수를 인수로 전달받는다. 첫 번째 콜백함수는 프로미스가 **`fulfilled`** 상태가 되면 호출된다. 프로미스의 비동기 처리 결과를 인수로 전달받는다. 두 번째 콜백함수는 프로미스가 **`rejected`** 상태가 되면 호출된다. 프로미스의 에러를 인수로 전달받는다.

- **`Promise.prototype.catch`**

  **`catch`** 메서드는 한 개의 콜백 함수를 인수로 전달받는다. **`catch`** 메서드의 콜백 함수는 프로미스가 **`rejected`** 상태인 경우만 호출된다. **`catch`** 메서드는 **`then`** 과 동일하기 동작한다.

- **`Promise.prototype.finally`**

  **`finally`** 메서드는 한 개의 콜백 함수를 인수로 전달받는다. finally 메서드의 콜백 함수는 프로미스의 성공(**`fulfilled`**) 또는 실패(**`rejected`**)와 상관없이 무조건 한 번 호출된다. **`finally`** 메서드는 프로미스의 상태와 상관 없이 공통적으로 수행해야 할 처리 내용이 있을 때 유용하다.

<br/>

**`async`/`await`란?**

- **`Promise`** 를 조금 더 간결하게 사용하여 자바스크립트가 동기적으로 보이는 것처럼 도와주는 문법으로 복잡한 **`Promise Chaining`** 을 막을 수 있다.

- **`async`**<br/>
  함수 앞에 사용하는 키워드로 **`new Promise`** 를 없이 자동으로 함수 안의 코드 블럭을 **`Promise`** 로 변환시켜준다. 그러므로 이 함수의 반환되는 리턴 값은 항상 **`Promise`** 가 된다.
- **`await`**<br/>
  **`await`** 는 **`Promise`** 가 **`fulfilled`** 될 때까지 기다렸다가 실행 해주는 키워드로 비동기 처리 결과를 받아올 수 있다. **`async`** 가 붙은 함수안에서만 사용 가능하다.

<br/>

**`promise`와 `async`/`await`의 차이점**

- **`Promise`** 사용시 **`catch`** 문을 통해 에러 핸들링이 가능하지만, **`async`**/**`await`** 은 **`try-catch`** 문을 사용해 에러 핸들링한다.

- ES5에서는 **`Promise`**나 **`async`**/**`await`** 를 지원하지 않기 때문에, 콜백 함수를 사용하여 비동기 동작을 처리한다.

<br/>

## 15. 클로저(Closure)란 무엇인가요?

(ref. https://velog.io/@rmaomina/job-interview-closure)

### 클로저(closure)란?

클로저는 함수와 함수가 선언된 어휘적 환경의 조합으로 외부 함수의 변수에 접근할 수 있는 내부 함수.
모든 함수는 클로저이다.

### 어휘적 환경이란?

코드가 선언 될 때의 주변 환경으로 즉, 클로저가 생성된 시점의 유효 범위에 있는 모든 지역 변수를 사용하는 환경을 말하는 것

### 클로저의 특징?

- 캡슐화 : 외부 함수의 변수가 함수 밖으로 노출되지 않아 정보의 접근을 제한 가능
- 모듈화 : 외부 함수의 실행이 끝나더라도 외부 함수 안의 변수가 메모리에 저장되어 있어 값을 기억

### 클로저 모듈 패턴?

클로저에서 내부 함수를 하나만 리턴하는 것이 아니라, 객체에 여러개의 내부 함수를 리턴하도록 만든 것

```js
const makeCounter = () => {
  let value = 0;

  return {
    increase: () => {
      value = value + 1;
    },
    decrease: () => {
      value = value - 1;
    },
    getValue: () => {
      getValue: () => value;
    },
  };
};

const counterA = makeCounter();
const counterB = makeCounter();
```

### 클로저를 사용했을 때의 단점은?

외부 함수 스코프가 내부 함수에 의해 언제든지 참조될 수 있기 때문에, 클로저 패턴은 메모리 상에 남아 가비지 컬렉션이 되지 않는다. 따라서 클로저를 남발할 경우 퍼포먼스 저하가 발생할 수 있음

<br/>

## 16. 구조 분해 할당(Destructuring assignment)이란?

배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현식

- **배열 구조 분해**
  배열의 각 요소를 배열로부터 추출하여 1개 이상의 변수에 할당.
  이 때 할당 기준은 배열의 인덱스며, Rest 요소를 사용할 수 있다.

  ```jsx
  const arr = [1, 2, 3];

  // ES6 배열 디스트럭처링 할당
  // 변수 one, two, three를 선언하고 배열 arr을 디스트럭처링하여 할당한다.
  // 이때 할당 기준은 배열의 인덱스다.
  const [one, two, three] = arr;

  console.log(one, two, three); // 1 2 3

  // Rest 요소
  const [x, ...y] = [1, 2, 3];
  console.log(x, y); // 1 [ 2, 3 ]
  ```

- **객체 구조 분해**
  객체의 각 요소를 객체로부터 추출하여 1개 이상의 변수에 할당한다.
  이 때 할당 기준은 객체의 프로퍼티 키며, Rest 요소를 사용할 수 있다.

      ```jsx
      const user = { firstName: 'Ungmo', lastName: 'Lee' };

      const { lastName, firstName } = user;

      console.log(firstName, lastName);
      ```

<br/>

## 17. 전개 구문(Spread syntax)이란?

하나로 뭉쳐 있는 여러 값들의 집합(이터러블한 값)을 펼쳐서(전개하여, 분산하여, spread) 개별적인 값들의 목록으로 만들어주는 문법. 배열이나 객체의 확장에 용이하다.

- ES6에서 추가되었다.

- 전개 구문 사용시 원본값과 다른 참조를 가르키지만 1레벨 수준에서만 복사되어 깊은복사라고 할수 없다. (2차원 배열에서 사용시 flat되어 복사됨)

- 배열에 전개구문을 사용하여 객체로 래핑하면 배열의 index를 프로퍼티 키로 갖는 객체가 생성됨

```jsx
console.log(...[1, 2, 3]); // 1 2 3
console.log(...'Hello'); // H e l l o
console.log(
  ...new Map([
    ['a', '1'],
    ['b', '2'],
  ])
); // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{ a: 1, b: 2 }); // TypeError: Found non-callable @@iterator
```

<br/>

## 18. 나머지 매개변수(Rest parameters)란?

매개변수 이름 앞에 세개의 점 …을 붙여서 정의한 매개변수. 정해지지 않은 수의 매개변수 목록을 배열로 전달 받으며 기본 값을 지정할 수 있다.

- ES6에서 추가되었다.

```jsx
function foo(...rest) {
  // 매개변수 rest는 인수들의 목록을 배열로 전달받는 Rest 파라미터다.
  console.log(rest); // [ 1, 2, 3, 4, 5 ]
}

foo(1, 2, 3, 4, 5);
```

<br/>

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

**정의**

- 암묵적인 **`느슨한 모드(Sloppy Mode)`**를 해제하고 명시적인 **`엄격 모드(Strict Mode)`**를 사용하는 방법
- JS 의 제한된 버전을 사용함으로써 런타임시 안전하고 효율적인 코드 작성을 돕는다.

**사용 방법**

```jsx
use strict

// ~~ 코드 작성
```

**특징**

- JS 가 기존에 무시했던 error 표시
- JS 엔진 최적화 작업을 어렵게 만드는 실수들을 바로 잡음
- ECMAScript의 차기 버전에서 정의될 문법들을 금지
- 서로 다른 엄격한 모드로 작성된 스크립트를 병합하면 문제가 생긴다는 단점이 있다.

<br/>

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

**`Function.prototype.apply / call / bind`**

- 세 가지 메서드 모두 **`Function.prototype`** 메서드이므로 모든 함수가 상속받아 사용할 수 있다.

**`Function.prototype.app**ly / call` **란?**

```jsx
function foo(arg1, arg2) {
  console.log(arg1, arg2);
}

// this로 사용할 객체
const thisArg = { a: 1 };

// apply 메서드
foo.apply(thisArg, [1, 2]);

// call 메서드
foo.call(thisArg, 1, 2);
```

- 두 개의 메서드의 본질적인 기능은 함수를 호출하는 것이다.
- **`apply`** : **`this`**로 사용될 객체와 호출할 함수의 인수를 유사배열객체로 묶어 전달한다.
- **`call`** : **`this`**로 사용될 객체와 호출할 함수의 인수들을 개별로 전달한다.

**`Function.prototype.bind`** 란?

```jsx
function foo(arg1, arg2) {
  console.log(arg1, arg2);
}

// this로 사용할 객체
const thisArg = { a: 1 };

// apply 메서드
const a = foo.bind(thisArg, [1, 2]);
console.log(a);
```

- **`apply`**와 **`call`** 메서드와 달리 함수를 호출하지 않고 첫 번째 인수로 전달한 값으로 **`this`** 바인딩이 교체된 함수를 새롭게 생성해 반환한다.
- 새로운 함수를 생성할 때 사용한다.

<br/>
