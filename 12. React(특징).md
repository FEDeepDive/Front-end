## 1. 함수 컴포넌트/클래스 컴포넌트 차이점, 장단점

|  | 클래스 컴포넌트 | 함수 컴포넌트 |
| --- | --- | --- |
| 선언 방식 | `React.Component`를 상속한 `Class`로 선언 | 일반적인 함수 문법으로 선언 |
| State 사용 | `this.state`와 생명주기 메서드 | `useState`, `useReducer`, `uesEffect` 등 Hooks |
| Props 사용 | `this.props`로 접근 | 매개변수로 받은 `props`로 접근 |
| 렌더링 방식 | `render()` 메서드로 렌더링할 요소를 반환함 | 렌더링할 요소를 직접 반환함 |
| 코드 복잡도 | 복잡하고 코드가 긺 | 간결하고 코드가 짧음 |
| 코드 응집도 | 코드 구조가 생명주기에 맞춰짐 | 코드 구조가 관심사별로 분리됨 |
| 코드 가독성 | 렌더링 요소를 한눈에 파악하기 어려움 | 렌더링 요소를 한눈에 파악하기 쉬움 |
| 러닝커브 | 높음 (`Class`, `this` 이해 필요) | 낮음 |
| 재사용성 | stateful 로직 재사용이 어려움 (HOC로 해결 but 코드가 계속 중첩돼 복잡해짐) | 커스텀 훅을 통한 높은 재사용성 |

- [클래스 컴포넌트 사용 예시 참고](https://react.vlpt.us/basic/24-class-component.html)

## 2. React의 라이프사이클에 대해 설명해주세요.

```
💡 모든 컴포넌트는 `mount`, `update`, `unmount`의 생명주기를 갖는다.
클래스 컴포넌트는 이를 생명주기 메서드로 제어하고, 함수 컴포넌트는 Effect로 생명주기 메서드를 대체한다.
```

- **컴포넌트의 생명주기**
  - 컴포넌트가 화면에 추가되면, `mount`됨
  - 컴포넌트가 상호작용의 결과로 새 props나 state를 받으면, `update`됨
  - 컴포넌트가 화면에서 제거되면, `unmount`됨
- **Effect의 생명주기**
  - Effect 종속성이 없으면, 렌더링될 때마다 Effect를 실행함
  - Effect 종속성이 빈 배열이면, 컴포넌트가 `mount`될 때 Effect를 실행함
  - Effect 종속성이 특정 데이터를 원소로 하는 배열이면, 컴포넌트가 `mount`되거나 종속성의 값이 변경될 때 Effect를 실행함
  - 컴포넌트가 `unmount`되면, `cleanUp` 함수를 수행함
- **참고**
  - [Lifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)

## 3. 생명주기 메서드

- **클래스 컴포넌트에서 일반적인 생명주기**
  - [생명주기 도표](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)
- **생명주기 메서드 (클래스 컴포넌트에서 사용)**
  - `constructor`: 메서드 바인딩, state 초기화 등 수행
  - `render`: 화면에 그릴 ReactNode를 반환
  - `componentDidMount`: 컴포넌트가 mount된 직후 호출됨. 주로 초기화 작업 수행
  - `componentDidUpdate`: 컴포넌트가 update된 직후 호출됨. 최초 렌더링에선 호출 X
  - `componentWillUnmount`: 컴포넌트가 unmount되기 직전 호출됨. 주로 정리 작업 수행

## 4. 고차 컴포넌트

- **개념**
  - HOC(Higher Order Component)
  - 컴포넌트 **로직 재사용**을 위해, 해당 컴포넌트를 감싼 **새로운 컴포넌트**를 반환하는 함수
  - Hooks의 등장으로 로직 재사용이 간편해져 과거에 비해 잘 사용되지 않지만, 여전히 유용함
- **특징**
  - 컴포넌트를 인자로 받아 새로운 컴포넌트로 반환함
  - 원본 컴포넌트를 수정하지 않고 기능을 추가함 (순수 함수)
  - props로 컴포넌트에 데이터나 동작을 주입 가능
- **예시**
  - 특정 권한이 필요한 모든 컴포넌트에서 권한 확인하기 번거로움 (Hook을 사용해도 되지만, 그러면 컴포넌트 내부에 권한 확인 로직이 추가되는 단점) ⇒ `withAuthorization`라는 HOC를 만들어 컴포넌트를 인자로 받고, 권한이 있을 때만 컴포넌트를 렌더링하게 함. 권한이 필요한 컴포넌트는 권한이 있는 경우의 동작만 코드로 적고, `withAuthorization(component)`를 export

## 5. 상태 관리 라이브러리 종류를 아는 대로 말해주세요.

- Redux
  - ✅ 많이 쓰임 ⇒ 레퍼런스 많음
  - ✅ 미들웨어가 많음 ⇒ 어떤 작업을 직접 제어하기 유용함 (⇒ 큰 프로젝트에서 많이 사용)
  - ❌ 보일러플레이트 코드가 많이 필요
- Zustand
  - ✅ 가벼움
  - ✅ 러닝커브가 낮음
  - ✅ 코드가 간단함
  - ❌ 레퍼런스가 비교적 적음
- Recoil
  - ✅ JS 라이브러리가 아니라, React 전용 라이브러리 ⇒ React와 호환 굿
- Jotai
- React Query (TanStack Query)
  - ✅ 서버 상태 관리 (위 다른 라이브러리는 클라이언트 상태 관리)
  - ✅ 데이터 페칭, 캐싱, 최적화 등을 간편하게 사용할 수 있도록 지원함

## 6. 클라이언트 상태와 서버 상태의 차이?

- **클라이언트 상태**
  - 개념
    - 클라이언트(브라우저/기기)가 제어권을 가지고 있으며, 동기적으로 동작하는 상태
    - ⇒ 항상 최신 값을 가짐
  - 범위에 따른 분류
    - `로컬 상태`: 컴포넌트 내부에서 관리하는 상태
    - `글로벌 상태`: 상태관리 라이브러리, contextAPI 등을 사용해 전역적으로 관리하는 상태
  - 예시
    - UI 상태
    - 브라우저 쿠키
- **서버 상태**
  - 개념
    - 서버(DB)에서 관리되어, 비동기적으로 동작하는 상태
    - ⇒ 데이터 조회 시점의 상태(스냅샷)이므로, 최신 값과 다를 수 있음
  - 예시
    - 로딩중, 에러, 성공 등 API 응답 상태

## 7. 에러 바운더리

## 8. Suspense
