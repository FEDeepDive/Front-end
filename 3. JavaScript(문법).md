## 1. ES6에 추가된 문법

```
💡 `let`, `const`, 화살표 함수, 클래스, 모듈, 프로미스 등이 추가되었습니다. 템플릿 리터럴, 객체 리터럴 기능이 향상되었고, `String`, `Array`, `Object` 등의 객체에 메서드들이 추가되었습니다.
```

- **`let`, `const`**
- **화살표 함수(Arrow Function)**
- **매개변수 기본값, Spread 연산자, Rest 파라미터**
- **구조분해할당(Destructuring)**
- **클래스**
- **모듈**
- **프로미스**
- **`Symbol`**
- **`Map`, `Set`**
- **이터레이션(Iteration) + `for...of`**
  - 이터레이션 프로토콜을 준수한 객체는 `for...of` 순회 가능
  - `for...of`: 이터레이터의 `next()`를 호출하여 이터러블을 순회
  - 참고: [이터레이션과 for...of 문](https://poiemaweb.com/es6-iteration-for-of)
- **제너레이터(Generator)**
  - 이터러블을 생성하는 함수
  - 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편함
  - ES7의 `async/await`과 함께 사용 가능
- **향상된 템플릿 리터럴**
  - 문자열 보간 (ex. `변수는 ${variable}`)
  - 여러 줄의 문자열 O
- **향상된 객체 리터럴**
  - 프로퍼티 축약 표현 (프로퍼티 값으로 변수 사용 시, 프로퍼티 이름 생략 가능)
  - 메소드 축약 표현 (`function` 키워드 생략 O)
  - 프로퍼티 키 동적 생성 O (ex. `obj[i + '-th'] = i`)
  - 참고: [객체 리터럴 프로퍼티 기능 확장](https://poiemaweb.com/es6-enhanced-object-property)
- **`String`, `Array`, `Object` 등의 메서드 추가**

```
💡 이외에도 매우 많음. 자세한 건 [공식 문서](https://262.ecma-international.org/6.0/) 확인.
참고로, ES6(=ECMAScript2015) 이후부터는 ECMA2016처럼 년도로 표기함.
```

## 2. `var`, `const`, `let`의 차이점

```
💡 `var`는 재선언, 재할당이 불가능하고, 함수 또는 글로벌 스코프를 갖습니다. 반면 `let`, `const`는 재선언이 불가능하고, 블록 레벨 스코프를 갖습니다. `let`은 재할당이 가능하지만, `const`는 재할당이 불가능합니다.
```

|  | var | let | const |
| --- | --- | --- | --- |
| 재선언 | O | X | X |
| 재할당 | O | O | X |
| 스코프 | 함수 안 선언 시 함수 범위, 이외에는 전역 범위 | 블록({}) 범위 | 블록({}) 범위 |
| 호이스팅 | O, undefined로 초기화 | O, 초기화 X ⇒ 선언 전 사용 시 Reference Error | O, 초기화 X ⇒ 선언 전 사용 시 Reference Error |
| 기타 특성 | var 키워드 생략 가능 |  | 선언과 동시에 할당 필요 |

## 3. `null`, `undefined`?

```
💡 `null`은 빈 값이고, `undefined`는 값이 할당되지 않은 상태를 가리킵니다.
```

- `null`: 값이 비어있음
  - type: null
    - 실제 타입은 `null`이나, 자바스크립트 초기 설계 오류로 `typeof null`의 결과는 `object`임([참고](https://poiemaweb.com/js-type-check))
- `undefined`: 자료형이 지정되지 않음 (값이 할당되지 않아서)
  - type: undefined

## 4. `NaN`?

```
💡 `NaN`은 숫자가 아닌 값을 나타냅니다. 주로(항상이 아님) 숫자가 아닌 값을 숫자처럼 사용하려고 하는 경우에 `NaN`이 반환됩니다.
```

- **개념**
  - Not a Number, 즉 숫자가 아님을 나타냄
- **특징**
  - type: Number
  - 설정 불가능, 쓰기 불가능
  - `NaN === NaN` ⇒ `false`
    - [이유](https://velog.io/@eunbeann/Why-NaN-NaN-is-False): `NaN`은 다른 어떤 값과도 (자기 자신 포함) 같지 않음
    - 따라서 `NaN`인지 판별할 때 `isNaN()` 사용
- **`NaN`이 반환되는 상황**
  - 숫자로 변환 실패 (ex. `Number('abc')`)
  - 결과가 허수인 수학 계산식 (ex. `Math.sqrt(-1)`)
  - 정의할 수 없는 계산식 (ex. `0 * Infinity`, `Infinity/Infinity`)
  - `NaN` 연산 (ex. `7 * NaN`, `7 * 'abc'`) ⇒ `**NaN`은 전염성을 가짐\*\*
  - 유효하지 않은 값이 숫자로 표시되는 경우 (ex. `new Data('abc').getTime()`)

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.

```
💡 JavaScript 코드는 세미콜론이 없어도 에러가 나지 않으며, 세미콜론이 없을 경우 인터프리터가 자동으로 삽입해주기 때문입니다.
```

- **이유**
  - 세미콜론이 없어도 에러가 나지 않음
  - 세미콜론이 없을 경우, 인터프리터가 자동으로 삽입해주기 때문(=ASI (Automatic Semicolon Insertion, 자동 세미콜론 삽입))
- **번외**
  - **세미콜론 쓰면 좋은 점**
    - 가독성
    - 안전성
    - 범용성
  - **세미콜론 안 쓰면 좋은 점**
    - 코드 라인 위치 변경이 용이함
      ```jsx
      array
      	.map(...)
      	.filter(...) // 세미콜론이 없으면 라인 위치 변경이 간편함
      ```

## 6. `Symbol`에 대해 설명해주세요.

- **개념**
  - ES6에서 추가된 7번째 원시형 타입
  - 유일성이 보장됨
  - “심볼 이름”(또는 “심볼 설명”)을 가짐
    - 두 심볼이 서로 동일한 심볼 설명을 가져도 심볼값은 서로 다름
    - ⇒ 심볼 이름은 진짜 이름표 역할만 함
- **목적**
  - 숨겨진 프로퍼티, 유니크한 식별자를 만들기 위해 사용됨
- **특징**
  - `for..in` 반복문에서 배제됨 (non-Symbol이어야 순회함)
- **참고**
  - [심볼형](https://ko.javascript.info/symbol)

## 7. `==` 과 `===` 의 차이가 무엇인가요?

```
💡 엄격한 동등 연산자(`===`)는 피연산자의 타입이 서로 다른 경우 `false`를 반환합니다.
하지만 느슨한 동등 연산자(`==`)는 피연산자의 타입이 서로 다른 경우 타입 변환을 시도한 후 값을 비교합니다.
따라서 정확한 값 비교를 원한다면 엄격한 동등 연산자(`===`)를 사용하는 것이 좋습니다.
```

|  | 느슨한 동등 연산자(==) | 엄격한 동등 연산자(===, 일치 연산자) |
| --- | --- | --- |
| 비교 값 | 값 | 값 & 타입 |
| 연산 과정 | 타입이 다른 경우 타입 변환 후 비교 | 동등 연산자와 동일 but 타입이 다른 경우 바로 `false` 반환 |

**💡자세한 내용은 [MDN 동등 비교 및 동일성](https://developer.mozilla.org/ko/docs/Web/JavaScript/Equality_comparisons_and_sameness#loose_equality_using) 참고**

## 8. `for … of` / `for … in` 문

### `for...in`

- **순회 대상**
  - 모든 객체
  - 객체의 모든 \*열거가능(enumerable)하고 non-Symbol인 속성에 대해 반복
    - \*열거 속성: 내부의 열거 가능 플래그 `[[Enumerable]]`가 `true`인 속성
- **특징**
  - 객체의 key에만 접근 가능
  - 임의의 순서로 반복(=순서 보장 X)
  - 객체의 프로토타입까지 순회 가능
- **등장 시기**: ES1

### `for...of`

- **순회 대상**
  - 이터러블 객체(`[Symbol.iterator]` 속성을 갖고 있는 객체)
- **특징**
  - 객체의 key, value에 접근 가능
  - `await` 사용 가능 (`for-await-of`)
- **등장 시기**: ES6

### `Array.prototype.forEach`

- **순회 대상**: Array, Map
- **장점**
  - 배열의 요소와 인덱스에 접근 가능
  - 콜백 함수를 따로 짤 수 있음 & 화살표 함수 사용 가능
- **단점**
  - 루프 내부에서 `await` 사용이 불가
  - 반복 흐름을 제어하지 못함 (`break`, `continue` 불가능)
- **등장 시기**: ES5

### 참고

- [for...of와 for..in의 차이](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of#difference_between_for...of_and_for...in)
- [for vs for-in vs forEach vs for-of 무엇으로 자바스크립트 리스트를 돌아야 하나](https://yceffort.kr/2021/06/best-solution-for-looping-over-array)

## 9. `reduce` 사용법

```
💡 `reduce`는 배열의 각 요소에 대해 함수를 실행하고, 그 결과를 누산기에 누적하여 최종 누적 결과를 얻을 때 사용됩니다.
```

- **개념**

  - 배열을 순회하며 각 요소에 대한 함수를 실행 ⇒ 함수 반환값을 누적하여 하나의 결과값을 반환함

- **구문**

  ```jsx
  // 물음표(?)로 끝나는 변수는 Optional

  const 누적된결과값 = array.reduce(
    (누산기, 현재요소, 현재인덱스?, _호출한배열?) => {
      return 누산기에_누적할_값;
    },
    누산기초기값?,
  );
  ```

  - `array.reduce(콜백, 누산기초기값?)`
    - 콜백 매개변수
      - `누산기`: 콜백의 반환 값을 누적함
      - `현재요소`
      - `현재인덱스?`
      - `호출한배열?`: `reduce()`를 호출한 배열
    - `누산기초기값?`: 콜백 최초 호출 시 누산기 초기값으로 할당할 값. 없으면 배열의 첫 번째 요소 사용. (빈 배열 + 초기값도 없으면 오류 발생)
  - 반환값: 누산기의 최종 값

- **예시**
  ```jsx
  // 배열의 모든 원소 더하기
  const numbers = [1, 2, 3, 4];
  const sum = numbers.reduce((sum, num) => sum + num, 0);
  console.log(sum); // 10
  ```

## 10. `splice`, `slice`, `split` 차이

```
💡 `splice`와 `slice`는 배열의 특정 구간을 추출한다는 점에서 비슷합니다.
하지만 `splice`는 원본 배열을 변형하고, 배열 삭제와 추가 모두 가능한 반면,
`slice`는 원본을 변형하지 않고, 특정 부분을 획득하는 데 목적이 있다는 점에서 다릅니다.
`split`은 문자열을 구분자로 끊어 배열로 만들 때 사용됩니다.
```

|  | splice | slice | split |
| --- | --- | --- | --- |
| 목적 | 배열에 요소 삽입/삭제/교체를 통한 배열 내용 변경 | 배열/문자열의 특정 구간 획득 | 문자열을 특정 구분자로 나눔 |
| 원본변형 | O | X | X |
| 반환값 | 제거한 구간 배열 | 추출한 구간 배열 | 구분자로 나눈 결과 배열 |
| 매개변수(\*:옵셔널) | `시작 인덱스`, `*삭제할 요소 개수`, `*배열에 추가할 요소들` | `*시작 인덱스`, `*종료 인덱스(구간에 미포함)` | `*구분자`, `*끊어진 문자열의 최대 개수` |
| 매개변수 특징 | 인덱스가 음수(-n)면, 뒤에서 n번째로 계산 | 인덱스가 음수(-n)면, 뒤에서 n번째로 계산 |  |

## 11. 옵셔널 체이닝

```
💡 옵셔널 체이닝(`?.`)은 값의 존재 여부를 평가하기 위한 구문입니다. 만약 평가하려는 대상이 `null` 또는 `undefined`이라면 즉시 `undefined`를 반환하고, 그렇지 않으면 평가를 계속 진행합니다.
```

- **개념**

  - 평가대상이 존재하면 평가를 계속 진행, \*`nullish`면 `undefined` 반환
    - \*nullish: `null` 또는 `undefined`
  - ES11(ECMAScript2020)

- **문법**

  ```jsx
  // 평가대상?.anything
  obj?.prop;
  obj?.[key];
  obj?.method();
  arr?.[index];
  func?.(args);
  ```

  ```jsx
  user?.address?.street;
  // 위 코드는 아래와 동일한 의미를 가짐
  user !== null &&
  user !== undefined &&
  user.address !== null &&
  user.address !== undefined
    ? user.address.street
    : undefined;
  ```

- **특징**

  - nullish 체크를 위한 코드가 필요없음 ⇒ 코드 간결성
  - `nullish` 값을 참조했을 때 에러를 일으키지 않음 ⇒ 안전하게 접근 O
  - 평가대상이 `nullish`하면 평가를 즉시 중단함 (=단축 평가)

- **주의할 점**

  - 평가대상은 값이 존재하지 않아도 괜찮아야 함. 무분별한 사용은 ㄴㄴ.
  - 쓰기에 사용 불가 (읽기나 삭제에는 O)
    ```jsx
    user?.name = 'Finn' // SyntaxError. undefined = 'Finn'이 되기 때문
    ```

## 12. NULL 병합 연산자(`??`)는 무엇인가요?

```
💡 Null 병합 연산자(`??`)는 앞쪽 피연산자가 `null` 또는 `undefined`일 때 뒤쪽 피연산자를 반환하고, 그렇지 않으면 앞쪽 피연산자를 반환합니다.
```

- **개념**
  - 왼쪽 피연산자가 `nullish`이면 오른쪽 피연산자를, 그렇지 않으면 왼쪽 피연산자를 반환
  - 단축 평가
  - ES11(ECMAScript2020)
- **구문**
  ```jsx
  // 두 코드는 서로 동일한 의미를 가짐
  a ?? b;
  a === null || a === undefined ? b : a;
  ```
- 🚨 **OR 연산자(`||`)와 차이점: nullish vs. falsy**
  ```jsx
  // OR 연산자 살펴보기
  // 두 코드는 서로 동일한 의미를 가짐
  a || b;
  Boolean(a) === false ? b : a;
  ```
  - **Null 병합 연산자**는 `null`과 `undefined`를 제외한 *falsy*한 값을 유효한 값으로 인정함
  - **OR 연산자**는 *falsy*한 값을 유효한 값으로 인정하지 않음 ⇒ 예상치 못한 오류 발생 O
  - \**falsy*한 값: `0`, `''`, `NaN`, `null`, `undefined` 등

## 13. 단축평가

```
💡 단축평가란, 왼쪽 피연산자가 결과를 확정짓는 경우 오른쪽 피연산자를 평가하지 않은 채 평가를 중단하는 것을 말합니다. AND(`&&`), OR(`||`), 옵셔널 체이닝(`?.`), Null 병합 연산자(`??`) 등이 단축평가로 시행됩니다.
```

- **개념**
  - Short Circuit
  - 왼쪽 피연산자를 평가했을 때 연산 결과가 확정되면 오른쪽 피연산자를 평가하지 않고 평가를 중단하는 것
  - 예시: AND(`&&`), OR(`||`), 옵셔널 체이닝(`?.`), Null 병합 연산자(`??`)
    - \*옵셔널체이닝은 연산자가 아니라 구문임

## 14. Promise

```
💡 프로미스(Promise)는 기존의 콜백함수를 활용한 비동기 처리를 보완하기 위한 객체입니다.
```

- **목적**
  - 비동기 처리 (콜백함수보다 편하게)
  - **콜백함수 디자인 패턴의 대체제**
    - 가독성 완화 & 유지보수성 강화 (ex. `then` 체이닝, 비동기 처리 시점 명시 …)
    - 에러 처리 기능 `catch` 추가
    - 여러 비동기 처리를 한 번에 처리할 수 있음
- **개념**

  - X가 성공하면 A, 실패하면 B를 실행
  - **[프로미스의 3가지 상태](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md)**
    - 대기(pending): `new Promise()` 호출 시 대기 상태가 됨. 성공/실패 기다리는 상태
    - 성공(fulfilled)
    - 실패(rejected)
      ```
      💡 처리(settled) : 결과가 확정된 프로미스. 상태가 아님! 편의를 위한 용어일 뿐.
      ```
  - `Ajax`, `fetch`는 프로미스가 적용된 녀석들임

- **문법**

  ```jsx
  const promise = new Promise((resolve, reject) => {
    // 비동기 작업 수행

    if (/* 비동기 작업 수행 성공 */) {
      resolve('result');
    }
    else { /* 비동기 작업 수행 실패 */
      reject('failure reason');
    }
  });

  promise.then(function () {
    console.log("then: 프로미스 성공 시 실행");
  }).catch(function () {
    console.log("catch: 프로미스 실패 시 실행");
  }).finally(function () {
    console.log("finally: 프로미스 결과와 관계 없이 마지막에 실행");
  })
  ```

  - **`then`, `catch` 메서드는 프로미스를 반환함** ⇒ 체이닝이 가능
  - 요청에 대한 응답이 유효하면 resolve, 유효하지 않으면 reject하는 식으로 많이 쓰임

- 참고
  - [자바스크립트 Promise 쉽게 이해하기](https://joshua1988.github.io/web-development/javascript/promise-for-beginners/)
  - [프로미스](https://poiemaweb.com/es6-promise)

## 14-1. Promise란 무엇이며, async/await과 어떻게 다른지, 왜 async/await이 등장했는지?

- **프로미스(Promise)**
  - 콜백함수를 활용한 비동기 처리 패턴을 보완하기 위한 객체
- **async/await의 등장 배경**
  - 프로미스를 활용한 비동기 처리 패턴을 보완하기 위함
- **프로미스와 async/await 차이점**

  |  | 프로미스 | async/await |
  | --- | --- | --- |
  | 사용 방식 | 후속 처리 메서드(ex. `then`) 사용 | 비동기 처리할 곳에 `await` 키워드 사용 |
  | 코드 길이 | 비교적 긺 | 비교적 짧음 |
  | 비동기적 사고 | 비동기적 사고가 필요함 ⇒ 여전히 비동기 처리가 복잡함 | 비동기적 사고 필요 X ⇒ 비동기 처리를 일반 코드 짜 듯 짤 수 있음 |

## 14-2. Promise나 async/await를 es5로 트랜스파일하면 어떻게 되나요?

```
💡 프로미스(Promise)는 새롭게 추가된 객체이므로 코드가 자동으로 변경되지 않습니다. 때문에 폴리필을 추가해주어야 합니다.
반면 async/await은 코드가 자동으로 변경됩니다.
```

## 15. 클로저(Closure)란 무엇인가요?

```
💡 클로저(Closure)란 **함수와 그 함수의 어휘적 환경이 조합**되어 특별한 기능을 갖는 함수입니다. 클로저는 참조를 통해 선언 당시 주변 상태를 기억하고, 이를 통해 외부 스코프의 식별자에 접근할 수 있습니다. 클로저를 사용하면 데이터 은닉, 상태 유지 등이 가능합니다.
```

- **클로저에 앞서, 어휘적 환경(Lexical Environment)이란?**
  - **렉시컬 스코프(Lexical Scope)**
    - 식별자가 선언된 위치의 블록 + 상위 스코프
    - 식별자는 선언과 동시에 주변 상태(렉시컬 스코프에 선언된 식별자)를 참조함
  - **어휘적 환경 개념**
    - 코드가 선언될 때의 주변 환경으로, 코드의 스코프와 식별자에 대한 접근을 제공함
  - **어휘적 환경의 기능**
    - 1️⃣환경 레코드(렉시컬 스코프 정보 저장, 식별자-값 매핑)
    - 2️⃣스코프 체인 탐색을 통한 외부 환경 참조
  - **어휘적 환경의 특징**
    - 식별자 선언 시 형성됨
    - 한 번 형성되면 스코프 체인은 변하지 않음 ⇒ 정적 특성
  ```
  💡 (정리) 렉시컬 환경이란 코드가 선언될 당시 주변 환경을 말합니다. 렉시컬 환경이 있기에 각 **식별자의 렉시컬 스코프 정보를 저장**할 수 있으며, **스코프 체인**을 통해 외부 스코프를 탐색하여 식별자를 찾을 수 있습니다.
  ```
  - 예시
    ```jsx
    let name = 'finn';
    function lexical() {
      console.log(name);
    }
    name = 'jayk';
    lexical(); // 'finn'이 아닌 'jayk' => 값 기억이 X 변수 자체를 참조
    ```
    - `lexical` 함수의 렉시컬 스코프: `lexical` 함수 내부 스코프 + 전역 블록
    - `lexical` 함수는 함수가 선언될 때의 `name` 변수 값 "finn"을 기억하는 게 아니라, 전역 블록의 `name` 변수를 "참조"함
- **핵심 개념**
  - **함수 자체와 함수의 어휘적(lexical) 환경이 조합**되어 특별한 기능을 제공하는 함수
  - ⇒ **\*참조를 통해 주변 상태를 기억하여, 외부 스코프의 식별자에 접근할 수 있는 함수**
    - \*참조하지 않아도 주변 상태를 기억할 수 있음 but 위와 같은 설명이 일반적임
  - 부연 설명
    - 모든 함수는 클로저임
    - 자신이 선언됐을 때의 주변 환경을 기억함 & 해당 변수에 접근 O
    - 내부 함수에서 외부 함수로 접근 O (예시 참고)
- **예시**

  ```jsx
  // 클로저 활용 예시
  function counter() {
    let cnt = 0;

    function setCnt(x) {
      cnt = x;
    }
    function print() {
      console.log(cnt);
    }

    return {
      print,
      setCnt,
    };
  }

  const myCounter = counter();
  myCounter.print(); // 0
  myCounter.setCnt(5);
  myCounter.print(); // 5. 클로저의 특성 때문에 0이 아니라 5임!
  ```

  - 1️⃣ 내부 함수(`setCnt`, `print`)를 외부 함수(`counter`) 바깥에서 호출해도 외부 함수의 변수(`cnt`)에 접근이 가능
  - 2️⃣ 내부 함수 실행이 끝나면 외부 함수 내 `cnt`에 접근할 수 없다고 예상할 수 있음 but 클로저이기 때문에 참조가 유지되어 이게 가능한 거임
    - `myCounter` (참조)⇒ `setCnt`, `print`
    - `setCnt`, `print` (참조)⇒ `cnt`

- **캡슐화 & 모듈화**
  - 노출되어선 안되는 정보를 클로저에 넣어, **정보 접근 제한**
  - 함수 실행이 끝나도 **상태가 유지**됨 ⇒ \*모듈 패턴 구현 가능
    - \*모듈 패턴: 외부 함수 리턴 시, 객체에 여러 내부 함수를 담아 리턴
    - ⇒ 리턴 값은 외부에서 직접 접근 불가, 클로저를 할당받은 녀석(모듈)만 사용 가능
- **주의할 점**
  - 클로저 내 식별자는 언제든지 참조될 수 있기에 삭제되지 않고 메모리에 남아있게 됨 ⇒ 성능 저하의 원인
- **참고**
  - [클로저](https://poiemaweb.com/js-closure)
  - [MDN 클로저](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures#%ED%81%B4%EB%A1%9C%EC%A0%80closure)
  - [자바스크립트 클로저 실용적이고 쉬운 설명](https://www.youtube.com/watch?v=LL0DGc5pg7A&t=344s)
  - [😄 면접관: closure에 대해 설명해 보세요 🫠 네..?](https://velog.io/@rmaomina/job-interview-closure)
  - [어휘적 환경과 클로저의 기본 개념](https://taero.blog/posts/about-closure)

## 16. 구조 분해 할당(Destructuring assignment)이란?

```
💡 구조 분해 할당이란 배열이나 객체의 값을 변수에 바로 할당하는 것을 말합니다.
```

- **개념**
  - 배열 또는 객체의 값을 추출하여 변수에 할당하는 것
- **배열 구조 분해**

  ```jsx
  // # 기본 할당 및 버림
  const arr = [1, 2, 3];
  let [a, b] = arr; // a = 1, b = 2, 3은 버려짐

  // # 값 교환
  [a, b] = [b, a]; // a = 2, b = 1

  // # 기본값 (undefined이면 적용)
  const [x = 0, y = 0] = [1]; // x = 1, y = 0
  ```

- **객체 구조 분해**

  ```jsx
  // # 기본 할당
  const obj = { a: 1, b: 2, c: 3 };
  const { a, b } = obj; // a = 1, b = 2

  // # 새로운 변수 이름으로 할당
  const { a: one, b: two } = obj; // one = 1, two = 2. 기존 a, b가 있어도 오류 발생 X

  // # 기본값 (undefined이면 적용)
  const { x = 0, y = 0 } = { x: 1 }; // x = 1, y = 0
  ```

## 17. 전개 구문(Spread syntax)이란?

```
💡 전개 구문(Spread Syntax)은 이터러블이나 객체의 프로퍼티를 늘어뜨려 놓기 위해 사용됩니다.
```

- **개념**
  - `...iterable`
  - 이터러블 객체 또는 객체의 프로퍼티를 펼침
  - ES6
- **쓰임**
  - 1️⃣함수 호출에서 매개변수를 전개: `func(...iterable)`
  - 2️⃣배열 리터럴에서 전개: `['a', ...iterable, 'd']`
    - ⇒ 배열 복사에 사용 (depth: 1)
    - ⇒ 새로운 배열 생성에 사용
  - 3️⃣객체 리터럴에서 전개: `{...obj}`
    - ⇒ 객체 복사에 사용 (depth: 1)
    - ⇒ 새로운 객체 생성에 사용
    ```
    💡 **객체는 이터러블이 아님!** 1️⃣, 2️⃣와 같이 사용하면 오류 발생
    ⇒ Rest/Spread 프로퍼티 제안으로 인해 객체 프로퍼티 전개가 지원됨 (ES2018, ES9)
    ```

## 18. 나머지 매개변수(Rest parameters)란?

```
💡 나머지 매개변수(Rest parameter)는 함수에서 여러 개의 매개변수를 하나의 배열로 변환하여 받는 것을 말합니다. 나머지 매개변수는 함수의 마지막 매개변수에만 사용할 수 있습니다.
```

- **개념**
  - 함수에서 여러 개의 매개변수를 하나의 배열로 받는 것
  - 함수의 마지막 매개변수에만 사용 가능
- **예시**
  ```jsx
  function example(first, second, ...rest) {
    console.log(first);
    console.log(second);
    console.log(rest);
  }
  example('one', 'two', 'three', 'four', 'five');
  // "one"
  // "two"
  // [three, four, five]
  ```
- **등장** (중요X)
  - 과거, 함수의 매개변수 데이터를 갖는 `arguments` 객체는 `Array` 메서드 사용이 불가능함
  - ⇒ 유사 배열인 `arguments` 객체를 배열로 변환하는 코드 필요
  - ⇒ 해당 코드를 줄이기 위해 나머지 매개변수가 도입됨

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

```
💡 `"use strict"`는 엄격 모드를 활성화하기 위한 구문으로 스크립트나 함수의 최상단에 작성하여 적용할 수 있습니다. 엄격 모드는 자바스크립트의 일부 기능을 차단하여 안전하고 보장된 코드를 작성하게 해줍니다. 하지만 엄격 모드 스크립트와 비엄격 모드 스크립트는 서로 충돌할 수 있고, 엄격 모드를 지원하지 않는 브라우저도 있기 때문에 사용에 유의해야 합니다.
```

- **엄격 모드(strict mode) 적용 방법**
  - 엄격 모드를 적용할 부분 최상단에 `"use strict";` 삽입하여 적용
  - 스크립트 전체, 함수, 모듈에 적용 가능
    - 함수에 적용 시 내부 함수 또한 엄격 모드
    - `export`된 **모듈은** 구문 유무와 상관없이 **무조건 엄격 모드**
- **엄격 모드(strict mode) 개념**
  - 자바스크립트의 몇몇 기능을 차단하여 안전한 코드를 작성하게 함
- **특징**
  - 1️⃣**실수를 에러로 피드백** ⇒ 즉시 수정 & 헷갈리는 코드 차단
    - 함수에서 중복된 매개변수 이름을 사용할 경우 오류 발생
    - 없는 프로퍼티 삭제를 시도할 경우 오류 발생
    - …
  - 2️⃣**최적화 작업을 어렵게 만드는 코드를 바로잡음** ⇒ 비엄격 모드 코드보다 빠를 수 O
  - 3️⃣**ECMAScript 차기 버전에서 정의될 문법 사용 금지** ⇒ 오류 방지
    - `let`, `private`, `yield` 등 예약어를 변수명으로 사용하지 못함
    - 스크립트 최상단 또는 탑 레벨 함수가 아닌 곳에서 함수를 정의하지 못함
  - 4️⃣**보안 강화**
    - 전역 컨텍스트에서 `this`는 `undefined` ⇒ `this`로 `window`에 접근하지 못함
    - 보안을 위협하는 `function.arguments`, `function.caller`를 사용하지 못함
- **주의할 점**
  - 엄격 모드 스크립트와 비엄격 모드 스크립트 병합 시 엄격 모드가 되어 문제가 생길 수 있음
  - 엄격 모드를 지원하지 않는 브라우저가 많음!
    - ⇒ 그러니까 엄격 모드에 의지하기보다, 엄격 모드를 사용하는 것처럼 코드를 짜라

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

```
💡 `call`, `apply`, `bind` 모두 함수의 `this`값을 변경할 때 사용됩니다.

`call`과 `apply`는 변경한 `this`값이 반영된 함수 호출 결과를 반환하지만, 파라미터 전달 방식에 차이가 있습니다.
`call`은 파라미터를 쉼표로 구분하고 `apply`는 파라미터를 하나의 배열로 만들어 전달해주어야 합니다.

`bind`는 변경한 `this`값이 반영된 함수 자체를 반환합니다.
```

- **비교**

  ```
  💡 모두 `Function` 메서드로, 함수의 `this` 참조 값을 바꾼다는 공통점이 있음
  ```

  |  | `call` | `apply` | `bind` |
  | --- | --- | --- | --- |
  | **개념** | 설정한 `this`값과 여러 파라미터를 가지고 함수 호출 | 설정한 `this`값과 단일 파라미터 배열을 가지고 함수 호출 | 설정한 `this`값과 여러 파라미터를 가지고 함수 복제 |
  | **반환값** | 함수 호출 결과 | 함수 호출 결과 | 복제한 함수 |
  | **기본 문법** | `func.call(thisArg[, arg1[, arg2[, ...]]])` | `func.call(thisArg, [argsArray])` | `func.bind(thisArg[, arg1[, arg2[, ...]]])` |

- **예시**

  - `call`, `apply`, `bind` 기본 예시

    ```jsx
    const kim = { math: 100 };
    const lee = {
      math: 20,
      sum: function (korean, english) {
        console.log(korean + english + this.math);
      },
    };

    // lee.sum()을 호출하되, this를 kim으로 설정
    lee.sum.call(kim, 20, 30); // 150
    lee.sum.apply(kim, [20, 30]); // 150

    // lee.sum의 this를 kim으로 설정한 새로운 함수 반환
    kim.sum = lee.sum.bind(kim, 20, 30);
    kim.sum(); // 150
    ```

  - `apply` 응용 예시

    ```jsx
    // # 유사 배열을 배열처럼 사용하기
    function concat() {
      // apply로 유사 배열인 arguments의 Array 메서드 사용을 가능케 함
      return Array.prototype.join.apply(arguments);
      // [...arguments].join();
    }
    concat('abc', 123); // 'abc,123'

    // # 반복문 없이 배열에 배열 붙이기
    const array = ['a', 'b'];
    const elements = [0, 1, 2];
    array.push.apply(array, elements);
    console.log(array); // ['a', 'b', 0, 1, 2]
    ```

- **참고**
  - [[JS] 📚 Call & Bind & Apply 함수 정리](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-Call-Bind-Apply)

## 20-1. `bind`를 `apply`, `call`로 어떻게 구현할 수 있을까요? 구현해보세요.

```jsx
Function.prototype.customBind = function (thisArg, ...rest) {
  if (!thisArg) {
    return this;
  }

  return () => this.call(thisArg, ...rest); // call 활용
  return () => this.apply(thisArg, rest); // apply 활용

  // ❗ 화살표 함수 대신 일반 함수 사용 시, 기존 this 백업 필요
};
```

- 참고
  - [bind 메소드 간단하게 구현하기](https://wonism.github.io/implement-bind/)
