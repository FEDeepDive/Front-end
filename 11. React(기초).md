## 1. React의 장점, 사용 이유

- **널리 쓰임 ⇒ 크고 활성화된 커뮤니티 & 다양한 툴**
  - 다른 라이브러리, 도구들이 많고 꾸준히 업데이트 됨 (ex. 상태관리 라이브러리, 디버깅 툴)
  - 문제를 마주했을 때 해결 방법을 빠르게 찾을 수 있음
  - 기술, 이슈에 대한 토론이 활발하게 일어남
  - 많은 사람들이 관심을 가지기 때문에 React 관련 소식을 빠르게 접할 수 있음
- **JSX ⇒ 가독성, 개발 생산성, 유지보수 용이, 유연성 …**
  - HTML 파일 수정이 필요 없음
  - 컴포넌트 내에서 HTML-like 마크업을 사용 가능
  - 요소를 다루거나 이벤트/데이터 바인딩하기가 쉽고 유연하여 편함
- **가상 DOM ⇒ 빠르고 편한 DOM 조작 & DOM 성능 최적화**
  - DOM 변경은 무겁고 비용이 많이 듬 ⇒ DOM을 가상화해 DOM 조작 비용과 속도를 줄임
  - 변경이 있는 요소만 리렌더링

## 2. JSX

### **등장 배경**

- 기존에는 HTML이 UI, JS가 로직을 담당했음
- 웹이 interactive하게 변하면서, 로직이 점점 UI를 결정하게 됨
- ⇒ **렌더링 로직과 마크업을 같은 곳에 둬서**, 수정할 때마다 **동기화 상태를 유지**하게 하자!

### **개념**

- JavaScript를 확장한 문법으로, UI 마크업와 렌더링 로직을 함께 다룰 수 있게 함
- 보통 React에서 쓰이지만, React와 독립적인 문법 구문임([참고](https://ko.legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-a-jsx-transform))

### **동작 원리**

- 브라우저는 JSX를 이해하지 못하므로 트랜스파일이 필요함
- ⇒ 컴파일 시 JSX 요소는 JavaScript 객체로 변환되고, 프로퍼티는 객체의 키가 됨
  ```jsx
  const element = <h1 className='greeting'>Hello, world!</h1>;

  const element = React.createElement(
    'h1',
    { className: 'greeting' },
    'Hello, world!',
  );

  const element = {
    type: 'h1',
    props: {
      className: 'greeting',
      children: 'Hello, world!',
    },
  };
  ```

### **문법**

- **단일 루트 요소 반환**
  - 여러 요소를 반환하려면 하나의 상위 요소로 감싸져 있어야 함
  - React Fragment(`<></>`)로 감쌀 수 있음
  ```
  💡 JSX는 JavaScript 객체로 변환된다. 그러므로 여러 요소를 반환하는 것은 두 개 이상의 객체를 반환하는 것과 같은데, 이는 불가능하다. 그래서 그 객체들을 하나의 태그로 감싸야만 반환할 수 있는 것이다.
  ```
- **태그는 항상 닫기**
  ```html
  <!-- wrong (correct in HTML) -->
  <img src="..." alt="..." />
  <li> item

  <!-- correct -->
  <img src="..." alt="..." />
  <li>item</li>
  ```
- **프로퍼티 이름 제한**
  - JavaScript 예약어 사용 불가 (ex. `class`)
  - CamelCase 사용 (ex. `stroke-width` 대신 `strokeWidth`)
  - 예외: `aria-*`, `data-*`는 대시를 사용하여 작성함
  ```
  💡 JSX 프로퍼티가 객체의 키로 변환되기 때문에 대시를 사용하지 못한다.
  ```
- **중괄호(`{}`)를 사용해 변수, 함수, 객체 사용 가능**

## 3. props/state

## 4. A 부모 컴포넌트, B/C 자식 컴포넌트가 있을 때:

## 5. Virtual DOM
