## 1. position 속성에 대해 설명해주세요.
`position`은 문서 상에 요소를 배치하는 방법을 지정하는 CSS 속성(property)이다. `top`/`left`/`bottom`/`right` 속성을 함께 지정하여 요소를 배치할 최종 위치를 결정할 수 있다.

### 지정할 수 있는 값
1. `static`: 요소를 일반적인 문서 흐름에 따라 배치한다. `top`/`left`/`bottom`/`right`이 함께 쓰여도 아무런 효과를 가지지 않는다. 아무 값을 지정하지 않았을 때의 기본값이다.
2. `relative`: 요소 자체는 일반적인 문서 흐름에 따라 배치한다. 그러나 함께 주어지는 `top`/`left`/`bottom`/`right`의 값에 따라, 원래 위치를 기준으로 하여 각각 위쪽, 왼쪽, 아래쪽, 오른쪽에서 얼마만큼 떨어져 위치할지 결정할 수 있다. 이때, 적용된 `top`/`left`/`bottom`/`right`의 값은 다른 요소의 위치에 영향을 주지 않는다. `z-index`가 `auto`가 아닐 경우에만 새로운 쌓임 맥락이 만들어진다.
3. `absolute`: 요소가 일반적인 문서 흐름에서 벗어나 배치되며, 페이지 레이아웃에 요소가 위치하기 위한 공간이 생성되지 않는다. 해당 요소는 ‘자신과 가장 가깝고 `static`이 아닌 조상’의 내부 여백 영역 기준으로 위치를 계산하며, 주어진 `top`/`left`/`bottom`/`right`의 값에 따라 위치가 결정된다. `z-index`가 `auto`가 아닐 경우에만 새로운 쌓임 맥락이 만들어지며, `absolute` 값이 지정된 요소의 margin은 다른 요소들의 margin과 상쇄되지 않는다.
4. `fixed`: 요소가 일반적인 문서 흐름에서 벗어나 배치되며, 페이지 레이아웃에 요소가 위치하기 위한 공간이 생성되지 않는다. 해당 요소는 뷰포트 영역 기준으로 위치를 계산하며, 주어진 `top`/`left`/`bottom`/`right`의 값에 따라 위치가 결정된다. 항상 새로운 쌓임 맥락이 만들어지며, `fixed` 값이 지정된 요소의 margin은 다른 요소들의 margin과 상쇄되지 않는다.
5. `sticky`: 최초에는 `relative`와 같이 동작하다가, 스크롤 위치가 어느 임계점에 이르면 ‘스크롤 동작이 존재하며 가장 가까운 조상’에 붙어서 `fixed`와 같이 동작한다. 항상 새로운 쌓임 맥락이 만들어진다.

## 2. display 속성에 대해 설명해주세요.
`display`는 해당 속성이 적용된 HTML 요소가 블록 또는 인라인 중 어떠한 요소로 다루어질지, 그리고 해당 요소의 자식들이 어떠한 레이아웃 모드를 사용할지 지정하는 CSS 속성(property)이다.

### 블록/인라인 요소?
`writing-mode` 속성을 통해 지정된 쓰기 모드에 따라 ‘블록 요소’와 ‘인라인 요소’가 배치되는 방향이 달라진다.

|쓰기 모드 \ 요소|블록|인라인|
|:-:|:-:|:-:|
|가로|수직|수평|
|세로|수평|수직|

두 가지 요소의 방식을 절충한 `inline-block`도 존재한다. 인라인 요소의 배치 방향을 따르며 블록 요소처럼 여러 속성을 지정할 수 있게 된다.

### 레이아웃 모드
기본 레이아웃인 CSS Flow Layout에서 벗어나 새롭게 레이아웃을 정의할 수 있는 Flexible Box Layout, Grid Layout을 적용하도록 지정할 수 있다.

### 그 외
`display: table`을 지정하여, 2차원 행렬 데이터에 알맞은 형태의 레이아웃을 지정할 수도 있다.

## 3. box model이란?
CSS에 포함되는 모든 요소는 박스로 둘러싸여 있으며, 브라우저가 박스를 표현하는 메커니즘을 Box model이라고 한다. Box model은 HTML 요소를 4가지의 사각형 영역으로 나눈다.

|Content|Padding|Border|Margin|
|:-:|:-:|:-:|:-:|
|요소의 실제 내용이 표시되는 영역|내용 주변을 공백처럼 둘러싸는 영역|내용과 패딩을 둘러싸는 영역|내용과 패딩, 테두리를 둘러싸며 다른 요소 사이의 공백 역할을 하는 영역|

Box model을 통해 블록 요소의 너비/높이, 패딩/마진/테두리를 지정할 수 있으나 인라인 요소는 너비/높이를 지정할 수 없다.

## 4. `box-sizing`에 대해 설명해주세요.
요소의 너비와 높이를 결정짓는 `box-sizing` 속성은 `content-box`가 기본값이며, 이는 해당 요소에 정의된 `width`와 `height` 속성이 내용 영역만 고려하여 계산하도록 한다. 때문에 요소에 적용된 패딩, 테두리와 마진을 다 합치면 박스의 크기가 사용자가 원하는 것보다 크게 나올 수 있다.

`box-sizing: border-box`를 지정하여, `width`와 `height` 속성이 패딩과 테두리를 함께 고려하여 계산되도록 할 수 있다.

## 5. 마진 상쇄(margin Collapsing)가 왜 일어나는지, 해결방법?
지정된 쓰기 모드에 따라 정해진 ‘블록 요소의 배치 방향’으로 인접하는 마진이 둘 이상 존재할 경우, 해당 마진들이 하나로 합쳐지는 현상이 발생하며 이를 마진 상쇄라고 부른다. 마진 상쇄를 해결하기 위해서는 마진이 서로 인접하지 않게 만들어야 하며, 다음 경우를 생각해볼 수 있다.

1. 마진 사이에 패딩이나 테두리를 위치시킨다.
2. 마진이 있는 요소의 부모 요소에, 마진보다 큰 고정 높이(또는 너비)값을 준다.
3. 어느 한 요소를 `inline-block`으로 만든다.
4. 부모 요소의 레이아웃 모드를 flexbox나 grid로 바꾼다.

## 6. reset.css/normalize.css에 대해 설명해주세요.
모든 브라우저는 각 HTML 요소에 기본값으로 적용하는 서식이 서로 다르다. 사용자가 어떠한 브라우저를 사용하든 같은 화면을 보여주어야 하기 때문에, 저마다 다른 브라우저의 기본 스타일을 하나로 통일해야 한다. 이를 위해 CSS를 ‘Reset’하거나 ‘Normalize’하는 방법이 사용된다.

|`reset.css`|`normalize.css`|
|:-:|:-:|
|각 브라우저의 기본 스타일을 모두 제거하여 브라우저의 서식을 하나로 통일한다.|각 브라우저의 기본 스타일 중 유용한 것들은 유지하고 그렇지 않은 것들은 제거한다. 유지되는 스타일에 대하여 각 브라우저 간의 상이한 부분의 스타일을 조정하여 브라우저의 서식을 하나로 통일한다.|

## 7. sass, css module, css in js 차이점
Vanilla CSS는 다음과 같은 문제점이 있다:

1. 모든 스타일이 단일 이름공간에 선언되기 때문에, 모든 스타일의 이름이 중복되지 않아야 한다.
2. CSS 파일의 로드 순서에 따라 적용되는 스타일의 우선 순위가 달라지기 때문에 스타일 간의 의존성을 관리하기 어렵다.

이러한 문제점을 해결하기 위해 아래의 접근법들이 생겨났다.

### CSS 전처리기
CSS 스타일을 구조적으로 작성할 수 있게, 기본 CSS에 존재하지 않는 여러 문법을 통하여 CSS를 생성하는 프로그램이다. SASS는 CSS 전처리기들 중 가장 오래된 역사를 가지고 있으며, 변수/중첩문/믹스인/함수 등을 사용하여 스타일을 작성할 수 있게 해준다.

**그 외 전처리기**
- `Less`
- `Stylus`

### CSS 모듈
파일 내에 작성된 클래스명과 애니메이션 이름들이 기본적으로 지역 공간에 선언된다. 서로 다른 모듈에 존재하는 클래스들의 이름이 중복될 수 있어 의존성 관리가 쉬워지며, 따라서 재사용성과 모듈성이 높아진다.

### CSS in JS
스타일을 CSS 파일에 작성하지 않고 JS 코드 내에서 작성한다. 스타일이 문서 레벨이 아닌 컴포넌트 레벨로 추상화되며, JS와 CSS 코드가 변수와 함수를 공유할 수 있어 유연성이 높아진다.

**주요 라이브러리**
- `styled-component`
- `Emotion`
- `Vanilla Extract`
- `Panda CSS`
- `StyleX`

## 8. 이미지를 img src 태그로 만드는 것과 요소의 background로 만들었을 때의 차이점
### `<img src="example.png">`

**로고나 프로필 사진 등 의미를 가지고 있거나, 삽화같이 내용과 관련 있는 이미지에 사용한다.**

1. 이미지를 불러오지 못했을 때, alt 속성으로 지정해준 대체 텍스트를 제공할 수 있다.
2. 페이지를 인쇄할 때 기본적으로 포함된다.
3. 검색 엔진이 이미지임을 인식하여 검색 결과에 노출할 수 있다.

### `{ background-image: url("example.png") }`

**순수하게 디자인을 위해서 활용하고 싶은 이미지에 사용한다.**

1. 여러 개의 작은 이미지를 사용해야 하는 경우, CSS Sprite 기법을 활용할 때 사용하기 좋다.
2. 페이지를 인쇄할 때 포함되지 않는다.
3. 검색 엔진이 이미지로 인식하지 않아 검색 결과에 노출되지 않는다.

## 9. `visibility: hidden`과 `display: none`의 차이점
### 외형적 차이

`visibility: hidden`을 적용할 경우, 화면의 레이아웃 변화 없이 단순히 해당 요소가 보이지 않게 된다. 다른 요소들이 빈 공간을 채우기 위해 움직이지 않고 제자리에 위치한다.

`display: none`을 적용할 경우, 해당 요소가 아예 존재하지 않는 것처럼 취급되며, 레이아웃의 변화가 생긴다. 다른 요소들이 빈 공간을 채우며 위치를 바꾼다.

### 기능적 차이
`visibility: hidden`을 적용할 경우, 레이아웃의 변화가 없기 때문에 Reflow 없이 Repaint만이 발생한다.

`display: none`을 적용하는 경우, 레이아웃의 변화가 생기기 때문에 브라우저가 렌더 트리를 다시 생성하게 된다. 또한 기존에 화면에 보이던 요소에 `display: none`을 적용하게 될 경우, 레이아웃 변화가 생겨 Reflow가 발생할 가능성이 있다.

## 10. 반응형 웹의 3요소
2010년 Ethan Marcotte의 글 [‘Responsive Web Design’](https://alistapart.com/article/responsive-web-design/)이 인기를 얻게 되며, ‘반응형 웹’이라는 용어가 인기를 얻게 되었다. 해당 글에서 이야기하는 반응형 웹의 3요소는 다음과 같다:

### Fluid grid
서로 다른 기기의 화면 크기에 비례하여 조정되는 레이아웃 구조를 뜻한다. 고정된 픽셀 값보다 `%` 등의 상대 단위를 사용하여, 화면 크기가 달라지더라도 각 요소의 크기 비율이 유지되도록 한다.

### Flexible images
서로 다른 기기의 화면 크기와 해상도에 따라 이미지의 크기를 조정하는 것을 뜻한다. 이미지 크기를 컨테이너의 100%로 지정하여, 이미지의 화면 비율을 유지하고 왜곡을 방지함과 동시에 사용 가능한 공간 크기에 비례하여 이미지 크기를 조정할 수 있다.

### Media queries
웹사이트를 보기 위해 사용되는 기기 화면의 특성에 따라 다른 스타일과 레이아웃 규칙을 적용하는 것을 뜻한다. Media query를 사용하여 화면 사이즈, 해상도, 화면 방향(orientation)과 그 외 장치 환경을 특정하여 CSS 스타일을 적용할 수 있다.

## 11. 미디어 쿼리의 동작 방식과 좋은 예시를 들어주세요.
일반적인 미디어 쿼리 문법은 다음과 같다:

```css
@media media-type and (media-feature-rule) {
  /* CSS rules */
}
```

### 미디어 타입

어떤 미디어를 위한 스타일 코드인지를 브라우저에 알려주기 위해 사용한다. 모든 기기를 위한 `all`, 인쇄 미리보기 화면을 위한 `print`, 일반적인 화면을 위한 `screen` 등을 사용할 수 있다.

### 미디어 구문

스타일 코드가 실제로 적용될 조건을 설정하기 위해 사용한다. 소괄호로 묶어 작성하며, 주로 기기의 너비에 따라 다른 레이아웃을 지정하기 위해 작성되는 경우가 많다.

### 스타일 규칙

설정한 미디어 타입과 미디어 구문이 현재 상황과 일치하는 경우 적용할 CSS 스타일 규칙이다.

---

미디어 쿼리는 일반적으로 기기의 너비에 따라 다른 레이아웃을 보여주기 위해 자주 쓰이지만 `prefers-color-scheme` 구문을 이용해 라이트/다크 모드 중 사용자가 원하는 모드를 지정하여 보여줄 수도 있고, `prefers-reduced-motion` 구문을 이용해 전정 기능에 장애가 있는 사용자들이 컨텐츠를 편하게 접할 수 있도록 애니메이션을 줄이는 데에 이용할 수도 있다.

## 12. CSS에서 사용되는 단위들에 대해 설명해주세요.
일반적으로 CSS 단위를 묻는다면 보통 길이 단위라고 생각하여 길이 단위에 관해 정리하였다.

### **px**

절대 단위 중 일반적으로 화면 스타일에 사용하는 유일한 단위. 항상 동일한 크기로 간주되기 때문에 반응형 웹에는 적합하지 않다.

### **%**

부모 요소에 대해 상대적인 크기를 지정할 때 사용. 단위/값 여부에 대해 의견이 다른 부분이 있었던 것으로 보이는데, MDN에서는 %와 그 이외의 단위를 `<percentage>`와 `<dimension>`으로 나누고 있는 것으로 보임. 그러나 회의록의 결론대로, 명확한 정의보다는 그 의미와 쓰이는 상황을 아는 것이 중요할 듯함.

### **em**

부모 요소의 글꼴 크기에 대해 상대적인 크기를 지정할 때 사용하는 단위이다.

### **rem**

최상위 요소, 즉 `<html>`의 글꼴 크기에 대해 상대적인 크기를 지정할 때 사용하는 단위이다.

### **vw, vh, vmin, vmax**

뷰포트 크기에 대해 상대적인 크기를 지정할 때 사용하는 단위. `vw`는 뷰포트 너비, `vh`는 뷰포트 높이의 1%와 동일하다. `vmin`과 `vmax`는 `vw`와 `vh` 중 각각 작은 것, 큰 것과 같다.

### **sv{w|h}, lv{w|h}, dv{w|h}**

`sv{w|h}`는 뷰포트의 너비/높이 중 작은 값을 이용해 계산되는 단위이며, `lv{w|h}`는 뷰포트의 너비/높이 중 큰 값을 이용해 계산되는 단위이다. `dv{w|h}`는 현재 뷰포트의 상태에 따라 동적으로 알맞은 너비/높이 값을 계산해준다.

## 13. 선택자의 우선순위에 대해 설명해주세요.
선택자는 특정한 요소를 얼마나 더 ‘명시적’으로 선택하느냐에 따라 그 우선순위가 높아진다. 따라서 CSS 스타일이 적용되는 우선순위는 다음과 같다:

1. `!important`가 적용된 스타일
2. 인라인으로 적용된 스타일
3. id 선택자
4. 클래스/속성/가상 클래스 선택자
5. 요소/가상 요소 선택자

하나의 요소에는 여러 가지 스타일 속성이 설정되는 경우가 많은데, 브라우저는 이러한 속성들 중 어떤 것을 우선 적용할 지 계산해야 하기 위해 ‘명시도(Specificity)’를 계산한다. 명시도는 주어진 CSS 선언에 적용되는 일종의 가중치로, 각 선택자 유형의 수에 의해 결정된다. 이렇게 계산된 명시도가 서로 같을 경우, 마지막에 선언된 CSS가 적용된다.

## 14. CSS에서 변수(커스텀 프로퍼티)를 사용하는 이유는 무엇인가요?
특정한 CSS 값에 의미를 가지는 식별자를 부여하여, 문서 내에서 다시 사용하기 위해 사용한다. CSS 파일에서 직접 정의하여 사용할 수도 있고, JS를 이용해서 정의하거나 사용할 수도 있다.

### CSS에서 직접 정의 및 사용

```css
/* CSS 변수는 자식 요소에 상속됨 */
parent-element {
  --variable-name: someValue;
}

child-element {
  some-property: var(--variable-name);
}
```

### JS에서 정의 및 사용

```js
element.style.getPropertyValue("--variable-name");

element.style.setProperty("--my-variable", "10px");
```

## 15. 쌓임 맥락(Stacking Context)이란?
`z-index` 속성을 통해, **‘사람이 화면을 바라보는 방향(z축 방향)’** 기준으로 요소를 어떻게 배치할지 설정할 수 있다. `position` 속성이 기본값이 아니면서 `z-index` 값이 큰 요소는 자신보다 `z-index` 값이 작으면서 동일한 위치에 있는 요소를 보이지 않게 가리게 된다. 즉, `z-index`는 서로 겹치는 요소가 쌓이는 순서를 제어한다.

**쌓임 맥락**은 이러한 `z-index`가 적용되는 일종의 그룹이라고 생각할 수 있다. `z-index` 값은 같은 쌓임 맥락 안에 있는 요소들끼리만 비교되고 적용되며, 다른 쌓임 맥락 안에 있는 요소에 영향을 미치지 않는다. 쌓임 맥락은 다른 쌓임 맥락 안에 포함될 수 있으며, 계층 구조를 이룬다.

쌓임 맥락이 만들어지는 조건은 상당히 많지만, `isolation: isolate`를 적용해주어 별도 부수 효과 없이 의도적으로 쌓임 맥락을 만들 수 있다.