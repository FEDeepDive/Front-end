## 1. ES6에 추가된 문법

```
💡 `let`, `const`, 화살표 함수, 클래스, 모듈, 프로미스 등이 추가되었습니다. 템플릿 리터럴, 객체 리터럴 기능이 향상되었고, `String`, `Array`, `Object` 등의 객체에 메서드들이 추가되었습니다.
```

- `let`, `const`
- 향상된 템플릿 리터럴
  - 문자열 보간 (ex. `변수는 ${variable}`)
  - 여러 줄의 문자열 O
- 향상된 객체 리터럴
  - 프로퍼티 축약 표현 (프로퍼티 값으로 변수 사용 시, 프로퍼티 이름 생략 가능)
  - 메소드 축약 표현 (`function` 키워드 생략 O)
  - 프로퍼티 키 동적 생성 O (ex. `obj['No.' + i] = i`)
  - 참고: [객체 리터럴 프로퍼티 기능 확장](https://poiemaweb.com/es6-enhanced-object-property)
- 화살표 함수(Arrow Function)
- 매개변수 기본값, Spread 연산자, Rest 파라미터
- 구조분해할당(Destructuring)
- 클래스
- 모듈
- `Symbol`
  - 새로 추가된 **원시 타입**
- 프로미스
- `Map`, `Set`
- 이터레이션(Iteration) + `for...of`
  - 이터레이션 프로토콜을 준수한 객체는 `for...of` 순회 가능
  - `for...of`: 이터레이터의 `next()`를 호출하여 이터러블을 순회
  - 참고: [이터레이션과 for...of 문](https://poiemaweb.com/es6-iteration-for-of)
- 제너레이터(Generator)
  - 이터러블을 생성하는 함수
  - 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편함
  - ES7의 `async/await`과 함께 사용 가능
- `String.includes()` 등 메서드
- `Array.from()`, `Array.keys()`, `Array.find()`, `Array.findIndex()`
- `Object.entires`

```
💡 이외에도 매우 많음. 자세한 건 [공식 문서](https://262.ecma-international.org/6.0/) 확인.
참고로, ES6 이후부터는 ECMA2016, 2018처럼 년도로 표기함.
```

## 2. `var`, `const`, `let`의 차이점

```
💡 `var`는 재선언, 재할당이 불가능하고, 함수 또는 글로벌 스코프를 갖습니다. 반면 `let`, `const`는 재선언이 불가능하고, 블록 레벨 스코프를 갖습니다. `let`은 재할당이 가능하지만, `const`는 재할당이 불가능합니다.
```

|  | var | let | const |
| --- | --- | --- | --- |
| 재선언 | O | X | X |
| 재할당 | O | O | X |
| 스코프 | 함수 안 선언 시 함수 범위, 이외에는 전역 범위 | 블록({}) 범위 | 블록({}) 범위 |
| 호이스팅 | O, undefined로 초기화 | O, 초기화 X ⇒ 선언 전 사용 시 Reference Error | O, 초기화 X ⇒ 선언 전 사용 시 Reference Error |
| 기타 특성 | var 키워드 생략 가능 |  | 선언과 동시에 할당 필요 |

## 3. `null`, `undefined`?

```
💡 `null`은 빈 값이고, `undefined`는 값이 할당되지 않은 상태를 가리킵니다.
```

- `null`: 값이 비어있음
  - type: **object**
  - 빈 객체를 가리키는 객체 포인터
- `undefined`: 자료형이 지정되지 않음 (값이 할당되지 않아서)
  - type: undefined

## 4. `NaN`?

```
💡 `NaN`은 숫자가 아닌 값을 나타냅니다. 주로(항상이 아님) 숫자가 아닌 값을 숫자처럼 사용하려고 하는 경우에 `NaN`이 반환됩니다.
```

- **개념**
  - Not a Number, 즉 숫자가 아님을 나타냄
- **특징**
  - type: Number
  - 설정 불가능, 쓰기 불가능
  - `NaN === NaN` ⇒ `false`
    - [이유](https://velog.io/@eunbeann/Why-NaN-NaN-is-False): `NaN`은 다른 어떤 값과도 (자기 자신 포함) 같지 않음
    - 따라서 `NaN`인지 판별할 때 `isNaN()` 사용
- **`NaN`이 반환되는 상황**
  - 숫자로 변환 실패 (ex. `Number('abc')`)
  - 결과가 허수인 수학 계산식 (ex. `Math.sqrt(-1)`)
  - 정의할 수 없는 계산식 (ex. `0 * Infinity`, `Infinity/Infinity`)
  - `NaN` 연산 (ex. `7 * NaN`, `7 * 'abc'`) ⇒ `**NaN`은 전염성을 가짐\*\*
  - 유효하지 않은 값이 숫자로 표시되는 경우 (ex. `new Data('abc').getTime()`)

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.

```
💡 JavaScript 코드는 세미콜론이 없어도 에러가 나지 않으며, 세미콜론이 없을 경우 인터프리터가 자동으로 삽입해주기 때문입니다.
```

- **이유**
  - 세미콜론이 없어도 에러가 나지 않음
  - 세미콜론이 없을 경우, 인터프리터가 자동으로 삽입해주기 때문
- **번외**
  - **세미콜론 쓰면 좋은 점**
    - 가독성
    - 안전성
    - 범용성
  - **세미콜론 안 쓰면 좋은 점**
    - 코드 라인 위치 변경이 용이함
      ```jsx
      array
      	.map(...)
      	.filter(...) // 세미콜론이 없으면 라인 위치 변경이 간편함
      ```

## 6. `Symbol`에 대해 설명해주세요.

## 7. `==` 과 `===` 의 차이가 무엇인가요?

## 8. `for … of` / `for … in` 문

## 9. `reduce` 사용법

## 10. `splice`, `slice` 차이

## 11. 옵셔널 체이닝

## 12. NULL 병합 연산자(`??`)는 무엇인가요?

## 13. 단축평가

## 14. Promise

## 14-1. Promise란 무엇이며, async/await과 어떻게 다른지, 왜 async/await이 등장했는지?

## 14-2. Promise나 async/await를 es5로 트랜스파일하면 어떻게 되나요?

## 15. 클로저(Closure)란 무엇인가요?

## 16. 구조 분해 할당(Destructuring assignment)이란?

## 17. 전개 구문(Spread syntax)이란?

## 18. 나머지 매개변수(Rest parameters)란?

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

## 20-1. `bind`를 `apply`, `call`로 어떻게 구현할 수 있을까요? 구현해보세요.
