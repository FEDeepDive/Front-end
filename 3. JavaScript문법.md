## 1. ES6에 추가된 문법
| 기능 | 설명 | 예제 |
| --- | --- | --- |
| let과 const | 블록 스코프를 가지는 변수 선언 | let variable = 10;<br>const constant = 20; |
| 화살표 함수 | 간단한 함수 표현식 | const add = (a, b) => a + b; |
| 템플릿 리터럴 | 문자열 템플릿 표현을 더욱 간단하게 백틱(`)을 사용해 적는다. | `Hello, ${name}!` |
| 디스트럭처링 할당 | 객체나 배열에서 원하는 값 추출 및 할당 | `const { name, age } = person;  const [a,b] = [1,2]` |
| 클래스 | 객체 지향 프로그래밍을 위한 클래스 선언 | javascript class Animal { ... } const cat = new Animal(); |
| 프로미스 | 비동기 처리를 위한 객체 | javascript const fetchData = () => new Promise((resolve, reject) => { ... }); |
| 모듈 | 코드 모듈화 및 재사용을 위한 기능 | javascript import { add, subtract } from './math'; export const multiply = (a, b) => a * b; |
| 나머지 매개변수와 전개 구문 | 가변 개수의 매개변수를 다룸 | const sum = (...numbers) => numbers.reduce((acc, num) => acc + num, 0); |
| 기본 매개변수 | 함수 매개변수에 기본 값을 설정 | const greet = (name = 'Guest') => Hello, ${name}!; |
| rest 파라미터 | 함수의 마지막 매개변수로 정의되며, 나머지 인자들을 배열로 받음 | javascript const sum = (initial, ...numbers) => initial + numbers.reduce((acc, num) => acc + num, 0); |

## 2. `var`, `const`, `let`의 차이점
var의 단점은 주로 함수 스코프를 가지고 있다는 점과 호이스팅이 발생하는 것 등이다.이러한 단점을 보완하고자 ES6에서 let과 const가 도입되었다.
재할당이 필요한 경우 let 그 외의 경우 const를 사용하길 권장하고 있다.

| 특징 | var (ES5) | let (ES6) | const (ES6) |
| --- | --- | --- | --- |
| 스코프 | 함수 스코프 | 블록 스코프 | 블록 스코프 |
| 호이스팅 | O (선언부만 호이스팅) | O (선언과 초기화 모두 호이스팅) | O (선언과 초기화 모두 호이스팅) |
| 재선언 가능 | O | X | X |
| 재할당 가능 | O | O | X (상수로 간주되므로) |
| 초기화 전 참조 불가 | undefined | ReferenceError | ReferenceError |
| 전역 변수로의 호이스팅 | 가능 | 불가능 | 불가능 |
| for 루프에서의 블록 스코프 활용 | 불가능 | 가능 | 가능 |
| 상수로 사용하기 | 불가능 | 불가능 | 가능 |
| 객체와 배열에서의 활용 | 내부 속성/요소 변경 가능 | 내부 속성/요소 변경 가능 | 내부 속성/요소 변 |

## 3. `null`, `undefined`?
```
둘 다 값이 없음을 나타내는 특별한 값으로 falsy하다.
'null'은 의도적으로 표현하는 값 => 의도적인 없음
'undefined'는 값이 없을 확인하는 값 => 처음부터 없음
```
📍참고

동등 연산(==) : null == undefined ⇒ true

일치 연산(===) :  null === undefined ⇒ false

## 4. `NaN`?
1. `NaN`은 전역 객체의 속성. 즉, 전역 범위의 변수로 Not a Number(숫자가 아님) 을 뜻함.
⇒`NaN`역시 JavaScript의 [falsy](https://developer.mozilla.org/ko/docs/Glossary/Falsy) 값 중 하나

`NaN` 을 return 하는 경우
- 숫자로 변환 실패 (예시: `parseInt("blabla")`, `Number(undefined)`와 같은 명시적인 것 또는 `Math.abs(undefined)`와 같은 암시적인 것)
- 결과가 허수인 수학 계산식 (예시: `Math.sqrt(-1)`)
- 정의할 수 없는 계산식 (예시: `0 * Infinity`, `1 ** Infinity`, `Infinity / Infinity`, `Infinity - Infinity`)
- 피연산자가 `NaN`이거나 `NaN`으로 강제 변환되는 메서드 또는 표현식 (예시: `7 ** NaN`, `7 * "blabla"`) - 이것은 `NaN`이 전염성 있다는 것을 의미합니다.
- 유효하지 않은 값이 숫자로 표시되는 기타 경우 (예시: 잘못된 [날짜](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date) `new Date("blabla").getTime()`, `"".charCodeAt(1)`)

특이한 점  :
`NaN === NaN` 은 `false`다

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.
```
세미콜론 자동 삽입(ASI, automatic semicolon insertion)이라는
인터프리터가 ‘문장의 끝이라고 생각되는 지점’에 
세미콜론을 자동으로 붙여주는 기능이 있기 때문이다. 
```
그렇다면 세미콜론 자동 삽입(ASI, automatic semicolon insertion) 기능이란 무엇인가?

1. 줄바꿈이 되는 행의 마지막에
2. 행의 마지막이 `}` 이고 줄바꿈이 되어 다음 행이 시작될때
3. 파일의 끝에 도달할 때
4. `return`이 있는 행의 마지막에
5. `break`가 있는 행의 마지막에
6. `throw`가 있는 행의 마지막에
7. `continue`가 있는 행의 마지막에

⇒ 이런 규칙으로 세미콜론을 자동으로 찍어준다 하지만 ‘자동’이란 키워드와 늘 붙어다니는 문제는 의도하지 않은 상황이 발생할 수 있다는 단점이 있다는 것이다. 결론적으로 의도한 바와 일치하게 하고 싶다면, 명시적으로 찍어주는게 좋지만 뭐 자유롭게 사용해도 될거 같다. 회사에 들어간다면 팀이나 프로젝트에 따라 다를 수 있으므로, 특정한 코딩 가이드 라인을 따라가면 될 것이다.

```
사담👀 학부시절 자바와 c++을 배울때 
`싫어하는 사람이 있으면 코드중에 세미콜론 하나를 그리스어 물음표? 바꿔라` 
(요즘은 어디가 틀렸는지 다 알려주지만) 이런 말이 있을정도로 
세미콜론은 골치(?)아프면서 당연하게 중요한 요소였던거 같다. 
잠시 코딩과 멀어졌다 다시 자바스크립트를 공부할 때 자연스럽게 코드마다 끝 지점에 
새미콜론을 찍었다. 근데 안찍어도 된다는게 좋았던거 같다.
(최소한 세미콜론 하나때문에 오류를 찾으려 밤새진 않아도 될테니!) 
여전히 습관처럼 찍곤 있지만 내가 까먹어도 알아서 챙겨준다는게 너무 매력있는거 같다.
⇒ 아마 기능을 만든 의도도 초보 프로그래머들의 실수를 교정해주려는 배려일 것 같다는 
말에 공감했다. 그만큼 자바스크립트가 유연한 언어라 좋은거 같다.
```

## 6. `Symbol`에 대해 설명해주세요.
- ES6에서 도입된 7번째 데이터 타입으로 **변경 불가능한 원시 타입의 값**이다.
- 프로퍼티 키로 사용될 수 있다.
- for in문에서 무시된다.

> 👉 심벌 값은 유일무이한 값이므로 심벌 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다. 
>

>👉 심벌을 사용하면 표준 빌트인 객체도 확장 하기에 안전하다. 미래에 생길 빌트인 객체와 이름 충돌할 일이 없어짐.
>
## 7. `==` 과 `===` 의 차이가 무엇인가요?
- `==` (동등비교 연산자, Equality Operator):
    - **`==` 연산자는 값을 비교할 때 타입 변환을 수행**합니다. 따라서 **타입이 다른 두 값의 비교를 할 때 타입 변환이 일어납니다.**
    - 타입 변환 규칙에 따라 값이 같은지 비교합니다.
        - **숫자와 문자열 비교:**
            
            `console.log(5 == "5"); // true` **문 자열 "5"를 숫자 5로 변환**하여 비교
            
        - **불리언과 숫자 비교:**
        ``console.log(true == 1); // true`` **불리언 true를 숫자 1로 변환**하여 비교
        - **null과 undefined 비교:** 
        `console.log(null == undefined);// true` null과 undefined는 서로 동등하다고 간주
        - **객체와 문자열 비교:** `console.log({} == "[object Object]"); // true` 객체를 문자열로 변환하여 비교
        - **문자열과 불리언 비교:** `console.log("true" == true); // false`, 문자열 "true"를 불리언 true로 변환하여 비교 ⇒ ??? 어렵
- `===` (일치비교 연산자, Strict Equality Operator):
    - `===` 연산자는 **값과 타입을 모두 비교**합니다. 타입 변환을 수행하지 않고 엄격하게 비교합니다.
    - 비교하는 값의 타입과 값이 정확히 일치하는지 확인합니다.
    
    ⇒ 특별한 경우가 아니라면 의도치 않은 실수를 막기 위해  `===` 를 사용하는것이 좋음
## 8. `for … of` / `for … in` 문
### `for … in` 문

객체의 모든 프로퍼티를 순회하며 열거하려면 for...in 문을 사용한다.

```jsx
for (변수선언문 in 객체) {...}
```

- for...in 문은 프로퍼티를 열거할 때 순서를 보장하지 않으므로 주의 ⇒ but,대부분의 모던 브라우저는 순서를 보장하고 숫자(사실은 문자열)인 프로퍼티 키에 대해서는 정렬을 실시
- 순회 대상 객체의 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거
⇒ 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다.
- `for...in`은 인덱스의 순서가 중요한 `Array`에서 반복을 위해 사용할 수 없다.
⇒ 순서가 중요한 배열의 반복시에는 숫자 인덱스를 사용할 수 있는 for, forEach, for of를 사용하는 것을 권장한다.

**장점**

- 쉽게 객체의 속성을 확인(콘솔이나 다른 방법으로 출력)할 수 있기 때문에 실질적으로 디버깅을 위해 사용될 수 있다.
- 키-값 쌍이 선호되는 데이터의 경우(속성이 "key"의 역할을 함) 특정 값을 가진 키가 있는지 확인하려는 경우에 for...in이 효과적이다.

### `for … of` 문

`for...of` 구문은 **컬렉션** 전용이다. 모든 객체보다는, `[Symbol.iterator]` 속성이 있는 모든 컬렉션 요소에 대해 이 방식으로 반복한다.

```jsx
for (변수선언문 of 이터러블) { ... }
```

- for...of문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 for...of 문의 변수에 할당한다.
- 이터레이터 리절트객체의 done 프로퍼티 값이 false이면 이터러블의 순회를 계속하고 true이면 이터러블의 순회를 중단한다.

| 특성 | for...of | for...in |
| --- | --- | --- |
| 사용 목적 | 이터러블 객체 순회 (배열, 문자열 등) | 객체의 프로퍼티 순회 |
| 구문 | for (const value of iterable) { /* code */ } | for (const key in object) { /* code */ } |
| 반복 대상 | 이터러블 객체 (Array, Set, Map, 문자열 등) | 객체 (프로토타입 체인의 상속된 프로퍼티도 포함) |
| 순회 대상 | 값 (요소, 문자 등) | 키 (프로퍼티 이름) |
| 상속된 프로퍼티 | 미포함 | 포함 |
| 순서 보장 여부 | 보장됨 | 보장되지 않음 |
| 반복 변수 값 | 값 복사 (immutable) | 키 값 |
## 9. `reduce` 사용법
배열을 하나의 값으로 축소하는 고차 함수. 
주로 배열의 모든 요소를 하나의 값으로 합치거나 변환할 때 사용.
    
  ``` 
  	array.reduce((누적값, 현재값, 현재인덱스, 호출한배열) => {
      // 처리 로직
    }, 초기값);
  
  ```
  빈 요소를 제외하고 배열 내에 존재하는 각 요소에 대해 `callback` 함수를 한 번씩 실행
  요소를 돌면서 현재값과 누적값을 계산해 누적값을 반환한다.
  
  초기 값이 없다면 첫번째 요소를 누적값에 넣고, 두번째 값을 현재 값에 넣어서 진행한다.
  → 이는 **예상치 못한 실수를 발생하게 할 수 있으니 초기값은 항상 넣어 두는 것이 안전**하다.
  
  reduce는 가독성이 상대적으로 안좋기 때문에 map,filter로 충분히 해결 할 수 있는 문제들은 reduce사용을 하지 않는것이 좋다고 생각한다.
## 10. `splice`, `slice`,`split`차이
### **`splice()`:**

- 배열 메서드로 배열의 요소를 추가 또는 제거,교체 할 수 있다.
- 첫 번째 매개변수는 시작 인덱스이며, 두 번째 매개변수는 제거할 요소의 개수다.
- 나머지 매개변수는 배열에 추가될 요소다.
- 원본배열을 수정한다.
- 제거한 배열을 반한다.

### **`slice()`:**

- 배열 메서드로 배열의 일부분을 추출하여 새로운 배열을 반환
- 첫 번째 매개변수는 시작 인덱스이며, 두 번째 매개변수는 끝 인덱스(끝 인덱스는 제외)이다.
- 원본 배열을 변경하지 않고, 새로운 배열을 반환한다.

### **`split()`:**

- 문자열 메서드로 문자열을 지정된 구분자를 기준으로 나누어 배열로 반환합니다.
- 첫 번째 매개변수로는 구분할 문자열을 넣고 두번째 매개변수 환할 배열의 최대 길이이다.(선택사항)
- 원본 배열을 변경하지 않고, 새로운 배열을 반환한다.
- 문자열을 배열로 만들 때 많이 사용. ex. `str.split(””)`

| 메서드 | 사용 대상 | 동작 | 반환값 | 원본 변경 여부 |
| --- | --- | --- | --- | --- |
| splice | 배열 | 요소를 추가 또는 제거하고, 제거된 요소를 반환 | 제거된 요소들의 배열 | 원본 배열 변경 |
| slice | 배열 | 일부분을 추출하여 새로운 배열을 반환 | 추출된 배열 | 원본 배열 변경 안됨 |
| split | 문자열 | 구분자를 기준으로 나누어 배열로 반환 | 구분된 문자열로 이루어진 배열 | 원본 문자열 변경 안됨 |
## 11. 옵셔널 체이닝

옵셔널 체이닝 연산자는 **`?.`** 으로 표현되며, 좌항의 피연산자가 **`null` 또는 `undefined`(Nullish)**인 경우 **`undefined`를 반환**하고, 그렇지 않으면 **우항의 프로퍼티 참조** 를 이어간다. 
→ 간단하게 평가 대상이 존재하는지, 안 하는지를 체크해주고 존재할 경우 다음 평가를 진행하고 아니면 undefined를 반환한다.

- 중첩된 객체 구조에서 속성이 존재하지 않을 경우에 발생하는 오류를 방지하는 데 사용.
- 주로 객체의 속성이나 메소드에 **안전하게 접근**하기 위해 사용된다.
- 조건문이나 변수 할당 없이도 중첩된 속성에 **간편하게 접근**가능하다.
- 옵셔널 체이닝은 존재하지 않아도 괜찮은 대상에만 사용하는 것이 좋다.
⇒ 어떤 경우에는 값이 반드시 있어야 하는 경우를 구분하기 어려울 수 있기 때문. (에러가 안나니까)
[참고](https://mine-it-record.tistory.com/631)

## 12. NULL 병합 연산자(`??`)는 무엇인가요?

Null 병합 연산자는 **`??`**으로 표현되며, 왼쪽 피연산자가 **`null` 또는 `undefined`(Nullish)**일 때만 오른쪽 피연산자를 반환합니다. 그 외의 경우에는 왼쪽 피연산자를 반환
→ 평가 대상이 null이나 undefined인 경우에 오른쪽 피연산자 반환

- 주로 옵셔널 체이닝과 함께 사용
- **기본값을 설정**할 때 유용

## 13. 단축평가

논리 연산자를 사용할 때, 연산의 결과가 확정되면 나머지 연산을 수행하지 않고 바로 평가를 멈추는 동작

### **1. 논리곱 AND (`&&`)의 단축 평가:**

예전에 배울때 true=1, false=0으로 치환해서 곱했을때 0이나오면 false, 그 외엔 true이렇게 외웠던 거 같다.

| A | &&(*) | B | A &&(*) B |
| --- | --- | --- | --- |
| false(0) | &&(*) | false(0) | false(0) |
| true(1) | &&(*) | false(0) | false(0) |
| false(0) | &&(*) | true(1) | false(0) |
| true(1) | &&(*) | true(1) | true(1) |
- 조건이 Truthy값일 때 무언가를 해야한다면 논리곱 연산자 표현식으로 if문을 대체할 수 있다.

### **2. 논리합 OR (`||`)의 단축 평가:**

마찬가지로 덧셈해서 0이나오면 false, 그 외엔 true

| A |  \|\|(+) | B | A  \|\|(+) B |
| --- | --- | --- | --- |
| false(0) | \|\|(+) | false(0) | false(0) |
| true(1) |  \|\|(+) | false(0) | false(0) |
| false(0) |  \|\|(+) | true(1) | false(0) |
| true(1) |  \|\|(+) | true(1) | true(1) |

- 조건이 Falsy값일 때 무언가를 해야한다면 논리합 연산자 표현식으로 if문을 대체할 수 있다.

## 14. Promise

JavaScript는 단일 스레드 언어로, 한 번에 한 작업만 처리할 수 있다. 이로 인해 오랜 시간이 걸리는 작업이나 네트워크 요청과 같은 비동기 작업이 발생할 때 기다리면서 다른 작업을 수행할 수 없는 문제가 있었다. 이를 해결하기 위해 비동기 작업을 처리하기 위한 패턴이 필요했고, 그 중 하나가 Promise다.

## 14-1. Promise란 무엇이며, async/await과 어떻게 다른지, 왜 async/await이 등장했는지?

```markdown
🎯Promise는 비동기 작업을 다루기 위한 객체로 
1️⃣비동기 처리 상태 2️⃣처리 결과를 관리 하는 객체이다.
**주로 콜백 지옥을 방지하고 가독성**을 높이기 위해 도입됐다. 
```

Promise는 생성자 함수를 통해 new 와 함께 호출하여 생성한다. 콜백 함수인 resolve와 reject함수를 인수로 전달받고 콜백함수 내부에서 비동기 처리를 수행 한다.

- 생성방법 :  `new promise(resolve, reject)`
- Promise 객체의 세 가지 상태:
    - 프로미스 생성 직후 ⇒ **pending** : 대기 상태, 비동기 작업이 아직 완료되지 않은 상태
    - resolve함수가 호출되면 ⇒ **fulfilled** : 완료 상태,비동기 작업이 성공적으로 완료된 상태
    - reject함수가 호출 되면 ⇒ **rejected** : 실패 상태, 비동기 작업이 실패한 상태
- 후속처리 : 상태가 변하면 이에 따른 후속 처리를 한다.
    - **`.then()`**  : 두가지 콜백 함수를 인수로 받을 수 있아 암묵적으로 프로미스로 반환한다.
        - **fulfilled** → (resolve함수가 호출된 상태)가 되면 처리 결과를 인수로 받는다. ⇒ 값처리
        - **rejected → (**reject함수가 호출된 상태**)**가 되면 프로미스의 에러를 인수로 받는다. ⇒에러처리
    - `**.catch()` :** 한가지 콜백 함수를 인수로 받음 **rejected 인 상태만 호출 됨**
    - `.**finally()` :** Promise가 이행되던, 거부되던 항상 실행되는 콜백 함수를 등록
    - 이 밖에도 여러가지 후속 처리 메서드들이 있음

그러나 Promise 자체는 여전히 콜백을 사용하기 때문에, 여러 개의 비동기 작업을 연결하거나 순차적으로 실행하는 등의 상황에서도 복잡성이 발생할 수 있다.

## 14-2. Promise나 async/await를 es5로 트랜스파일하면 어떻게 되나요?

**Promise**는 **ES5로** 바뀌더라도 그대로이고 polyfill을 통해 **Promise** 객체**를** 추가해주어야한다. **async await**는 polyfill을 추가해주지 않아도 바뀌며 알아서 따로 **async** 관련 함수**를** 만들어주고 while, switch 문 등을 활용해서 만들어준다.

## 15. 클로저(Closure)란 무엇인가요?

```markdown
클로저는 주로 캡슐화, 정보 은닉, 비동기 작업에서의 상태 유지 등 다양한 상황에서 활용되며, 
제대로 사용할 경우 코드의 가독성과 유지보수성을 높일 수 있다.
```

- 정의 :
    
    함수와 그 함수가 선언된 렉시컬 스코프(lexical scope)의 조합으로, 함수가 외부 스코프의 변수에 접근 가능하게 하는 개념
    
- 발생 조건 :
    - 함수는 다른 함수 내에서 선언되어야 하며(중첩함수)
    - 내부 함수는 반환되거나 매개변수로 전달되어 외부 함수 외부에서 사용되어야 함.
- 특징 :
    - 렉시컬 스코프를 기반으로 동작하여 선언 시점에 외부 스코프의 변수에 대한 참조를 유지
    
    ⇒ 함수는 자신이 선언된 스코프 외부의 변수에 접근할 수 있고, 해당 변수가 사라진 이후에도 사용할 수 있다
    
- 장점 :
    - **캡슐화:** 변수와 함수를 외부에서 보호하고 접근을 제어할 수 있다.
    - **상태 유지:** 외부 변수의 상태를 유지하므로 함수 호출 간에 정보를 전달할 수 있다.
- 단점 :
    - **메모리 누수:** 클로저가 외부 스코프의 변수에 계속 접근하는 경우 메모리 누수가 발생할 수 있다.
    - **복잡성:** 오용 시 코드를 이해하고 유지보수하기 어려울 수 있다.

## 16. 구조 분해 할당(Destructuring assignment)이란?
구조화된 배열과 같은 이터러블 또는 객체를 파괴하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. 배열과 같은 이터러블 또는 객체 리터럴에서 필요한 값만 추출하여 변수에 할당할 때 유용하다.

### 배열구조분해할당

👉배열 디스트럭처링 할당의 대상(할당문의 우변)은 이터러블이어야 하며, 할당 기준은 **배열의 인덱스**다. 즉, **순서대로 할당**된다.

```jsx
const arr = [1, 2, 3];

const [one, two, three] = arr;
console.log(one, two, three); // 1 2 3
```

```jsx
// 왼쪽 배열리터럴 = 오른쪽 이터러블
const [x, y] = [1, 2];
console.log(x,y); // 1 2

const [x, y] = [1, 2, 3, 4, 5, 6];
console.log(x,y); // 1 2
```

✔️이때 변수의 개수와 이터러블의 요소 개수가 반드시 일치할 필요는 없다.

✔️ 배열 디스트럭처링 할당을 위한 변수에 **기본값을 설정할 수 있다**.

```jsx
// 기본값
const [a, b, c = 3] = [1, 2];
console.log(a, b, c); // 1 2 3
// 기본값보다 할당된 값이 우선한다.
const [e, f = 10, g = 3] = [1, 2];
```

✔️ 배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 **Rest 요소를 사용할 수 있다.**

```jsx
const [x, ...y] = [1, 2, 3];
console.log(x, y); // 1 [ 2, 3 ]
```

### 객체구조분해할당

👉 객체 디스트럭처링 할당의 대상(할당문의 우변)은 객체이어야 하며, 할당 기준은 **프로퍼티 키**다. 즉, **순서는 의미가 없으며 선언된 변수 이름과 프로퍼티 키가 일치하면 할당**된다.

```js
const user = { firstName: 'Youngeun', lastName: 'Kim' };

const { lastName, firstName } = user;
console.log(firstName, lastName); // Youngeun Kim
```

```js
// 왼쪽 객체리터럴 = 오른쪽 객체 또는 객체로 평가될 수 있는 표현식(문자열, 숫자, 배열 등)
const { lastName, firstName } = { firstName: 'Youngeun', lastName: 'Kim' };
```

✔️ 객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 따로 선언해줘야함

```js
const user = { firstName: 'Youngeun', lastName: 'Kim' };

const { lastName: ln, firstName: fn } = user;
console.log(fn, ln); // Youngeun Kim
```

✔️ 배열때와 마찬가지로 기본값 설정 가능, 중첩 가능

```jsx
let person = { name: 'John', age: 30, address: { city: 'New York' } };

let { name, age, address: { city = 'Unknown' } } = person;

console.log(name); // 'John'
console.log(age);  // 30
console.log(city); // 'New York' (기본값이 없으면 'Unknown')
```

✔️ 객체에서 프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용하다.

```jsx
const str = 'Hello';
// String 래퍼 객체로부터 length 프로퍼티만 추출한다.
const { length } = str;
console.log(length); // 5
const todo = { id: 1, content: 'HTML', completed: true };
// todo 객체로부터 id 프로퍼티만 추출한다.
const { id } = todo;
console.log(id); // 1
```

✔️ 함수의 매개변수로 사용 가능

```jsx
function printPerson({ name, age }) {
    console.log(`${name} is ${age} years old.`);
}

let person = { name: 'Alice', age: 25 };
printPerson(person);
```

✔️ 배열의 요소가 객체인 경우 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.

## 17. 전개 구문(Spread syntax)이란?

ES6에서 도입된 스프레드 문법`...`은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서개별적인 값들의 목록으로 만든다.

✔️ 스프레드 문법을 사용할 수 있는 대상 : for...of 문으로 순회할 수 있는 이터러블에 한정
ex.Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection), arguments

```jsx
// 배열
console.log(...[1, 2, 3]); // 1 2 3
// 문자열
console.log(...'Hello'); // H e l l o
// Map과 Set
console.log(...new Map([['a', '1'], ['b', '2']])); // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{ a: 1, b: 2 }); // TypeError: Found non-callable @@iterator
```

🚨 **스프레드 문법의 결과는 값이 아니다.** 
⇒  쉼표로 구분한 **값의 목록**을 사용하는 문맥에서만 사용할 수 있다.

✔️ 얇은 복사, 추가를 할 수 있다.

```jsx
// 배열
let arr1 = [1, 2, 3];
let arr2 = [...arr1, 4, 5];
// 객
let obj1 = { a: 1, b: 2 };
let obj2 = { ...obj1, c: 3, d: 4 };
```
## 16. 구조 분해 할당(Destructuring assignment)이란?

구조화된 배열과 같은 이터러블 또는 객체를 파괴하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. 배열과 같은 이터러블 또는 객체 리터럴에서 필요한 값만 추출하여 변수에 할당할 때 유용하다.

### 배열구조분해할당

👉배열 디스트럭처링 할당의 대상(할당문의 우변)은 이터러블이어야 하며, 할당 기준은 **배열의 인덱스**다. 즉, **순서대로 할당**된다.

```jsx
const arr = [1, 2, 3];

const [one, two, three] = arr;
console.log(one, two, three); // 1 2 3
```

```jsx
// 왼쪽 배열리터럴 = 오른쪽 이터러블
const [x, y] = [1, 2];
console.log(x,y); // 1 2

const [x, y] = [1, 2, 3, 4, 5, 6];
console.log(x,y); // 1 2
```

✔️이때 변수의 개수와 이터러블의 요소 개수가 반드시 일치할 필요는 없다.

✔️ 배열 디스트럭처링 할당을 위한 변수에 **기본값을 설정할 수 있다**.

```jsx
// 기본값
const [a, b, c = 3] = [1, 2];
console.log(a, b, c); // 1 2 3
// 기본값보다 할당된 값이 우선한다.
const [e, f = 10, g = 3] = [1, 2];
```

✔️ 배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 **Rest 요소를 사용할 수 있다.**

```jsx
const [x, ...y] = [1, 2, 3];
console.log(x, y); // 1 [ 2, 3 ]
```

### 객체구조분해할당

👉 객체 디스트럭처링 할당의 대상(할당문의 우변)은 객체이어야 하며, 할당 기준은 **프로퍼티 키**다. 즉, **순서는 의미가 없으며 선언된 변수 이름과 프로퍼티 키가 일치하면 할당**된다.

```jsx
const user = { firstName: 'Youngeun', lastName: 'Kim' };

const { lastName, firstName } = user;
console.log(firstName, lastName); // Youngeun Kim
```

```jsx
// 왼쪽 객체리터럴 = 오른쪽 객체 또는 객체로 평가될 수 있는 표현식(문자열, 숫자, 배열 등)
const { lastName, firstName } = { firstName: 'Youngeun', lastName: 'Kim' };
```

✔️ 객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 따로 선언해줘야함

```jsx
const user = { firstName: 'Youngeun', lastName: 'Kim' };

const { lastName: ln, firstName: fn } = user;
console.log(fn, ln); // Youngeun Kim
```

✔️ 배열때와 마찬가지로 기본값 설정 가능, 중첩 가능

```jsx
let person = { name: 'John', age: 30, address: { city: 'New York' } };

let { name, age, address: { city = 'Unknown' } } = person;

console.log(name); // 'John'
console.log(age);  // 30
console.log(city); // 'New York' (기본값이 없으면 'Unknown')
```

✔️ 객체에서 프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용하다.

```jsx
const str = 'Hello';
// String 래퍼 객체로부터 length 프로퍼티만 추출한다.
const { length } = str;
console.log(length); // 5
const todo = { id: 1, content: 'HTML', completed: true };
// todo 객체로부터 id 프로퍼티만 추출한다.
const { id } = todo;
console.log(id); // 1
```

✔️ 함수의 매개변수로 사용 가능

```jsx
function printPerson({ name, age }) {
    console.log(`${name} is ${age} years old.`);
}

let person = { name: 'Alice', age: 25 };
printPerson(person);
```

✔️ 배열의 요소가 객체인 경우 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.

## 17. 전개 구문(Spread syntax)이란?

ES6에서 도입된 스프레드 문법`...`은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서개별적인 값들의 목록으로 만든다.

✔️ 스프레드 문법을 사용할 수 있는 대상 : for...of 문으로 순회할 수 있는 이터러블에 한정
ex.Array, String, Map, Set, DOM 컬렉션(NodeList, HTMLCollection), arguments

```jsx
// 배열
console.log(...[1, 2, 3]); // 1 2 3
// 문자열
console.log(...'Hello'); // H e l l o
// Map과 Set
console.log(...new Map([['a', '1'], ['b', '2']])); // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1, 2, 3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{ a: 1, b: 2 }); // TypeError: Found non-callable @@iterator
```

🚨 **스프레드 문법의 결과는 값이 아니다.** 
⇒  쉼표로 구분한 **값의 목록**을 사용하는 문맥에서만 사용할 수 있다.

✔️ 얇은 복사, 추가를 할 수 있다.

```jsx
// 배열
let arr1 = [1, 2, 3];
let arr2 = [...arr1, 4, 5];
// 객
let obj1 = { a: 1, b: 2 };
let obj2 = { ...obj1, c: 3, d: 4 };
```

## 18. 나머지 매개변수(Rest parameters)란?

👉 Rest 파라미터는 세 개의 점(**`...`**)으로 표현하 이름 그대로 먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당된다.  따라서 Rest 파라미터는 반드시 **마지막 파라미터**이어야 한다.

✔️ 화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 Rest 파라미터를 사용해야 한다.
⇒ 화살표 함수 함수 자체의 arguments 객체를 갖지 않기 때문에
✔️ 하나의 함수 정의에서는 하나만 사용할 수 있습니다.

🚨 Rest 파라미터에는 기본값을 지정할 수 없다

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

`use strict` 는 엄격한 모드(strict mode)를 활성화 하는 문이다.

- 스크립트 전체에 대한 선언을 맨 위에 위치시키는 것이 가장 일반적이고 권장되는 방법이다.
- 

### **장점:**

- **에러 방지:** 엄격 모드는 몇 가지 일반적인 프로그래밍 오류를 에러로 변환한다. 예를 들어, 변수를 선언하지 않고 사용하거나, 변수 삭제 시도, 읽기 전용 속성에 값 할당 시도 등의 오류를 빠르게 감지한다.
- **보안 강화:** 엄격 모드는 보안에 관련된 취약점을 해결하고, 코드 실행을 예측 가능하게 만들어 안전성을 향상시킨다.
- **성능 개선:** 몇 가지 최적화 기회를 제공하여 일부 경우에는 코드 실행 속도를 향상시킬 수 있다.
- **디버깅 용이성:** 엄격 모드는 디버깅을 돕는 추가 정보를 제공하므로 오류를 신속하게 파악하고 수정할 수 있다.

### **단점:**

- strict mode 스크립트와 non-strict mode 스크립트를 혼용하는 것은 오류를 발생시킬 수 있다.
- strict mode가 적용된 함수가 참조할 함수 외부의 컨텍스트에 strict mode를 적용하지 않는다면 이 또한 문제가 발생할 수 있다.
- 함수단위로 적용이 가능한데 어떤 함수는 적용하고 어떤 함수는 적용하지 않는것이 바람직 하지 않으며, 일일히 적용하는것은 번거롭다.

⇒ 즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용해 스코프 단위로 사용하는것이 좋다.

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

👉apply, call, bind 메서드는 Function.prototype의 메서드다. 즉, 이들 메서드는 모든 함수가 상속받아 사용할 수 있다. 모두 **함수를 호출**할 때 특정한 **`this`** 값을 설정할 수 있는 메소드다.

### `apply`

```jsx
/**
 * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다.
 * @param thisArg - this로 사용할 객체
 * @param argsArray - 함수에게 전달할 인수 리스트의 배열 또는 유사 배열 객체
 * @returns 호출된 함수의 반환값
*/
Function.prototype.apply(thisArg[, argsArray])
```

✔️ apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다

### `call`

```jsx
/**
 * 주어진 this 바인딩과 ,로 구분된 인수 리스트를 사용하여 함수를 호출한다.
 * @param thisArg - this로 사용할 객체
 * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트
 * @returns 호출된 함수의 반환값
*/
Function.prototype.call (thisArg[, arg1[, arg2[, ...]]])
```

✔️ call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.

⭐ apply와 call 메서드는 호출할 함수에 **인수를 전달하는 방식만 다를 뿐** this로 사용할 객체를 전달하면서 함수를 호출하는 것은 동일하다.
→ **`apply`와 `call`**는 함수를 즉시 호출하면서 실행합니다.

### **`bind`**

```jsx
Function.prototype.bind(thisArg, arg1, arg2, ...)
```

 ✔️ apply와 call 메서드와 달리 **함수를 호출하지 않고**, 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 **함수를 새롭게 생성해 반환**한다.
## 20-1. `bind`를 `apply`, `call`로 어떻게 구현할 수 있을까요? 구현해보세요.
1. **`apply`로 `bind` 구현:**
    
    ```js
    function customBindWithApply(fn, thisArg, ...args) {
      return function() {
        return fn.apply(thisArg, args.concat(Array.from(arguments)));
      };
    }
    
    // 사용 예제:
    function greet(name, greeting) {
      console.log(`${greeting}, ${name}!`);
    }
    
    var boundGreet = customBindWithApply(greet, null, "John");
    boundGreet("Hello");
    
    ```
    
2. **`call`로 `bind` 구현:**
    
    ```js
    function customBindWithCall(fn, thisArg, ...args) {
      return function() {
        return fn.call(thisArg, ...args, ...arguments);
      };
    }
    
    // 사용 예제:
    function greet(name, greeting) {
      console.log(`${greeting}, ${name}!`);
    }
    
    var boundGreet = customBindWithCall(greet, null, "John");
    boundGreet("Hello");
    
    ```
    ⇒ 새로운 함수를 생성해서 구현하는거라는데,, gpt도움 받았습니다..
    