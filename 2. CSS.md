## 1. position 속성에 대해 설명해주세요.
<<<<<<< HEAD
```
글의 흐름에서 벗어나서 요소를 자유롭게 배치할 때 쓰는 속성
```
=> 기본값 static CSS공부한지 꽤 돼서 
순간 relative가 기본값으로 생각했다.

### 위치
    포지션의 위치를 정할땐 top, right, bottom, left 속성으로 위치를 정할 수 있다. 
  ![Alt text](image.png)
### static
     기본값이고, static인 경우 원래 있어야 할 위치에 배치.
### relative
    요소의 원래 위치를 기준으로 배치.요소의 원래 자리는 그대로 차지하고 있다.
 원래의 자리를 차지하면서 그 기준에 따라 위치를 정할 수 있다.

### absolute
    포지션 속성이 있는 가장 가까운 조상요소를 기준으로 배치하는 속성.
    글의 흐름에서 완전히 빠져서, 요소의 원래 자리는 차지하지 않는다. 

### fixed
    브라우저 화면을 기준으로 고정된 배치
    글의 흐름에서 완전히 빠져서, 요소의 원래 자리는 차지하지 않는다.
    => 내비게이션을 만들거나 할 때 fixed속성을 쓴다면 겹치지 않도록 타 요소에 마진을 넣어줌.

### sticky
    static처럼 원래 위치에 배치되어 있다가, 정해진 위치에 브라우저가 스크롤되면 그때부터 fixed처럼 고정되어 배치 
    기본적으로는 static처럼 배치되기 때문에 요소의 원래 자리를 차지함.
### z-index
    앞뒤 순서를 정할 때 쓰는 값
  -  순서기 때문에 단위 없이 쓴다. 
  -  값이 높을수록 화면에서 앞쪽. 
  -  값이 같으면 코드에서 아래 줄에 있는 요소가 앞쪽에 보임.
## 2. display 속성에 대해 설명해주세요.
    글의 흐름에서 요소를 어떻게 배치 할 지 정하는 속성
  -블록(Block)속성
  - 위에서 아래로 차례대로 배치되는 요소. 
  - 크기를 지정할 수 있다.  

    ex.`<h1>, <h2>, …, <h6> ,<p> ,<div> `
  
  -인라인(Inline)속성
  - 글을 쓰는 방향으로 줄이 바뀌면서 배치
  - 블록과 달리 크기를 지정불가

    ex.`<a>,<br>,<img>,<span>`
  
  -인라인 블록(Inline-block)속성

  인라인처럼 배치되지만 블록처럼 크기를 가지고 싶을 때 사용하는 display 속성

  |   | 블록 | 인라인 블록 | 인라인 |
  | --- | --- | --- | --- |
  | 기본 크기 | 좌우로 꽉 참 | 콘텐트에 딱 맞게 | 콘텐트에 딱 맞게 |
  | 배치 | 위에서 아래로 | 글 쓰는 방향 |글 쓰는 방향 |
  | width 와 height | O | O | X |
  | margin 과 padding | O | O | 	인라인 진행 방향(=가로)만 제대로 사용 가능 | 

## 3. box model이란?
![Alt text](image-1.png)

HTML/CSS에서 요소는 기본적으로 박스 형태

밖에서부터 차례대로 바깥 여백인 마진, 테두리인 보더, 테두리와 실제 내용 사이의 여백인 패딩, 그리고 실제 내용이 들어가는 콘텐트 박스가 있다.

## 4. `box-sizing`에 대해 설명해주세요.
    웹 페이지에서 박스 모델의 크기를 계산하는 방법을 정의하는 CSS 속성
- `content-box` (기본값) :
   content 부분만을 기준으로 박스의 크기를 계산. 즉, 너비와 높이에는 내용(content)만 포함되고, 안쪽 여백, 테두리, 그리고 바깥 여백은 추가로 고려되지 않는다.
  
- `border-box` :
   content, 안쪽 여백, 테두리까지 모두를 포함하여 박스의 크기를 계산. 즉,  요소의 크기를 지정할 때, 테두리와 안쪽 여백이 추가로 고려되어 적용된다.

   => 특정 크기의 요소를 만들 때 테두리와 안쪽 여백이 함께 고려되면서 예상치 못한 레이아웃 문제를 발생하게 할 수 있기 때문에  좀 더 직관적으로 크기를 지정하고 싶다면,`content-box` 대신에 `border-box`를 쓴다

## 5. 마진 상쇄(margin Collapsing)가 왜 일어나는지, 해결방법?
- 정의 : **어떤 두 개 이상 블록 요소의 상하 마진이 겹칠 때 어느 한 쪽의 값만 적용하는 브라우저 나름의 렌더링 규칙**
- 공통규칙 : 
    - 마진 상쇄는 인접한 두 박스가 온전한 block-level 요소일 경우에만 적용됨.
    - 마진 값이 0이더라도 상쇄 규칙은 적용됨.
    - 좌우 마진은 겹치더라도 상쇄안됨.
- 제외규칙 :
    - 박스가 `position: absolute` 된 상태
    - 박스가 `float: left/right` 된 상태 (단, clear 되지 않은 상태)
    - 박스가 `display: flex`일 때 내부 flexbox item
    - 박스가 `display: grid` 일 때 내부 grid item    
- 발생하는 상황 :
  - **인접 형제 박스 간 상하 마진이 겹칠 때:** 겹쳐진 두 마진 값을 비교해, 더 큰 마진 값으로 상쇄해 렌더링한다. 만약 겹쳐진 두 값이 동일할 경우, 중복을 상쇄해 렌더링한다.
  - **부모/자식간에 마진이 겹칠 때 :** 부모와 첫 번째(마지막) 자식 사이에 inline 콘텐츠(텍스트 등)가 없거나, (상·하단)에 명시적으로 padding 또는 border 값을 주지 않았다면 마진이 겹치게 된다. 
  - **빈 요소의 상하 마진이 겹칠 때 :** 빠른 레이아웃 구성을 위해 div로 영역을 만들어 놓을 경우,
내부에 요소를 append 하기 위해 빈 컨테이너를 만들어 놓을 경우 등

    '빈 요소' 란 높이(height)가 0인 상태의 블록 요소를 말함.
    - height / min-height / padding / border 등 상하로 늘어나는 프로퍼티 값을 명시적으로 주지 않았거나
내부에 Inline 콘텐츠가 존재하지 않는 요소
    - height / min-height / padding / border 등 상하로 늘어나는 프로퍼티 값을 명시적으로 주지 않았거나
내부에 Inline 콘텐츠가 존재하지 않는 요소
- 해결방법 :
  - 부모요소에 패딩,보더,오버플로우히든 적용
  - float 속성 사용 =>다른 레이아웃 이슈를 일으킬 수 있으므로 주의
      

## 6. reset.css/normalize.css에 대해 설명해주세요.

- Reset CSS:

      reset.css는 모든 브라우저에서 기본 스타일을 제거하고, 모든 요소를 초기 상태로 리셋하는 스타일 시트이다.
      각 브라우저는 기본적으로 각 요소에 대해 다르게 스타일을 적용하므로, 이를 통일시키고 초기화하여 동일한 기본 스타일을 갖도록 도와줌.
  
  Reset CSS는 모든 스타일을 제거하므로, 디자이너가 전체적인 스타일을 완전히 재정의해야 합니다.

- Normalize CSS:

      normalize.css는 리셋과 달리 브라우저 간의 일관성을 유지하면서 유용한 기본 스타일을 제공한다.
      각 브라우저의 스타일 차이를 최소화하면서, 기본적인 스타일을 설정하여 일관된 시작점을 제공한다.
  디자이너가 필요한 경우에만 스타일을 재정의하면 되므로, 기본적인 디자인을 크게 건드리지 않는다.

## 7. sass, css module, css in js 차이점

**Sass**
CSS 의 단점을 보완하기 위해 만든 CSS 전처리기

- CSS내에 반복되는 내용을 줄이고 효과적으로 스타일시트를 유지 보수 할 수 있다.
- CSS 파일 그 자체를 SCSS로 확장자만 바꾸어주어도 정상적으로 작동
- 변수의 사용, 조건문과 반복문, Import, Nesting, Mixin, Extend/Inheritance 등의 기능을 제공 한다.
- 다만 SASS 자체는 개발자용 언어이기 때문에 웹브라우저가 읽을 수 없음
    
    ⇒ 컴파일러를 거쳐서 CSS로 변환한 후 HTML에 연결해야 한다.
    
- SASS에는 Sass와 SCSS가 있다. (작성방식(문법)이 약간 다름)
    
    →Sass -들여쓰기 , SCSS- 대괄호와 세미콜론 사용
    
    |  | SCSS | SASS | CSS |
    | --- | --- | --- | --- |
    | 중괄호 {} | 필요 | 불필요(들여쓰기) | 필요 |
    | 세미콜론 ; | 필요 | 불필요 | 필요 |
    | : 뒤의 공백 | 불필요 | 필요 | 불필요 |
    | Mixin | @mixin | = | 없음 |
    | Include | @include | + | 없음 |
    | 확장자 | .scss | .sass | .css |

**CSS module**
CSS를 사용할 때 클래스 이름을 고유한 값으로 자동으로 만들어서 컴포넌트 스타일 클래스이름이 중첩되는 현상을 방지해 주는 기술이다.

- CSS Module을 이용하면 클래스명이 충돌하는 단점을 극복할 수 있다.
- CSS Module은 컴포넌트 단위로 스타일을 적용할 때 유용하다.
- import를 할 때 앞에 이름을 지정하고, 클래스에 적용시킬 때는 메서드를 호출하는 것 처럼 CSS module 클래스명을 호출하면 된다.
- 클래스 이름들은 주로 React 컴포넌트에서 JavaScript 코드에서 참조된다.

**CSS in JS**
단어 그대로 JavaScript코드에서 CSS를 작성하는 방식

- 스타일을 컴포넌트에 캡슐화하여 전역 스타일 충돌을 방지
- 동적 스타일링을 쉽게 구현
- React와 같은 컴포넌트 기반 라이브러리에서 유용

## 8. 이미지를 img src 태그로 만드는 것과 요소의 background로 만들었을 때의 차이점
이미지를 마크업 하는 두가지 방법이다. 용도에 맞게 잘 사용하는게 좋을 것 같다.

<**img>태그를 사용해서 마크업 ⇒ 전경 처리**

- 특징 :
    - **`<img>`** 태그를 사용하여 **이미지를 문서에 콘텐츠로 포함**시킨다.
    - 스크린 리더 및 검색 엔진에 대체 텍스트를 제공한다.( `alt` 속성 사용)
    - `**src`** 속성을 통해 브라우저는 이미지를 다운로드하고 페이지에 표시할 수 있다.
    - 이미지 외에도 텍스트나 다른 HTML 요소를 포함할 수 있다.
- 전경처리가 더 효과적인 상황
    - 이미지의 크기가 레이아웃에 영향을 미칠 때⇒반응형으로 이미지를 써야 할 때
    - 이미지에 구체적인 정보가 담겨있을 때
    - 사용자가 등록하는 데이터 이미지일 때
    - 인쇄 시 이미지까지 출력되어야 할 때
    - 검색엔진에 이미지까지 노출이 필요할 때, 이미지검색 SEO효과

**요소의 background로 이미지를 넣는법 ⇒배경처리**

- 특징 :
    - 주로 시각적 디자인과 스타일링에 중점
    - 스크린 리더에게 이미지 정보를 전달하는 데는 한계가 있다.
    - CSS속성으로 크기와 위치를 제어해야 한다.
    - [CSS sprite 기법](https://www.w3schools.com/css/css_image_sprites.asp)을 통해 이미지를 하나로 병합함으로써 파일 호출 횟수를 줄일 수 있습니다.
    ⇒ [메모리와 네트워크 사용량을 절약하는 효과](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Images/Implementing_image_sprites_in_CSS)를 가져와 사이트 성능 개선에 도움을 줌
- 배경처리가 더 효과적인 상황
    - **꾸밈(디자인) 요소로만 사용할 때**
    - **성능 향상을 위해, IR 기법 & Sprite 기법**
    - **개발 생산성과 유지보수 효율 향상을 위해, 아이콘 시스템**
    - **인쇄 시 이미지는 출력되지 않기를 원할 때**

## 9. `visibility: hidden`과 `display: none`의 차이점
`visibility: hidden`과 `display: none`은 둘 다 요소를 화면에서 숨기는 CSS 속성

- `visibility: hidden`
    - 요소를 화면에서 숨기지만, 레이아웃에서 차지하는 공간은 유지됨
        
        ⇒ 시각적으로는 보이지 않지만, 투명하게 공간을 차지
        
- `display: none`
    - 요소를 화면에서 숨기면서, 레이아웃에서도 해당 요소의 공간을 차지안함.
        
        ⇒  화면에서 완전히 사라지며, 다른 요소들에 대한 레이아웃 계산에서 제외됨
        

```markup
따라서 두 속성을 사용할 때, 숨긴 요소가 레이아웃에 영향을 주지 않아야 할 경우
**display: none**을 사용하는 것이 더 적합하고, 공간은 유지하면서 시각적으로만 숨기고 싶을 때는
**visibility: hidden**을 사용하는것이 좋다.
```

| 특성 | visibility: hidden | display: none |
| --- | --- | --- |
| 화면에서의 시각성 | 화면에서 보이지 않음 | 화면에서 완전히 사라짐 |
| 레이아웃 공간 유지 여부 | 공간을 계속 차지함 | 공간을 차지하지 않음 |
| 인터랙션 가능 여부 | 인터랙션 가능 | 인터랙션 불가능 |
| 주로 사용되는 상황 | 요소를 시각적으로 숨기되, 레이아웃에 공간을 유지해야 할 때 | 요소를 완전히 숨기고, 레이아웃에서 공간이 요 없을 때 |
## 10. 반응형 웹의 3요소
반응형 : 다양한 디바이스와 화면 크기에 대응하여 웹 페이지를 최적화하는 디자인 접근 방식

**그리드 레이아웃 (Flexible Grid Layout)**

- CSS 그리드 레이아웃이나 Flexbox를 활용하여 유연하게 배치한다.
- 상대적인 단위(%, em, rem)를 사용하여 레이아웃을 정의한다.

**유동적인 이미지와 미디어 (Flexible Images and Media)**

- 이미지와 미디어 요소도 다양한 화면 크기에 적응하여 화면에 최적화된 크기로 표시
- CSS의 **`max-width: 100%`**나 **`img`** 태그의 **`width: 100%`** 등을 사용하여 이미지가 부모 요소에 맞춰 유연하게 크기 조절될 수 있도록 함.

**미디어 쿼리 (Media Queries) - @media**

- 디바이스의 특성에 따라 스타일이나 레이아웃을 다르게 적용하기 위함
- 특정 스타일을 적용함으로써 반응형 디자인을 구현
- CSS의 미디어 쿼리를 사용하여 특정 조건(화면 크기, 해상도 등)에 맞춰 스타일 시트를 로드

```css
@media (조건) {
  /* 조건을 만족할 때 적용될 스타일 */
}
```
## 11. 미디어 쿼리의 동작 방식과 좋은 예시를 들어주세요.
**미디어 쿼리 구문 동작방식 및 구성 요소:**

- **미디어 타입(Media Type) 지정**
`@media` 규칙으로 시작하여 미디어 쿼리를 정의
`media_type` 부분은 특정한 미디어 타입을 지정한다
⇒여기 코드가 어떤 미디어를 위한 것인지 브라우저에 알려주는 미디어 유형
ex. `all`, `screen`, `print`
- **미디어 특성(Media Feature) 지정:**
`and` 키워드를 사용하여 미디어 타입과 미디어 특성을 연결
`media_feature` 부분은 미디어의 특정한 특성을 지정
ex**.** `width`, `height`, `min-width`, `max-width`, `orientation`
- **조건 설정:**
조건을 설정하여 특정 미디어 특성에 대한 범위를 지정
ex. `min-width: 600px`

```css
/* 600px 이하의 너비일 때 적용되는 스타일 */
@media screen and (max-width: 600px) {
  body {
    background-color: lightblue;
  }
}

/* 601px 이상의 너비일 때 적용되는 스타일 */
@media screen and (min-width: 601px) {
  body {
    background-color: lightgreen;
  }
}
```

조건이 충족되면 스타일 규칙 적용 뷰포트의 특정 조건에 따라 CSS 규칙을 적용하여 웹 페이지를 반응형으로 만들 수 있음.
## 12. CSS에서 사용되는 단위들에 대해 설명해주세요.
1. **절대 길이 단위 (Absolute Length Units):**
    - **px (픽셀):** 가장 일반적으로 사용되는 단위로, 화면의 해상도에 따라 다르지만 고정된 크기.
    - **in (인치):** 1 인치에 해당하는 크기.
    - **cm (센티미터):** 1 센티미터에 해당하는 크기.
    - **mm (밀리미터):** 1 밀리미터에 해당하는 크기.
2. **상대 길이 단위 (Relative Length Units):**
    - **em:** **부모 요소의 폰트 크기**에 대한 상대적인 크기
    - **rem:** **루트 요소**(보통 **`<html>`**)의 폰트 크기에 대한 상대적인 크기.
    - **% (퍼센트):** **부모 요소**에 대한 상대적인 크기.
3. **Viewpoint Percentage Length Units:**
    - **vw (뷰포트 너비):** 뷰포트 너비의 백분율로 크기를 씀.
    - **vh (뷰포트 높이):** 뷰포트 높이의 백분율로 크기를 씀.
    - **vmin:** 뷰포트의 높이 또는 너비 중 작은 쪽에 대한 백분율 크기를 씀.
    - **vmax:** 뷰포트의 높이 또는 너비 중 큰 쪽에 대한 백분율 크기를 씀.
4. **상대적인 디스플레이 단위:**
    - **% (퍼센트):** 부모 요소에 대한 백분율로 요소의 크기를 씀.
    - **fr (fractional unit):** 그리드 레이아웃에서 사용되며, 사용 가능한 공간의 비율을 나타냄.
5. **색상 단위:**
    - **RGB, RGBA:** 빨강, 초록, 파랑의 색상을 나타냅니다. RGBA에서 A는 투명도를 나타냄.
    - **HEX:** RGB 색상을 16진수로 나타낸 것.
    - **HSL, HSLA:** 색상, 채도, 밝기(또는 투명도)를 나타냄.
## 13. 선택자의 우선순위에 대해 설명해주세요.
화면에 그려질 때 어떤 CSS를 적용시킬지에 대한 규칙

1. **인라인 스타일 (Inline Styles):** 가장 높은 우선순위를 가지며, 직접 **HTML 요소**의 **`style`** 속성에 정의된 스타일. 계산시 `1000` 으로 계산
2. **아이디 선택자 (ID Selectors):** ID 선택자로 선택된 요소에 적용된 스타일은 인라인 스타일 다음으로 높은 우선순위를 가짐. 계산시 `100` 으로 계산
3. **클래스 선택자 및 속성 선택자 (Class Selectors & Attribute Selectors):** 클래스 선택자와 속성 선택자로 선택된 요소에 적용된 스타일은 아이디 선택자 다음으로 높은 우선순위를 가짐. 계산시 `10` 으로 계산
4. **요소 선택자 및 가상 클래스 선택자 (Type Selectors & Pseudo-class Selectors):** 요소 선택자와 가상 클래스 선택자로 선택된 요소에 적용된 스타일은 클래스 선택자와 속성 선택자 다음으로 높은 우선순위를 가짐.계산시 `1` 으로 계산
5. **전체 선택자 (*):** 가장 낮은 우선순위를 가지며, 모든 요소에 영향을 미침. 계산시 `0` 으로 계산
⇒ 각 선택자 우선순위 값들을 더하면 높은 순서대로 전체 선택자 우선순위가 된다.
동일한 우선순위를 갖는 경우에는 나중에 정의된 스타일 규칙이 우선됨.

계산 시, 다 더해서 높은순서로 명시도를 계산하고(자세하게 적을 수록) 우선순위가 됨

이 외에도 **`!important`**를 사용하면 일반적인 선택자 우선순위 규칙을 무시하고 강제로 스타일을 적용 할 수 있다. 오용 시 코드의 유지보수를 어렵게 만들 수 있다. 무분별한 사용은 디버깅과 스타일 관리를 복잡하게 할 수 있으므로 신중하게 사용해야하고 최소한으로 사용해야 한다. 

**우선순위** 
!important(나쁜습관) > 인라인 스타일 > 아이디 > 클래스,어트리뷰트 > 요소,가상클래스 > 전체선택자
## 14. CSS에서 변수(커스텀 프로퍼티)를 사용하는 이유는 무엇인가요?

```css
💡 CSS 변수는 코드의 유지보수성과 일관성을 향상시키며, 
동시에 동적인 스타일 조작이 가능한 강력한 도구로서의 역할을 수행
```

- **스타일 일관성과 유지보수성 향상**

한곳에서 스타일을 변수로 색상, 여백, 폰트 크기 등의 스타일 값을 효과적으로 관리할 수 있어 코드의 유지보수성을 향상시키며 디자인 변경이 필요할 때 효율적으로 대응할 수 있다. 또한 디자인의 일관성을 유지하는데 도움이 됨

- **동적인 스타일 조작 가능**

JavaScript를 통해 CSS 변수 값을 동적으로 변경할 수 있다. 사용자 상호작용에 따라 스타일을 동적으로 조작하거나, 테마 전환 등 다양한 동적 스타일링을 가능하게 한다. 이는 웹 애플리케이션의 인터랙티브한 요소를 개발하는 데 도움이 된다.

- **코드의 간결성 및 가독성 상승**

CSS 변수를 활용하면 코드가 더 간결하고 가독성이 좋아지며, 긴 속성 값을 간략하게 표현할 수 있다.

`nav p { 16px ;}` 보다 `nav p {--font-regular;}` 가 더 기억하기 쉬우며 가독성이 좋다

### 사용법

- **변수 선언**
**`:root`** 또는 요소 안에서 선언될 수 있습니다. **`:root`**는 문서의 최상위 요소를 가리키며, 전역 변수를 선언할 때 주로 사용된다.

```css
// 루트 선언 예시
:root {
  --primary-color: #3498db;
  --secondary-color: #e74c3c;
}
// 일반 요소 선언 예시
.container {
  --main-color: #3498db;
}
```

⇒ CSS 변수는 선언된 요소 내에서만 유효하며 상속되지 않는다고 함.

- **변수 사용**
선언된 변수는 **`var()`** 함수를 사용하여 적용한다. ex. `color: var(--text-color, #333);`
- **자바스크립트로 동적변경**

```jsx
document.documentElement.style.setProperty('--primary-color', '#FF5733');
```

- **미디어쿼리**
미디어 쿼리 내에서 변수를 사용하여 다양한 디바이스에 대응할 수 있다.
## 15. 쌓임 맥락(Stacking Context)이란?
사용자 기준에서 뷰포트 혹은 웹페이지를 바라보고 있을 때 가상의 Z축을 사용한 HTML 요소의 3차원 개념화이다. 간단히 설명하자면, `z-index`를 묶어서 생각하는 범위라고 할 수 있음.

개념 자체는 복잡하지 않지만 쌓임 맥락이 만들어지는 조건은 굉장히 복잡함

**조건**

- 문서의 루트 요소(`<html>`)
- `position`이 `absolute`이거나 `relative`이고, `z-index`가 `auto`가 아닌 경우
- `position`이 `fixed`이거나 `sticky`인 경우
- 플렉스박스(우리가 다음 챕터에서 배울 개념)나 그리드(우리가 다음 다음 챕터에서 배울 내용)의 자식 중 `z-index`가 `auto`가 아닌 경우
- `opacity`가 1보다 작은 요소

…
이 밖에도 더 있으니 mdn 참고! ⇒ [MDN_쌓임맥락](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context)

사실 이런 조건들은 웹 브라우저를 만드는 사람들이 꼼꼼하게 챙기면 되고, 프론트를 배우는 우리는 좀 더 실용적으로 접근하면 된다고 한다. 의도와 다르게 내가 원하는 대로 `z-index`가 동작하지 않거나, `z-index` 값이 너무 많아지고 복잡해져서 코드가 헷갈릴 때 사용한다.

**장점**
쌓임 맥락은 형제 쌓임 맥락과 완전히 분리된다. 쌓임을 처리할 땐 자손 요소만 고려한다.

⇒쌓임 맥락만 분명하다면 바깥은 신경 쓰지 않고 코드를 쉽게 쓸 수 있다
ex. 내비게이션 같은 걸 만들 때도 `z-index` 숫자를 무한정 크게 하지 않아도 깔끔하게 값을 쓸 수 있음.
=======

## 2. display 속성에 대해 설명해주세요.

## 3. box model이란?

## 4. `box-sizing`에 대해 설명해주세요.

## 5. 마진 상쇄(margin Collapsing)가 왜 일어나는지, 해결방법?

## 6. reset.css/normalize.css에 대해 설명해주세요.

## 7. sass, css module, css in js 차이점

## 8. 이미지를 img src 태그로 만드는 것과 요소의 background로 만들었을 때의 차이점

## 9. `visibility: hidden`과 `display: none`의 차이점

## 10. 반응형 웹의 3요소

## 11. 미디어 쿼리의 동작 방식과 좋은 예시를 들어주세요.

## 12. CSS에서 사용되는 단위들에 대해 설명해주세요.

## 13. 선택자의 우선순위에 대해 설명해주세요.

## 14. CSS에서 변수(커스텀 프로퍼티)를 사용하는 이유는 무엇인가요?

## 15. 쌓임 맥락(Stacking Context)이란?
>>>>>>> main
