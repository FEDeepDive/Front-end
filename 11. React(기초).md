## 1. React의 장점, 사용 이유

- **널리 쓰임 ⇒ 크고 활성화된 커뮤니티 & 다양한 툴**
  - 다른 라이브러리, 도구들이 많고 꾸준히 업데이트 됨 (ex. 상태관리 라이브러리, 디버깅 툴)
  - 문제를 마주했을 때 해결 방법을 빠르게 찾을 수 있음
  - 기술, 이슈에 대한 토론이 활발하게 일어남
  - 많은 사람들이 관심을 가지기 때문에 React 관련 소식을 빠르게 접할 수 있음
- **JSX ⇒ 가독성, 개발 생산성, 유지보수 용이, 유연성 …**
  - HTML 파일 수정이 필요 없음
  - 컴포넌트 내에서 HTML-like 마크업을 사용 가능
  - 요소를 다루거나 이벤트/데이터 바인딩하기가 쉽고 유연하여 편함
- **가상 DOM ⇒ 빠르고 편한 DOM 조작 & DOM 성능 최적화**
  - DOM 변경은 무겁고 비용이 많이 듬 ⇒ DOM을 가상화해 DOM 조작 비용과 속도를 줄임
  - 변경이 있는 요소만 리렌더링

## 2. JSX

### **등장 배경**

- 기존에는 HTML이 UI, JS가 로직을 담당했음
- 웹이 interactive하게 변하면서, 로직이 점점 UI를 결정하게 됨
- ⇒ **렌더링 로직과 마크업을 같은 곳에 둬서**, 수정할 때마다 **동기화 상태를 유지**하게 하자!

### **개념**

- JavaScript를 확장한 문법으로, UI 마크업와 렌더링 로직을 함께 다룰 수 있게 함
- 보통 React에서 쓰이지만, React와 독립적인 문법 구문임([참고](https://ko.legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-a-jsx-transform))

### **동작 원리**

- 브라우저는 JSX를 이해하지 못하므로 트랜스파일이 필요함
- ⇒ 컴파일 시 JSX 요소는 JavaScript 객체로 변환되고, 프로퍼티는 객체의 키가 됨

  ```jsx
  const element = <h1 className='greeting'>Hello, world!</h1>;

  const element = React.createElement(
    'h1',
    { className: 'greeting' },
    'Hello, world!',
  );

  const element = {
    type: 'h1',
    props: {
      className: 'greeting',
      children: 'Hello, world!',
    },
  };
  ```

### **문법**

- **단일 루트 요소 반환**
  - 여러 요소를 반환하려면 하나의 상위 요소로 감싸져 있어야 함
  - React Fragment(`<></>`)로 감쌀 수 있음
  ```
  💡 JSX는 JavaScript 객체로 변환된다. 그러므로 여러 요소를 반환하는 것은 두 개 이상의 객체를 반환하는 것과 같은데, 이는 불가능하다. 그래서 그 객체들을 하나의 태그로 감싸야만 반환할 수 있는 것이다.
  ```
- **태그는 항상 닫기**
  ```html
  <!-- wrong (correct in HTML) -->
  <img src="..." alt="..." />
  <li> item

  <!-- correct -->
  <img src="..." alt="..." />
  <li>item</li>
  ```
- **프로퍼티 이름 제한**
  - JavaScript 예약어 사용 불가 (ex. `class`)
  - CamelCase 사용 (ex. `stroke-width` 대신 `strokeWidth`)
  - 예외: `aria-*`, `data-*`는 대시를 사용하여 작성함
  ```
  💡 JSX 프로퍼티가 객체의 키로 변환되기 때문에 대시를 사용하지 못한다.
  ```
- **중괄호(`{}`)를 사용해 변수, 함수, 객체 사용 가능**

## 3. props/state

# props/state

### Props

- **개념**
  - 커스텀 컴포넌트의 JSX attribute와 자식을 포함한 단일 객체
  - properties 라는 뜻
  - Props를 통해 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 수 있음
  - Props는 읽기 전용! 수정해선 안 됨

### **Props drilling**

- **개념**
  - 특정 컴포넌트로 Props를 전달하기 위해 해당 props를 필요로 하지 않는 컴포넌트에까지 props를 전달하게 되는 현상
  - Props가 마치 땅을 파고 내려가듯이 내려가서 drilling이라고 함
- **문제점**
  - 불필요한 Props 전달이 생김
  - 변경 사항이 생기면 Props를 전달하고 있는 모든 컴포넌트를 수정해야 함
  - 컴포넌트 간 의존성이 높아짐
- **해결 방안**
  - 필요한 Props을 전역으로 관리 ⇒ `Context API`나 상태 관리 라이브러리를 사용해 컴포넌트 트리 전체에 데이터를 제공할 수 있음
  - ReactNode를 전달하려는 경우 `children` props 사용 ⇒ 중간 컴포넌트들을 통해 내려가는 것은 동일하지만, 전달하고 있는 props를 중간 컴포넌트들이 몰라도 됨

### State

- **개념**
  - component-specific memory
  - 컴포넌트가 어떤 데이터를 기억할 수 있도록 데이터를 저장하는 지역 변수
  - 상태 변수에 데이터를 저장하고 setter 함수로 상태를 업데이트함
- **특징**
  - Props와 달리 **private** ⇒ 외부에서 접근 불가(local)
  - 상태는 컴포넌트마다 독립적임(isolated)
  - `setState`로 상태를 업데이트하면 렌더링이 일어남
- **컴포넌트 생성 방법에 따른 상태 제어 방법**
  - 클래스 컴포넌트: `constructor` 안에서 `this.state={...}`으로 상태 변수 지정 & `this.setState()`로 상태 업데이트
  - 함수 컴포넌트: `useState` 훅 사용

## 4. A 부모 컴포넌트, B/C 자식 컴포넌트가 있을 때:

- ❓ B 컴포넌트와 C 컴포넌트가 상태 공유를 하려면?
  - ✅ A 컴포넌트에서 상태를 관리하고 B, C 컴포넌트에 Props으로 상태를 전달한다.
  - ✅ 공유하려는 상태를 전역으로 관리한다.
- ❓ C 컴포넌트가 다른 곳으로 옮겨졌을 때는 상태를 어떻게 공유하는가?
  - ✅ 공유하던 상태를 전역으로 관리하여, 항상 접근 가능하게 한다.

## 5. Virtual DOM

### 등장 배경

- 실제 DOM 조작의 비효율성
  - 실제 DOM을 직접 조작하면, 리플로우&리페인팅이 빈번하게 일어남 ⇒ 성능 저하
  - 웹 발전에 따라 복잡한 웹 애플리케이션이 등장하며, 이러한 문제점이 극대화됨
- SPA의 등장
  - 새로 렌더링하려면 페이지 전체를 새로 로드해야 함 & 화면 깜빡임 현상 문제
  - ⇒ SPA로 페이지의 콘텐츠를 동적으로 업데이트
  - ⇒ 데이터와 UI 상태를 효율적으로 관리하는 방법이 필요해짐

### 가상 DOM 소개

- **개념**
  - JS 객체로 구현한 **실제 DOM의 모형**
  - 실제 DOM과 동일한 구조를 가지며, 메모리에만 존재
- **장점**
  - 1️⃣가벼움 ⇒ 조작하는 데 부담이 덜 함
  - 2️⃣비교(`diffing`) 알고리즘 최적화 ⇒ 변경 사항을 더 빠르게 감지
  - 3️⃣변경 사항 일괄 처리(`Batch 처리`) ⇒ 리플로우&리페인팅 최소화
    - 가상 DOM의 이전 상태와 새로운 상태를 비교하고, 한 번에 실제 DOM 에 반영
    - 실제 DOM을 직접 조작하면, 변경이 있는 순간마다 렌더링 됨

### 가상 DOM은 만능인가? (feat. Svelte)

- 가상 DOM 없이도 렌더링 문제 해결 가능 & 가상 DOM이 제일 빠른 건 X
- React, Vue는 라이브러리/프레임워크 🆚 Svelte는 컴파일러
- React는 브라우저 런타임에서 가상 DOM을 처리함 ⇒ 브라우저에 부담이 됨<br/>🆚 Svelte는 빌드할 때 미리 컴파일해서 브라우저에 줌 ⇒ 브라우저는 띄우기만 하면 됨
- Svelte의 방식이 가상 DOM을 쓰는 것보다 빠름

### React의 `diffing` 알고리즘

- 이전과 새로운 버전의 가상 DOM 트리를 재귀적으로, 최상위 노드부터 내려가며 비교
- **루트 요소 유형이 다른 경우** ⇒ 이전 트리를 버리고 완전히 새로운 트리를 구축
  - 즉 루트 요소 아래 모든 컴포넌트가 언마운트되고, 새로 다시 마운트 됨
- **요소의 속성이 다른 경우** ⇒ 변경된 속성만 갱신
- **`key` 속성이 일치하지 않는 경우** ⇒ 일치하지 않는 요소만 갱신
  - `key`는 불변하고, 예상 가능하며, 고유해야 함
  - `key`는 컬렉션 요소(ex. 리스트) 렌더링 시 갱신이 필요한 요소를 추적함
    ```diff
    // 리스트 맨 앞에 요소를 추가할 때, key의 유무 차이

    <ul>
    -  <li>봉준호</li>
    -  <li>손흥민</li>
    +  <li>BTS</li>    // 봉준호 !== BTS   => 갱신
    +  <li>봉준호</li> // 손흥민 !== 봉준호 => 갱신
    +  <li>손흥민</li> // 손흥민            => 트리에 추가
    </ul>

    <ul>
    +  <li key='bts'>BTS</li>
       <li key='bong'>봉준호</li>
       <li key='sonny'>손흥민</li>
    </ul>
    ```

### React에서 DOM 요소에 직접 접근해선 안 되는 이유

- React의 성능 최적화 방해
  - React는 가상 DOM을 사용해 변경 사항을 일괄 처리하고, 최소한의 DOM 조작만 수행하는데, 이를 반함
- 일관성이 떨어짐
  - 뭐는 가상 DOM, 뭐는 실제 DOM으로 조작하면 일관성이 없음
  - React가 가상 DOM을 재구성할 때 직접 DOM을 수정하면 동기화되지 않을 수 있음
- 보안 문제
  - XSS(Cross Site Scripting): 악성 스크립트를 삽입해 정보를 탈취하거나 사이트를 손상시키는 공격
  - React는 컴포넌트 간 props를 통해 데이터를 전달하므로 악의적인 입력으로부터 비교적 안전함
  - 직접 DOM을 수정하는 건, 이러한 React의 보안 메커니즘을 우회하는 것

### 함께 보면 좋은 내용

- `Shadow DOM`: 웹 컴포넌트의 범위 지정 변수 및 CSS용으로 설계된 브라우저 기술
- `React Fiber`: React 16의 새로운 재조정 엔진, virtual DOM의 증분 렌더링을 활성화

### 참고

- [React 공식 문서 - 재조정 (Reconciliation)](https://ko.legacy.reactjs.org/docs/reconciliation.html)
- [DOM은 뭐고 가상 DOM은 뭔가요? (+ Svelte와 React의 차이)](https://www.youtube.com/watch?v=1ojA5mLWts8)
