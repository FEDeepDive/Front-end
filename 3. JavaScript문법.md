## 1. ES6에 추가된 문법
1. `let`, `const`
2. 템플릿 리터럴
3. 화살표 함수
4. `import`, `export`
5. `class`
6. 구조 분해 할당
7. 기본(default)/나머지(rest) 매개변수, 전개(spread) 구문
8. `map()`, `filter()`, `reduce()`, `forEach()` 등
9. `Promise`
10. `for … of`

## 2. `var`, `const`, `let`의 차이점
|  | var | const | let |
| --- | --- | --- | --- |
| 스코프 | 전역/함수 | 블록 | 블록 |
| 재할당 | 가능 | 불가능 | 가능 |
| 재선언 | 가능 | 불가능 | 불가능 |
| 할당 이전 접근 가능 | 가능 | 불가능 | 불가능 |
| 전역 객체에 프로퍼티 생성 | O | X | X |

## 3. `null`, `undefined`?
`undefined`는 변수에 값이 할당되지 않은 상태를 나타낼 때 사용한다. `var` 또는 `let`을 이용해 변수는 선언했으나 값을 할당하지 않았다면 해당 변수는 자동으로 `undefined`가 할당된다.

`null`은 개발자가 해당 변수에 ‘존재하지 않음’ 또는 ‘비어 있음’을 명시적으로 나타낼 때 사용한다.

## 4. `NaN`?
**N**ot **a** **N**umber의 줄임말로, JS뿐만 아니라 컴퓨터 연산 전반에서 나타나는 개념이며 잘못된 입력을 받았음을 나타내는 기호이다. `NaN`은 그 자신을 포함하여 그 어떤 값과도 같지 않게 취급되며, 비교 연산자의 피연산자로 쓰였을 때 항상 `false`를 반환한다.

JavaScript에서 `NaN`을 결과로 반환하는 연산은 총 5가지가 있다.

### 숫자 변환 실패

예시: `parseInt("숫자 아니지롱")`, `Math.floor(undefined)`

### 허수 결과를 가지는 수학 계산식

예시: `Math.sqrt(-1)`

### 정의할 수 없는 계산식

예시: `0 * Infinity`, `Infinity - Infinity`

### 피연산자가 `NaN`이거나, `NaN`으로 강제 변환되는 표현식 또는 함수

예시: `42 + NaN`, `13 * "Hello"`

### 유효하지 않은 값을 숫자로 표시해야 하는 경우

예시: `new Date("숫자 아니지롱").getTime()`

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.
자바스크립트 엔진이 소스 코드를 해석할 때, statement의 끝으로 예측되는 지점에 세미콜론을 삽입해주는 기능인 ‘자동 세미콜론 삽입(Automatic semicolon insertion)’을 암묵적으로 수행하기 때문에, 사용자가 직접 세미콜론을 작성하지 않아도 된다고 한다. 그러나 자바스크립트 엔진이 프로그래머의 의도대로 코드를 해석하는 것에 실패할 위험이 있기 때문에, 명시적으로 세미콜론을 붙여주는 것을 권장하는 의견이 우세하다.

## 6. `Symbol`에 대해 설명해주세요.
ES6에서 새롭게 추가된 원시 타입으로, 그 값이 고유함이 보장된다. ES5 이전까지의 객체 프로퍼티 키는 문자열만을 사용했으며, 따라서 이미 존재하는 프로퍼티를 덮어쓰게 될 가능성이 있었다. ES6에서 `Symbol`이 추가되며, 객체의 프로퍼티 키를 고유하게 설정하여 충돌을 방지할 수 있게 되었다. 이렇게 생성된 프로퍼티 키는 일반적인 문자열 키와 달리 열거 불가능하다. 즉, `for ... in` 문법으로 접근할 수 없고,`Object.getOwnPropertyName()`으로 반환할 수 없으며, `JSON.stringify()`를 통해 객체를 JSON 문자열로 만들 때 무시된다.

JavaScript 엔진 내에 미리 생성되어 상수로 존재하는 내장 심볼들도 존재한다. 대표적으로 `Symbol.iterator`가 있는데, JavaScript 엔진은 `Symbol.iterator`를 키로 가지는 메소드가 정의된 객체를 iterable한 객체로 인식한다. 이러한 객체는 `for … of` 문법을 이용해 반복할 수 있다.

## 7. `==` 과 `===` 의 차이가 무엇인가요?

|  | `==` | `===` |
| --- | --- | --- |
| 명칭 | loose equality(느슨한 동등) | strict equality(엄격한 동등) |
| null vs. undefined | true | false |
| number vs. string | number == Number(string) | false |
| BigInt vs. string | StringToBigInt(x) == BigInt | false |
| boolean vs. number | Number(boolean) == number | false |
| … | … | … |

### 기억할 점
`===`를 사용할 경우, 두 값의 타입이 같지 않다면 항상 false이다. `==`를 사용할 경우, 두 값의 타입을 일치시키는 방향으로 어느 한 값을 변환한 다음 느슨한 동등 비교를 진행한다.

## 8. `for … of` / `for … in` 문
### `for ... in`

객체의 프로퍼티 키 중 문자열로 지정된 모든 열거 가능한 속성에 대해 반복문을 사용하는 문법이다. 해당 객체의 속성을 확인하기 위해 사용할 수 있다.

### `for ... of`

ES6에서 새롭게 등장한 문법으로, `Symbol.iterator`를 키로 가지는 모든 ‘컬렉션(Array, String, Map 등)’에 대해, 모든 원소를 한 번씩 추출하여 변수에 담아 반복문을 수행하는 식으로 동작한다.

## 9. `reduce` 사용법
`reduce(callbackFn, initialValue)`는 배열의 요소를 하나의 값으로 ‘줄이는’ 작업을 수행한다.

### `callbackFn(accumulator, currentValue, currentIndex, array)`

배열의 각 요소에 대해 실행할 함수이며, 콜백 함수의 이전 반환값을 `accumulator` 변수를 통해 접근 가능하다. `initialValue` 값이 존재할 경우 `accumulator`의 첫 값은 `initialValue` 값이고, 존재하지 않을 경우 배열의 첫 요소가 `accumulator` 값이 된다. 배열의 모든 요소에 대해 `callbackFn`이 실행된 후, 그 결과가 하나의 값으로 ‘줄어들어’ 반환된다.

## 10. `splice`, `slice` 차이
### `slice(begin, end)`

`slice()`는 문자열/배열에서 특정 범위만큼 복사한 값들을 담는 **새로운** 문자열/배열을 만들기 위해 사용한다. 새로운 변수를 만들기 때문에, 해당 문자열/배열을 조작한다고 하더라도 원본 문자열/배열에 영향을 미치지 않는다.

### `splice(start, deleteCount, ...items)`

`splice()`는 배열의 기존 요소를 삭제/교체하거나 새 요소를 추가하는 등 **배열의 내용을 변경**한다.

### `split(seperator)`

`split()`은 지정한 구분자를 이용하여 대상 문자열을 여러 개의 문자열로 나눈다.

## 11. 옵셔널 체이닝
옵셔널 체이닝 문법(`?.`)은 ES11(또는 ES2020)에서 처음 등장한 문법으로, 객체의 키에 접근할 때 해당 참조가 유효한지 아닌지 명시하지 않고도 접근할 수 있는 연산자이다. 기존에는 각 키가 존재하는지를 if문으로 일일이 검사한 후 해당 키에 접근할 수 있었다. `?.` 연산자를 사용하면 연산자 왼쪽의 값을 평가한 뒤 `undefined` 또는 `null`인 경우 그대로 평가가 종료되고(단축 평가), 그렇지 않은 경우에는 추가로 평가가 이루어져 결국 원하는 값에 도달할 수 있게 된다.

```java
// object
user: {
  name: 'John',
  age: 42,
  friends: {
    'Jane': {
      name: 'Jane',
      age: 40
    }
  }
}

// before
function getAgeOfFriend(user) {
  if (!user) return null;
  if (!user.friends) return null;
  if (!user.friends!.Jane) return null;

  return user.friends.Jane.age;
}

// after
function getAgeOfFriend(user) {
  return user?.friends?.Jane?.age;
}
```

## 12. NULL 병합 연산자(`??`)는 무엇인가요?
null 병합 연산자는 ES11(ES2020)에서 처음 등장한 문법으로, 여러 변수 중 그 값이 ‘nullish(`null` 혹은 `undefined`)’하지 않은 변수를 찾을 수 있는 연산자이다. `??` 연산자를 사용하면 옵셔널 체이닝과 동일하게 nullish한 변수들에 대해서 ‘단축 평가’가 이루어진다. 논리적 OR(`||`) 연산자가 있지만 논리적 OR 연산자는 [‘falsy’](https://developer.mozilla.org/ko/docs/Glossary/Falsy)한 값 또한 걸러내는 방식으로 동작한다. 따라서 여러 변수 중 ‘falsy’하지만 ‘nullish’하지 않은 값을 고려해야 하는 경우 `??`를 사용할 수 있다.

```jsx
const nullVal = null;
let undefinedVal;
const someNumber = 42;
const someText = 'fourty two';

// valA: 42
const valA = nullVal ?? someNumber;
// valB: 'fourty two'
const valB = undefinedVal ?? someText;

// valC: 42
const valC = 0 || someNumber;
// valD: 0
const valD = 0 ?? someNumber;

// valE: 'fourty two'
const valE = '' || someText;
// valF: ''
const valF = '' ?? someText;

// 주의! ??와 ||은 괄호를 통해 우선순위가 명확히 서로 구분될 때만 함께 사용 가능
// valG: 'fourty two'
const valG = (nullVal || undefinedVal) ?? someText;
```

## 13. 단축평가
논리적 AND(`&&`), 논리적 OR(`||`), null 병합(`??`) 연산자는 모두 단축평가를 실행한다. 표현식은 좌에서 우로 평가되며, 평가 도중 남은 조건들이 표현식의 최종 결과에 영향을 미치지 않는 것이 확실할 경우, 이후의 평가는 생략된다. 즉, 단축 평가를 사용하여 if문을 대체할 수 있다.

| 표현식 | 결과 |
| :-: | :-: |
| true \|\| any | true |
| false \|\| any | any |
| true && any | any |
| false && any | false |
| (null \| undefined) ?? any | any |

## 14. Promise
### 콜백 지옥(Callback Hell)
무언가를 비동기적으로 수행하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 ‘콜백’ 함수를 인자로 반드시 제공해야 한다. 이러한 콜백 함수를 넘겨주는 형태가 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상을 ‘콜백 지옥’이라고 한다.

### Promise
Promise는 ES6에서 처음 도입되었으며, ‘콜백 지옥’을 해결하여 비동기 작업을 더욱 편하게 처리할 수 있도록 도와주는 객체이다. Promise는 ‘대기(Pending)’, ‘이행(Fulfilled)’, ‘실패(Rejected)’의 3가지 상태 중 하나를 가지며, 대기 상태에서 어떠한 값을 가지는 이행 상태가 되거나 값을 가지지 않는 실패 상태로 전이할 수 있다. `.then()` 메소드를 통해 성공했을 경우와 실패했을 경우에 대한 동작을 지정해줄 수 있으며, `.catch()` 메소드를 통해 실패했을 경우에 대한 동작을 지정해줄 수 있다. 각 메소드의 반환값은 알맞게 전이한 상태의 새로운 Promise 객체이며, 각각 반환되는 Promise들을 순차적으로 연결하여 사용할 수 있다. 이러한 형태를 ‘Promise Chaining‘이라고 부르며, 덕분에 추가 작업이 많아져도 코드의 들여쓰기가 증가하지 않고 아래로만 길어진다.

### async/await
async/await은 ES8(ES2017)에서 처음 도입되었으며, Promise 객체를 더욱 편하게 사용할 수 있게 하기 위해 도입된 문법이다. async/await을 사용하면 Promise 기반의 비동기 함수를 마치 동기 함수를 사용하는 듯한 느낌으로 사용할 수 있게 된다.

함수 선언문 앞에 async 키워드를 붙여 async 함수를 만들 수 있다. async 함수는 항상 Promise를 반환하도록 바뀌며, 코드 상 Promise를 반환하지 않더라도 이행 상태의 Promise로 감싸 반환한다. async 함수 내에서는 await 키워드를 사용할 수 있다. async 함수를 호출할 때 함수 이름 앞에 await 키워드를 붙이면 Promise가 처리될 때까지 함수 실행을 지연시킬 수 있으며, 해당 함수 실행이 지연되는 동안 자바스크립트 엔진은 다른 작업을 처리할 수 있다. await을 통해 실행된 함수가 실패하는 경우, 즉 Promise가 실패 상태로 전이하는 경우 에러가 `throw`된 것과 마찬가지로 처리되며, 이러한 경우 `try … catch`문으로 감싸 처리할 수 있다.

### ES5 트랜스파일
async/await은 ES5로 트랜스파일할 경우 제너레이터 함수를 사용하는 형태로 변환된다. async 함수는 제너레이터 함수로, await은 해당 함수의 `yield`문으로 바뀌게 된다. 그러나 Promise의 경우 문법이나 연산자가 아니라 새롭게 등장한 객체이기 때문에 변환되지 않으며, 따라서 polyfill해주기 위한 라이브러리를 설치해주어야 한다.

## 15. 클로저(Closure)란 무엇인가요?
클로저는 함수와 해당 함수가 선언될 당시의 ‘어휘적 환경’의 조합이다. 중첩 함수를 선언할 때, 내부 함수가 외부 함수의 식별자를 사용하는 경우 클로저가 생성된다. 이렇게 생성된 클로저 덕분에, 내부 함수는 외부 함수의 실행이 종료되어도 외부 함수의 식별자를 참조할 수 있게 된다.

### 어휘적 환경(Lexical Environment)
1. **환경 레코드(Environment Record)**
    - 각 식별자를 알맞은 변수나 함수에 연결하기 위해 사용하는 자료구조
2. **외부 어휘적 환경에 대한 참조**
    - 코드의 중첩 구조를 기반으로 스코프 탐색을 하기 위해 사용

### 클로저가 유용한 이유
특정 함수에게만 상태 변경을 허용하여, 상태가 의도치 않게 변경되는 것을 막을 수 있다. 이러한 특성 덕분에, 클로저를 이용하여 객체지향에서의 캡슐화 및 정보 은닉과 동일한 동작을 접근 제한 지정자 없이 달성할 수 있다.

## 16. 구조 분해 할당(Destructuring assignment)이란?

## 17. 전개 구문(Spread syntax)이란?

## 18. 나머지 매개변수(Rest parameters)란?

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

## 20-1. `bind`를 `apply`, `call`로 어떻게 구현할 수 있을까요? 구현해보세요.
