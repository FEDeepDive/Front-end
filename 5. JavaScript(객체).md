## 1. `this`

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

✔ this는 자바스크립트 엔진에 의해 암묵적으로 생성

✔ 코드 어디서든 참조할 수 있다

✔ this가 가리키는 값, 즉 this 바인딩(식별자와 값을 연결하는 과정)은 **함수 호출 방식에 의해 동적으로 결정**된다.

🎈아래 표만 외워도 this가 뭘 가리키는지 정도는 쉽게 알아챌 수 있을것이다.

| 호출 방식 | this 바인딩 | 예시 |
| --- | --- | --- |
| 일반 함수 호출 | 전역 객체 | javascript regularFunction(); |
| 메서드 호출 | 메서드를 호출한 객체 | javascript obj.methodFunction(); |
| 생성자 함수 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 | javascript new ConstructorFunction(); |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | 첫 번째 인수로 전달한 객체 | javascript someFunction.apply(someObject); |
| Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 | 전달한 객체에 바인딩 | javascript someFunction.call(someObject); |

## 2. 클래스

자바스크립트는 프로토타입 기반 언어라서 클래스 기반 언어에 익숙한 프로그래머에겐 익숙하지 않아 다소 혼란스럽거나 어렵게 느낄 수 있었다. 때문에 ES6에서 도입된 클래스는 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 **새로운 객체 생성 메커니즘**을 제시한다.

✔ 클래스 몸체에서 정의할 수 있는 메서드는 **constructor(생성자), 프로토타입 메서드, 정적 메서드** 세가지가 있다.

**constructor**

- constructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드
- constructor 내부의 this는 클래스가 생성한 인스턴스를 가르킨다.
- 클래스 내에 최대 한 개
- 생략 가능 -> 빈 constructor 암묵적 생성
- 내부에서 return 문 반드시 생략

**프로토타입 메서드**

- 클래스 몸체에서 정의한 메서드는 기본적으로 프로토타입 메서드가 된다.
- 클래스는 프로토타입 기반의 객체 생성 메커니즘

**정적 메서드**

- static이라는 키워드를 붙이면 정적 메서드
- 정적 메서드는 클래스에 바인딩된 메서드
- 정적 메서드는 인스턴스로 호출 불가

```jsx
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello!');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello!
```

✔ 클래스는 함수다. 자바스크립트에서 함수는 일급 객체다. 그러므로 클래스도 일급 객체다!

✔ 클래스는 재정의될 수 없다. 재정의를 시도하면 `SyntaxError` 가 발생한다.

✔  클래스는 호이스팅이 발생하지만, 정의 이전에 참조 할 수 없다. ⇒ 클래스 선언문 이전에 일시적 사각지대(TDZ)에 빠지게 되기 때문에 호이스팅이 발생하지 않는 것처럼 동작

💬 클래스 선언문은 소스코드 평가 단계에서 이미 함수 객체를 생성하는데 일반 함수 선언문과 같이 소스코드 순서 상 이전에 호출할 수 없는 이유는?

✅ 클래스 함수 객체는 런타임 이전에 생성이 되는건 맞지만 내부 메서드들은 new 연산자로 생성한 인스턴스가 생성될 때 유효한 것이므로 클래스 선언 이후에 사용가능하다.

✔ 생성자 함수와의 차이점

| 특징 및 차이점 | 생성자 함수 | 클래스 |
| --- | --- | --- |
| 구문 | function Car(make, model) { ... } | class Car { constructor(make, model) { ... } } |
| 호출 방식 | new Car()로 호출 | new Car()로 호출 |
| 프로토타입 기반 | 지원 | 내부적으로 지원 (명시적 설정 불가능) |
| 프로토타입 메서드 추가 | Car.prototype.drive = function() { ... } | 메서드 정의 구문 사용 (자동으로 프로토타입에 추가됨) |
| this 바인딩 | 호출한 객체에 바인딩 | 항상 인스턴스에 바인딩 |
| 상속 | 프로토타입 체인 사용 | extends 키워드 사용 |

**클래스 필드**

클래스 내에서 선언되는 변수를 의미, 클래스의 인스턴스가 아닌 클래스 자체에 속하는 속성이며, 각 인스턴스에서 독립적인 값을 갖지 않고 모든 인스턴스가 공유한다.

- **정적클래스 필드**
    
    정적 클래스 필드는 클래스의 모든 인스턴스에서 공유되며, 클래스 자체에 속한다. 정적 필드는 **`static`** 키워드를 사용하여 정의된다.
    
- **프라이빗 클래스 필드**
프라이빗 클래스 필드는 클래스 내에서만 접근 가능한 필드로, 클래스 외부에서는 직접 접근할 수 없다. 프라이빗 필드는 **`#`** 접두어를 사용하여 정의된다.

```jsx
class Example {
  // 클래스 필드
  static staticField = 'I am a static field'; // 특징: 정적 필드
  instanceField = 'I am an instance field'; // 특징: 인스턴스 필드

  // 프라이빗 필드
  #privateField = 'I am a private field'; // 특징: 프라이빗 필드

  constructor() {
    // 생성자 내부에서 인스턴스 변수 정의
    this.anotherInstanceField = 'I am another instance field';
  }

  // 프라이빗 메서드
  #privateMethod() {
    console.log('I am a private method');
  }

  // 공개 메서드
  publicMethod() {
    console.log('I am a public method');
    
    // 특징: 프라이빗 필드 및 메서드 사용
    console.log(this.#privateField);
    this.#privateMethod();
  }
}

const instance = new Example();

// 특징: 정적 필드는 인스턴스에서 직접 접근 가능
console.log(instance.staticField);

// 특징: 인스턴스 필드는 인스턴스에서 직접 접근 가능
console.log(instance.instanceField);

// 에러 - 특징: 프라이빗 필드에 직접 접근 불가
console.log(instance.#privateField);
// 에러 - 특징: 프라이빗 메서드에 직접 접근 불가
instance.#privateMethod();

// 특징: 프라이빗 필드와 메서드를 간접적으로 접근
instance.publicMethod();
```

**클래스 상속**

- **`extends`** 키워드를 사용하여 부모 클래스 지정해 자식 클래스가 부모 클래스의 특성을 상속받아 사용할 수 있는 특징이 있다.
- 자식 클래스의 생성자에서 **`super()`** 를 사용해 부모 클래스의 생성자를 호출할 수 있다.

→ 코드의 재사용성을 높이고 유지보수를 쉽게해준다.

## 3. 불변성

**원시 데이터 타입의 불변성:**

- 원시 데이터 타입(숫자, 문자열, 불리언, null, undefined, Symbol)은 불변합니다. 이 값들은 변경 불가능하며, 변수에 새로운 값을 할당하면 이전 값이 변경되는 것이 아니라 새로운 메모리에 새로운 값이 할당됩니다.

**불변성을 유지하는 객체나 배열 생성:**

- 객체나 배열을 생성할 때, 불변성을 유지하는 방법으로 **`Object.freeze()`**, **`Object.seal()`**, **`Object.assign()`**, 혹은 불변성 라이브러리들을 사용할 수 있습니다.

| 구분 | 메서드 | 프로퍼티
추가 | 프로퍼티
삭제 | 프로퍼티
값 읽기 | 프로퍼티
값 쓰기 | 프로퍼티 어트
리뷰트 재정의 |
| --- | --- | --- | --- | --- | --- | --- |
| 객체 확장 금지 | Object.preventExtensions | ✕ | ◯ | ◯ | ◯ | ◯ |
| 객체 밀봉 | Object.seal | ✕ | ✕ | ◯ | ◯ | ✕ |
| 객체 동결 | Object.freeze | ✕ | ✕ | ◯ | ✕ | ✕ |

**불변성의 이점:**

- 예측 가능한 코드: 값이 변경되지 않으므로 코드 실행 결과를 예측하기 쉽다.
- 효율성: 변경이 없는 데이터는 캐싱이나 메모이제이션과 같은 최적화 기법에 활용될 수 있다.
- 병렬 처리: 불변 데이터는 여러 스레드나 워커 간에 안전하게 공유될 수 있다.

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

**자바스크립트의 타입**

| 데이터 타입 | 구분 | 설명 |
| --- | --- | --- |
| 숫자(number) | 원시 타입 | 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
| 문자열(string) | 원시 타입 | 문자열 |
| 불리언(boolean) | 원시 타입 | 논리적 참(true)과 거짓(false) |
| undefined | 원시 타입 | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
| null | 원시 타입 | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
| 심벌(symbol) | 원시 타입 | ES6에서 추가된 7번째 타입 |
| 객체(object) | 객체 타입 | 객체, 함수, 배열 등 |

데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유?

✔ 원시 타입의 값, 즉 **원시 값은 변경 불가능한 값immutable value**이다. 이에 비해 **객체(참조) 타입의 값, 즉 객체는 변경 가능한 값mutable value**이다.
✔ 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.
✔ 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달이라 한다.

| 특성 | 원시 타입 | 객체 타입 |
| --- | --- | --- |
| 변경 가능성 | 변경 불가능(immutable) | 변경 가능(mutable) |
| 저장 방식 | 값 자체가 변수에 직접 저장 | 참조 값이 변수에 저장 |
| 할당과 전달 | 값 복사 (값에 의한 전달) | 참조 값 복사 (참조에 의한 전달) |
## 5. 프로토타입

1. 프로토타입이란 무엇인가요?
2. 프로토타입의 장단점은 무엇인가요?
3. 프로토타입을 실제로 사용해볼 일은 잘 없는데 어디에 사용할 수 있을까요?

## 6. (Weak)Map vs. (Weak)Set

## 7. `Date` 객체
