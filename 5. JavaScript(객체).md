## 1. `this`

자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수로 JS엔진에 의해 암묵적으로 생성된다.

**`this` 바인딩**<br/>
식별자와 값을 연결하는 과정으로 **`this`** 라는 식별자와 **`this`** 가 가리키는 객체를 바인딩 하는 것. **`this`** 바인딩은 **함수 호출 방식에 따라 동적으로 결정**

**함수 호출 방식에 따른 `this` 바인딩**

| 함수 호출 방식                                             | this 바인딩                                                           |
| ---------------------------------------------------------- | --------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                             |
| 메서드 호출                                                | 메서드를 호출한 객체                                                  |
| 생성자 함수 호출(new 키워드를 붙여 함수 실행)              | 생성자 함수가 (미래에) 생성할 인스턴스                                |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫번째 인수로 전달한 객체 |
| 화살표 함수                                                | 상위 스코프에 바인딩 된 this에 바인딩                                 |
| addEventListener() 안에서 호출                             | 이벤트가 발생한 DOM 요소                                              |

<br/>

## 2. 클래스

**클래스란?** <br/>

- 클래스란 객체를 생성하기 위한 템플릿으로 객체의 상태나 행동을 정의한다.
- 클래스는 표현식으로 정의할 수 있기 때문에 일급 객체이다.

**[클래스 호이스팅](https://blinders.tistory.com/90)**<br/>
자바스크립트에서 클래스는 함수로 평가된다. 클래스 선언문은 문이기 때문에 **호이스팅이 발생하고** 런타임 이전 소스코드 평가되어 함수 객체와 프로토타입을 생성한다. 이때 생성되는 함수 객체는 **`constructor`** 이다. 호이스팅이 발생하고 소스코드가 평가되어 객체가 생성되지만 클래스는 정의이전에 참조할 수 없다. 객체가 가진 내부 메서드들은 new 연산자를 통해 인스턴스가 생성되었을 때 유효한 것이므로 클래스는 선언 이후에 사용가능하다.

**클래스는 프로토타입의 문법적 설탕인가?**<br/>
JS의 클래스는 프로토타입으로 구현되었기 때문에 클래스는 프로토타입의 문법 설탕이라는 의견이 있으며, 클래스를 사용할 경우 프로토타입을 사용하는 것보다 좀 더 많은 일이 내부적으로 일어나기 때문에 그렇지 않다는 의견 또한 존재한다.

**`new` 키워드란 ?**<br/>

- **`new`** 키워드를 사용해서 클래스를 호출해 객체를 생성할 수 있다.

- **`new`** 키워드를 사용해 생성된 객체는 **`constructor`** 을 호출하게 된다.

<br/>

## 3. 불변성

**불변성이란?**<br/>
새로운 값을 생성하지 않고는 내용을 변경할 수 없는 값

**[불변성의 이점](<https://github.com/FEDeepDive/Front-end/blob/uraflower/5.%20JavaScript(%EA%B0%9D%EC%B2%B4).md>)**

- 예측 가능한 코드 (변하지 않고 일관적인 상태를 가지므로)
- 메모리 효율 증가 (변하지 않는 만큼 메모리를 덜 잡아먹으니까)
- 안전한 병렬 처리 (여러 곳에 동시에 공유되어도 문제 없으니까)

**객체타입의 불변성을 유지하는법**

- **`Object.preventExtensions()`** : 객체의 확장, 프로퍼티 추가를 금지
- `**Object.seal()`** : **`Object.preventExtensions()`\*\* 의 특징을 포함, 이미 존재하는 속성 삭제 금지
- `**Object.freeze()` : `Object.seal()`\*\* 의 특징을 포함, 속성의 값 변경 금지
- 불변성 라이브러리 : **`Immer`**등의 불변성을 관리하기 위한 라이브러리 사용

<br/>

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

자바스크립트의 데이터 타입은 크게 **`원시타입`** 과 **`객체`** 로 구분됨

|             | 원시타입(Primitive Type)                                 | 객체(Object)                                                          |
| ----------- | -------------------------------------------------------- | --------------------------------------------------------------------- |
| 변경 가능성 | 변경 불가능(immutable)                                   | 변경 가능(mutable)                                                    |
| 저장 방식   | 실제 값이 저장                                           | 참조 값이 저장                                                        |
| 복사 방식   | call-by-value(값에 의한 전달)                            | https://uraflower.tistory.com/entry/Call-by-Sharing(공유에 의한 전달) |
| 예시        | number, string, boolean, undefined, null, symbol, bigint | 객체(function, array 포함)                                            |

<br/>

## 5. 프로토타입

프로토타입은 JavaScript에서 객체의 상속 구조를 정의하는 방법. 모든 객체는 `Object.prototype`이라는 프로토타입을 상속받고, 이 프로토타입에 정의된 속성과 메서드를 사용가능하다.

**장단점**

- 상속을 구현하는 간단하고 효율적인 방법이며 동적 프로그래밍을 가능하게 한다.
- 상속 관계가 복잡해지면 코드이해에 어려움이 있을 수 있고, 메모리 누수가 발생할 수 있다.

**실제 사용 예**

- 클래스 기반 프로그래밍 구현
- 객체의 필드와 메서드를 정의
- 동적 프로그래밍을 구현

**프로토타입 체인**

- 프로토타입 체인의 최상위에 위치하는 객체는 언제나 **`Object.prototype`** 이며 프로토타입의 프로토타입 또한 **`Object.prototype`**

<br/>

## 6. (Weak)Map vs. (Weak)Set

ES6 에서 새로 도입된 조금 특별한 객체로 데이터를 효율적으로 저장하고 관리하는데 사용된다.

**`Map`과 `Set`의 특징**

- Map과 Set은 요소 순서에 의미가 없어 인덱스로 요소에 접근할 수 없다.
- 이터러블 하기 때문에 **`for .. of`** 문으로 순회 가능하다.

**`Map`**

- **`Map`** 은 키와 값의 쌍으로 이루어진 컬렉션 객체
- 키 값으로 문자열만 허용하는 객체와 달리 모든 값을 키로 사용할 수 있다.
- 요소를 추가하거나 삭제할 때 **`get`**, **`set`**, **`delete`**, **`clear`** 의 메소드들을 사용한다.
- 객체의 프로퍼티를 자주 변경해야 할 때 유용하다.

**`Set`**

- **`Set`** 은 중복되지 않은 값들의 집합으로 이루어진 자료 구조
- 유일한 갑슬 가지는 목록을 만들거나 중복을 제거할 때 유용하다.

**`WeakMap`과 `WeakSet`**

- 키나 값이 반드시 객체여야하는 **`Map`** 과 **`Set`**

<br/>

## 7. `Date` 객체

표준 빌트인 객체인 Date 는 날짜와 시간을 표현하는데 사용되는 빌트인 객체이자 생성자 함수. **`new`** 연산자 없이 **`Date`** 생성자 함수 호출시 날짜와 시간 정보를 나타내는 문자열을 반환한다.

<br/>
