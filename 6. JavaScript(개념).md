## 1. 얕은 복사와 깊은 복사의 차이

```
💡 **얕은 복사(shallow copy)**는 원본의 참조값을 복사하여 원본과 복사본이 서로 같은 참조값을 공유하는 것을 말합니다. **깊은 복사(deep copy)**는 원본 값을 새로운 참조값에 복사하는 것을 말합니다.
얕은 복사의 경우 원본이나 복사본의 값 변경이 다른 객체에게 영향을 주지만, 깊은 복사는 두 객체가 완전히 독립적이기 때문에 서로 영향을 주지 않습니다.
```

| 얕은 복사(shallow copy) | 깊은 복사(deep copy) |
| --- | --- |
| 원본의 참조값을 복사(=참조값 공유) | 새 참조값에 원본 값을 복사(=원본/복사본이 독립적) |
| 객체의 값 변경이 다른 객체에 영향을 미침 | 객체의 값 변경이 다른 객체에 영향을 미치지 않음 |

- **깊은 복사하는 방법**
  - `JSON.stringfy()`: 객체를 JSON 문자열로 변환 → `JSON.parse()`: 문자열을 새 객체로 변환
  - `structuredClone()`: 깊은 복사를 제하는 HTML DOM API
  ```
  💡`JSON.stringfy()`, `structuredClone()`로는 직렬화할 수 없는 객체(ex. 함수, 심볼, HTML 객체 등)를 deep copy할 수 없음
  ```
  - 객체의 depth를 재귀적으로 반복하며 모든 depth의 값을 복사

## 2. 문(statement)과 표현식(expression)의 차이

```
💡 문은 실행 가능한 최소한의 실행 단위이고, 표현식은 값으로 평가되는 문입니다.
```

- **문(statement)**

  - 프로그램의 최소 실행 단위 (블록과 다름!)
  - 모든 문은 완료값을 가짐
  - 여러 토큰(더 이상 나눌 수 없는 최소 코드 단위)으로 구성됨 ![tokens](./images/js/tokens.png)

  ```jsx
  let a; // 선언문
  a = 3; // 할당문
  if (true) {} // if문
  while (true) {} // while문
  for (let i = 0; i < 10; i++) {} // for문
  ```

- **표현식(expression)**
  - 값으로 평가되는 문 ⇒ 표현식이 평가되면 새로운 값이 생성되거나 기존 값을 참조함
  - 리터럴은 그 자체로 표현식
  ```jsx
  let x = 3 + 1; // 4라는 값으로 평가됨 => 표현식
  x; // 4라는 값으로 평가됨 => 표현식
  let str = ''; // 문자열 리터럴 => 표현식
  ```

```
💡 문 안에 표현식이 속하므로, 모든 표현식은 문이지만 모든 문이 표현식인 건 아님.
```

- **참고**
  - [표현식과 문(expression and statement)](https://codingfarm.tistory.com/361)

## 3. JavaScript Module System

### CJS (CommonJS)

- **도입 배경**
  - 과거 자바스크립트는 모듈 개념이 없어, 모든 스크립트 파일을 전역 스코프로 사용했음
  - Node.js에서 Server-side용 모듈 시스템인 CommonJS를 만듦
- **특징**
  - **동기적 작동**
    - 모듈이 모두 다운로드 되기 전까지 아무것도 못함
    - ⇒ 모듈이 로컬에 있다는 전제이기 때문 (Server-side 타겟)
    - ⇒ 브라우저에서 작동 X (트랜스파일링 & 번들링 필요)
  - 불러온 객체의 복사본을 제공
    - ⇒ 내보낸 쪽에서 값을 변경해도 가져온 쪽에 반영되지 X
  - 동적 구조
    - 코드 중간에서도 `require` 가능
    - 동적인 만큼 최적화가 어려움
- **예시**

  ```jsx
  // importing
  const doSomething = require('./doSomething.js');

  // exporting
  module.exports = function doSomething() {
    // do something
  };
  ```

### AMD (Asynchronous Module Definition)

- **도입 배경**
  - Client-side용 모듈 시스템이 필요
- **특징**
  - 비동기적 불러오기
    - ⇒ 브라우저에서 작동 O (Client-side 타겟)

### UMD (Universal Module Definition)

- **도입 배경**
  - 여러 모듈 로더(CJS, AMD)를 동시에 사용하기 위해 등장 (디자인 패턴에 가까움)

### ESM (ECMAScript Module)

- **개념**
  - ES6 표준 모듈 시스템
  - 참고로 Node.js는 12버전부터 CommonJS와 ESModule을 동시 지원함
- **특징**
  - 모듈은 항상 `strict mode`
  - 비동기적 작동
  - 바인딩을 통한 로드
    - ⇒ `import/export` 모두 같은 값을 참조함
  - **정적 구조**
    - `import/export`가 컴파일 시점에 결정
    - 스크립트 다운로드는 비동기(병렬), 실행은 순차적으로 진행 ⇒ **종속성 트리 생성**
    - ⇒ Tree-shaking (중복되거나 불필요한 코드 부르지 않음)
    - ⇒ 순환 종속성 문제 해결
    - ⇒ 평가가 한 번만 됨 (동일한 import문을 여러 번 써도 한 번만 실행)
  - **동적 모듈 로딩(Dynamic Imports)**
    - `import()` 표현식 사용 ⇒ 동적 매개변수 사용 & 조건부 모듈 불러오기 가능
    - `import()` 표현식은 모듈이 내보내는 모든 객체를 담은 프로미스를 반환
    - ⇒ 코드 중간에서 써도 됨
    ```jsx
    import('/myModule.js').then((module) => {
      // ...
    });
    ```

### 참고

- [What the heck are CJS, AMD, UMD, and ESM in Javascript?](https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm)
- [[JavaScript] CJS, AMD, UMD, ESM](https://beomy.github.io/tech/javascript/cjs-amd-umd-esm/)

## 4. node.js와 그냥 js의 차이

```
💡 **JavaScript**는 프로그래밍 언어이고, **Node.js**는 브라우저 외부에서도 JavaScript가 실행될 수 있도록 지원하는 JavaScript 런타임 환경입니다.
```

| JavaScript | Node.js |
| --- | --- |
| 스크립트 프로그래밍 언어 | 자바스크립트 런타임 환경 |
| 기본적으로 브라우저에서만 실행됨 | 브라우저 외부에서도 JS가 실행될 수 있도록 지원함 |
| 주로 client-side에서 사용됨 | 주로 server-side에서 사용됨 |

- **참고**
  - [Difference between Node.js and JavaScript](https://www.geeksforgeeks.org/difference-between-node-js-and-javascript/)

## 5. iterable, iterator, 유사 배열 객체

### 이터레이션 프로토콜

- `for..of`, `spread` 문법을 적용할 수 있는 객체를 만들기 위한 규칙
- **이터러블 프로토콜**
    - **의미**: 이터러블을 만들기 위한 규칙
    - **내용**: 객체(또는 객체의 프로토타입 체인을 이루는 상위 객체)에 이터레이터 프로토콜을 준수하는 `Symbol.iterator` 메서드를 구현한다
- **이터레이터 프로토콜**
    - **의미**: 순회 가능하게 만들기 위한 규칙
    - **내용**
        - `Symbol.iterator`는 `iterator` 객체를 반환한다
        - `iterator` 객체는 **반드시 `next` 메서드**를 갖는다
        - `iterator` 객체의 메서드는 `iteratorResult` 객체를 반환한다
        - `iteratorResult` 객체는 `done`, `value` 프로퍼티를 갖는다

### 이터레이션 프로토콜을 준수하여 이터러블 생성하기

```jsx
const obj = {
  start: 0,
  end: 3,

  [Symbol.iterator]() {
    let current = this.start;
    let last = this.end;

    // iterator 객체 반환
    return {
	    // iterator 객체는 next 메서드를 가져야 함 (없으면 반복 불가능)
	    // next 메서드는 iteratorResult 객체를 반환
      next() {
        while (current < last) return { done: false, value: current++ };
        return { done: true }; // done이 true면 value 생략 가능
      },
    };
  },
};

// 이터러블이므로 for..of 수행 가능
for (let i of obj) {
  console.log(i); // 0, 1, 2가 차례로 출력됨
}
```

---

### 이터러블

- **정의**
    - 이터러블 프로토콜을 준수한 객체
    - `Symbol.iterator` 메서드를 갖거나 프로토타입 체인을 통해 사용할 수 있는 객체
- **내장 이터러블 종류**
    - `Array`, `TypedArray`, `String`, `Map` , `Set`
    - `arguments` (유사 배열 객체이면서 이터러블임)
    - `NodeList` 등 일부 DOM 컬렉션 유형
- **특징**
    - `for..of`를 적용할 수 있음
    - `전개 구문`을 적용할 수 있음 (객체는 이터러블이 아니지만 예외적으로 가능)

### **유사 배열 객체(array-like)**

- 인덱싱 요소와 `length` 프로퍼티를 갖는 객체
- 배열처럼 보일 뿐, 배열이 아니므로 배열 내장 메서드를 사용할 수 없음
- `Symbol.iterator` 구현 여부에 따라 이터러블일 수도, 아닐 수도 있음 (유사 배열 객체와 이터러블은 별개)
- `Array.from()`을 통해 배열로 만들 수 있음

```jsx
const arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};
```

## 6. generator

```
💡 제너레이터 객체는 제너레이터 함수로 만든 객체로 이터러블이자 이터레이터입니다. 제너레이터 함수를 사용하면 간편하게 이터러블을 생성할 수 있습니다.
```

- **제너레이터 함수**
    - **정의**: 제너레이터 객체를 반환하는 함수
    - **목적**: 이터러블을 직접 구현하는 것보다 간편하게 이터러블을 생성할 수 있음
    - **특징**
        - `function*` 키워드를 사용해 선언
        - `yield` 키워드를 사용해 함수를 중지하거나 재개함
- **제너레이터 객체**
    - 제너레이터 함수로 만든 객체로, `**이터러블`인 동시에 `이터레이터`임**
    - `이터러블`이 가져야 하는 `Symbol.iterator` 메서드를 가짐
    - `이터레이터`가 가져야 하는 `next` 메서드를 가짐
        - `next` 메서드는 `iteratorResult`(`done`, `value` 프로퍼티를 가진 객체)를 반환함
- **코드 예시**

  ```jsx
  // 제너레이터 함수 정의
  function* threeCounter() {
    yield 1; // 첫 번째 호출 시 여기까지 실행됨
    yield 2; // 두 번째 호출 시 여기까지 실행됨
    yield 3; // 세 번째 호출 시 여기까지 실행됨
    // 네 번째 호출 시 마지막까지 실행됨
  }

  // 제너레이터 객체 생성
  let generatorObject = threeCounter();

  // ✅ 제너레이터 객체는 이터러블이다
  console.log(Symbol.generator in generatorObject); // true

  for (let i of generatorObject) {
    console.log(i); // 1 2 3
  }

  generatorObject = threeCounter();

  console.log(...generatorObject) // 1 2 3

  generatorObject = threeCounter();

  // ✅ 제너레이터 객체는 이터레이터이다
  console.log('next' in generatorObject); // true
  console.log('return' in generatorObject); // true
  console.log('throw' in generatorObject); // true

  console.log(generatorObject.next()); // {value: 1, done: false}
  console.log(generatorObject.next()); // {value: 2, done: false}
  console.log(generatorObject.next()); // {value: 3, done: false}
  console.log(generatorObject.next()); // {value: undefined, done: true}
  ```

## 7. polyfill이란 무엇인가요?

- **개념**
    - (엔진에서 아직 지원하지 않는 최신) JS 기능을 구 표준 코드로 구현한 대체 코드
    - 최신 기능과 폴리필은 동일하게 동작함
- **함께 보면 좋은 내용**
    - 트랜스파일러, 바벨