## 1. 함수 컴포넌트/클래스 컴포넌트 차이점, 장단점
### 클래스 컴포넌트
React가 처음 등장했을 때부터 사용된 컴포넌트 형태. `Component` 클래스를 상속받아 구현할 수 있으며, `render` 메소드를 오버라이딩하여 원하는 JSX를 반환하도록 구현한다. props와 state를 가지고 있으며, `this` 키워드를 통해 `props`에 접근할 수 있고 `state` 변수를 통해 상태에 접근하거나 `setState` 메소드를 통해 상태를 변경할 수 있다.

### 함수 컴포넌트
React 16.8 버전부터 등장한 컴포넌트 형태. React 18.2 버전이 최신 버전인 현재 가장 기본적인 형태로 받아들여지고 있다. `props`를 입력으로 받아 JSX를 반환하는 일반적인 JavaScript 함수이며, hooks를 통해 React의 여러 기능들을 사용할 수 있다.

### 장단…점?
클래스 컴포넌트는 하위 호환성 유지와 에러 경계 컴포넌트를 작성하기 위해 남아있을 뿐, 공식 문서에서도 함수형 컴포넌트를 작성하기를 권장하고 있다. 장단점을 논할 이유가 없다고 생각한다.

## 2. React의 라이프사이클에 대해 설명해주세요.
1. `Mount`: 컴포넌트가 화면에 ‘추가’된 상태
2. `Update`: 상호작용에 대한 응답으로 새로운 `props`나 `state`를 받아 ‘갱신’하는 상태
3. `Unmount`: 컴포넌트가 화면에서 ‘제거’된 상태

## 3. 생명주기 메서드
생명주기 메서드란 `Mount`, `Update`, `Unmount`되는 등, React 컴포넌트의 상태가 변경될 때 실행될 코드가 위치하는 특별한 메서드다.

### `constructor(props)`
컴포넌트가 `Mount`되기 전 호출된다. 주로 `state`를 초기화하거나 이벤트 핸들러를 바인딩하기 위해 사용된다.

### `componentDidMount()`
컴포넌트의 첫번째 렌더링이 완료된 후, 즉 `Mount` 상태일 때 호출된다. 

### `componentDidUpdate(prevProps, prevState, snapshot?)`
컴포넌트의 `props`나 `state`가 바뀌어 리렌더링이 일어났을 때, 즉 `Update` 상태일 때 호출된다.

### `componentWillUnmount()`
컴포넌트가 화면에서 제거되기 전에, 즉 `Unmount` 상태일 때 호출된다.

### `getSnapshotBeforeUpdate(prevProps, prevState)`
React가 DOM을 갱신하기 직전에 호출된다. 이 생명주기 메서드가 반환한 값은 `componentDidUpdate` 메서드의 `snapshot` 파라미터로 전달된다.

---

**React 생명주기 도표**

https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

## 4. 고차 컴포넌트
컴포넌트가 props를 입력으로 받아 UI를 반환하는 함수라면, 고차 컴포넌트는 컴포넌트를 입력으로 받아 새로운 컴포넌트를 반환하는 함수이다. 동일한 로직이 여러 컴포넌트에서 중복되는 경우, 이를 분리해내어 재사용할 수 있도록 하는 일종의 패턴이다.

계층적으로 나누어져 구성된 클라이언트 애플리케이션의 각 계층이 공통적으로 다루어야 하는 관심사를 해결하기 위해서 사용할 수 있다. 중복되는 로직의 재사용성을 높이고, 관심사 분리를 할 수 있다는 장점이 있지만 컴포넌트 계층 구조가 복잡해진다는 단점이 있다.

```jsx
// HOC에는 일반적으로 'with' 접두어가 붙음

// 클래스 컴포넌트 형태
function withConcern(WrappedComponent) {
  return class extends React.Component {
    constructor(props) {
      super(props);
    }
    
    componentDidMount() {
      const { propForThisConcern, ...propsForRender } = this.props;
      console.log('Log from mount');
      console.log(propForThisConcern);
    }
    
    render() {
      const { propForThisConcern, ...propsForRender } = this.props;
      return <WrappedComponent {...propsForRender} />
    }
  }
}

// 함수 컴포넌트 형태
const withConcern = (WrappedComponent) => (props) => {
  const { propForThisConcern, ...propsForRender } = props;
  
  useEffect(() => {
    console.log('Log from first render');
    console.log(propForThisConcern);
  }, []);

  return <WrappedComponent {...propsForRender} />
}
```

---

이해하기 좋았던 블로그 포스트: https://jeonghwan-kim.github.io/2022/05/28/react-high-order-component

## 5. 상태 관리 라이브러리 종류를 아는 대로 말해주세요.
### 클라이언트 상태 관리 라이브러리
Zustand, Jotai, Valtio, XState, Recoil, Redux, MobX

### 서버 상태 관리 라이브러리
Tanstack Query(React Query), SWR

## 6. 클라이언트 상태와 서버 상태의 차이?
### 클라이언트 상태
1. 내가 제어할 수 있는 위치(브라우저 또는 애플리케이션)에 존재함
2. 데이터를 쉽게 조회 및 수정할 수 있음
3. 데이터를 공유하지 않으며, 단일 사용자 환경에서만 유효함

### 서버 상태
1. 내가 제어하거나 소유하지 않는 위치에 존재함
2. 조회하거나 수정하기 위해 비동기 API를 필요로 함
3. 불특정 다수와 공유하며, 내가 모르는 사이에 변경될 수 있음
4. 최신 데이터가 아닐 수 있음

## 7. 에러 바운더리

## 8. Suspense
