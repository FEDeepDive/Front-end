## 1. 얕은 복사와 깊은 복사의 차이

```
💡 **얕은 복사(shallow copy)**는 원본의 참조값을 복사하여 원본과 복사본이 서로 같은 참조값을 공유하는 것을 말합니다. **깊은 복사(deep copy)**는 원본 값을 새로운 참조값에 복사하는 것을 말합니다.
얕은 복사의 경우 원본이나 복사본의 값 변경이 다른 객체에게 영향을 주지만, 깊은 복사는 두 객체가 완전히 독립적이기 때문에 서로 영향을 주지 않습니다.
```

| 얕은 복사(shallow copy)                  | 깊은 복사(deep copy)                              |
| ---------------------------------------- | ------------------------------------------------- |
| 원본의 참조값을 복사(=참조값 공유)       | 새 참조값에 원본 값을 복사(=원본/복사본이 독립적) |
| 객체의 값 변경이 다른 객체에 영향을 미침 | 객체의 값 변경이 다른 객체에 영향을 미치지 않음   |

- **깊은 복사하는 방법**
  - `JSON.stringfy()`: 객체를 JSON 문자열로 변환 → `JSON.parse()`: 문자열을 새 객체로 변환
  - `structuredClone()`: 깊은 복사를 제하는 HTML DOM API
  ```
  💡`JSON.stringfy()`, `structuredClone()`로는 직렬화할 수 없는 객체(ex. 함수, 심볼, HTML 객체 등)를 deep copy할 수 없음
  ```
  - 객체의 depth를 재귀적으로 반복하며 모든 depth의 값을 복사

## 2. 문(statement)과 표현식(expression)의 차이

```
💡 문은 실행 가능한 최소한의 실행 단위이고, 표현식은 값으로 평가되는 문입니다.
```

- **문(statement)**
  - 프로그램의 최소 실행 단위 (블록과 다름!)
  - 모든 문은 완료값을 가짐
  - 여러 토큰(더 이상 나눌 수 없는 최소 코드 단위)으로 구성됨
    ![tokens](./images/js/tokens.png)
  
  ```jsx
  let a; // 선언문
  a = 3; // 할당문
  if (true) {} // if문
  while (true) {} // while문
  for (let i = 0; i < 10; i++) {} // for문
  ```
- **표현식(expression)**
  - 값으로 평가되는 문 ⇒ 표현식이 평가되면 새로운 값이 생성되거나 기존 값을 참조함
  - 리터럴은 그 자체로 표현식
  ```jsx
  let x = 3 + 1; // 4라는 값으로 평가됨 => 표현식
  x; // 4라는 값으로 평가됨 => 표현식
  let str = ""; // 문자열 리터럴 => 표현식
  ```

```
💡 문 안에 표현식이 속하므로, 모든 표현식은 문이지만 모든 문이 표현식인 건 아님.
```

- **참고**
  - [표현식과 문(expression and statement)](https://codingfarm.tistory.com/361)

## 3. JavaScript Module System

### CJS (CommonJS)

- **도입 배경**
  - 과거 자바스크립트는 모듈 개념이 없어, 모든 스크립트 파일을 전역 스코프로 사용했음
  - Node.js에서 Server-side용 모듈 시스템인 CommonJS를 만듦
- **특징**
  - **동기적 작동**
    - 모듈이 모두 다운로드 되기 전까지 아무것도 못함
    - ⇒ 모듈이 로컬에 있다는 전제이기 때문 (Server-side 타겟)
    - ⇒ 브라우저에서 작동 X (트랜스파일링 & 번들링 필요)
  - 불러온 객체의 복사본을 제공
    - ⇒ 내보낸 쪽에서 값을 변경해도 가져온 쪽에 반영되지 X
  - 동적 구조
    - 코드 중간에서도 `require` 가능
    - 동적인 만큼 최적화가 어려움
- **예시**
  ```jsx
  // importing
  const doSomething = require('./doSomething.js');

  // exporting
  module.exports = function doSomething() {
    // do something
  }
  ```

### AMD (Asynchronous Module Definition)

- **도입 배경**
  - Client-side용 모듈 시스템이 필요
- **특징**
  - 비동기적 불러오기
    - ⇒ 브라우저에서 작동 O (Client-side 타겟)

### UMD (Universal Module Definition)

- **도입 배경**
  - 여러 모듈 로더(CJS, AMD)를 동시에 사용하기 위해 등장 (디자인 패턴에 가까움)

### ESM (ECMAScript Module)

- **개념**
  - ES6 표준 모듈 시스템
  - 참고로 Node.js는 12버전부터 CommonJS와 ESModule을 동시 지원함
- **특징**
  - 모듈은 항상 `strict mode`
  - 비동기적 작동
  - 바인딩을 통한 로드
    - ⇒ `import/export` 모두 같은 값을 참조함
  - **정적 구조**
    - `import/export`가 컴파일 시점에 결정
    - 스크립트 다운로드는 비동기(병렬), 실행은 순차적으로 진행 ⇒ **종속성 트리 생성**
    - ⇒ Tree-shaking (중복되거나 불필요한 코드 부르지 않음)
    - ⇒ 순환 종속성 문제 해결
    - ⇒ 평가가 한 번만 됨 (동일한 import문을 여러 번 써도 한 번만 실행)
  - **동적 모듈 로딩(Dynamic Imports)**
    - `import()` 표현식 사용 ⇒ 동적 매개변수 사용 & 조건부 모듈 불러오기 가능
    - `import()` 표현식은 모듈이 내보내는 모든 객체를 담은 프로미스를 반환
    - ⇒ 코드 중간에서 써도 됨
    ```jsx
    import("/myModule.js").then((module) => {
    	// ...
    });
    ```

### 참고

- [What the heck are CJS, AMD, UMD, and ESM in Javascript?](https://dev.to/iggredible/what-the-heck-are-cjs-amd-umd-and-esm-ikm)
- [[JavaScript] CJS, AMD, UMD, ESM](https://beomy.github.io/tech/javascript/cjs-amd-umd-esm/)

## 4. node.js와 그냥 js의 차이

```
💡 **JavaScript**는 프로그래밍 언어이고, **Node.js**는 브라우저 외부에서도 JavaScript가 실행될 수 있도록 지원하는 JavaScript 런타임 환경입니다.
```

| JavaScript                       | Node.js                                          |
| -------------------------------- | ------------------------------------------------ |
| 스크립트 프로그래밍 언어         | 자바스크립트 런타임 환경                         |
| 기본적으로 브라우저에서만 실행됨 | 브라우저 외부에서도 JS가 실행될 수 있도록 지원함 |
| 주로 client-side에서 사용됨      | 주로 server-side에서 사용됨                      |

- **참고**
  - [Difference between Node.js and JavaScript](https://www.geeksforgeeks.org/difference-between-node-js-and-javascript/)

## 5. iterable, iterator, 유사 배열 객체

## 6. generator

## 7. polyfill이란 무엇인가요?
