## 1. `this`

자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수로 JS엔진에 의해 암묵적으로 생성된다.

**`this` 바인딩**<br/>
식별자와 값을 연결하는 과정으로 **`this`** 라는 식별자와 **`this`** 가 가리키는 객체를 바인딩 하는 것. **`this`** 바인딩은 **함수 호출 방식에 따라 동적으로 결정**

**함수 호출 방식에 따른 `this` 바인딩**

| 함수 호출 방식                                             | this 바인딩                                                           |
| ---------------------------------------------------------- | --------------------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                             |
| 메서드 호출                                                | 메서드를 호출한 객체                                                  |
| 생성자 함수 호출(new 키워드를 붙여 함수 실행)              | 생성자 함수가 (미래에) 생성할 인스턴스                                |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫번째 인수로 전달한 객체 |
| 화살표 함수                                                | 상위 스코프에 바인딩 된 this에 바인딩                                 |
| addEventListener() 안에서 호출                             | 이벤트가 발생한 DOM 요소                                              |

<br/>

## 2. 클래스

**클래스란?** <br/>

- 클래스란 객체를 생성하기 위한 템플릿으로 객체의 상태나 행동을 정의한다.
- 클래스는 표현식으로 정의할 수 있기 때문에 일급 객체이다.

**[클래스 호이스팅](https://blinders.tistory.com/90)**<br/>
자바스크립트에서 클래스는 함수로 평가된다. 클래스 선언문은 문이기 때문에 **호이스팅이 발생하고** 런타임 이전 소스코드 평가되어 함수 객체와 프로토타입을 생성한다. 이때 생성되는 함수 객체는 **`constructor`** 이다. 호이스팅이 발생하고 소스코드가 평가되어 객체가 생성되지만 클래스는 정의이전에 참조할 수 없다. 객체가 가진 내부 메서드들은 new 연산자를 통해 인스턴스가 생성되었을 때 유효한 것이므로 클래스는 선언 이후에 사용가능하다.

**클래스는 프로토타입의 문법적 설탕인가?**<br/>
JS의 클래스는 프로토타입으로 구현되었기 때문에 클래스는 프로토타입의 문법 설탕이라는 의견이 있으며, 클래스를 사용할 경우 프로토타입을 사용하는 것보다 좀 더 많은 일이 내부적으로 일어나기 때문에 그렇지 않다는 의견 또한 존재한다.

**`new` 키워드란 ?**<br/>

- **`new`** 키워드를 사용해서 클래스를 호출해 객체를 생성할 수 있다.

- **`new`** 키워드를 사용해 생성된 객체는 **`constructor`** 을 호출하게 된다.

<br/>

## 3. 불변성

**불변성이란?**<br/>
새로운 값을 생성하지 않고는 내용을 변경할 수 없는 값

**[불변성의 이점](<https://github.com/FEDeepDive/Front-end/blob/uraflower/5.%20JavaScript(%EA%B0%9D%EC%B2%B4).md>)**

- 예측 가능한 코드 (변하지 않고 일관적인 상태를 가지므로)
- 메모리 효율 증가 (변하지 않는 만큼 메모리를 덜 잡아먹으니까)
- 안전한 병렬 처리 (여러 곳에 동시에 공유되어도 문제 없으니까)

**객체타입의 불변성을 유지하는법**

- **`Object.preventExtensions()`** : 객체의 확장, 프로퍼티 추가를 금지
- `**Object.seal()`** : **`Object.preventExtensions()`\*\* 의 특징을 포함, 이미 존재하는 속성 삭제 금지
- `**Object.freeze()` : `Object.seal()`\*\* 의 특징을 포함, 속성의 값 변경 금지
- 불변성 라이브러리 : **`Immer`**등의 불변성을 관리하기 위한 라이브러리 사용

<br/>

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

자바스크립트의 데이터 타입은 크게 **`원시타입`** 과 **`객체`** 로 구분됨

|             | 원시타입(Primitive Type)                                 | 객체(Object)                                                          |
| ----------- | -------------------------------------------------------- | --------------------------------------------------------------------- |
| 변경 가능성 | 변경 불가능(immutable)                                   | 변경 가능(mutable)                                                    |
| 저장 방식   | 실제 값이 저장                                           | 참조 값이 저장                                                        |
| 복사 방식   | call-by-value(값에 의한 전달)                            | https://uraflower.tistory.com/entry/Call-by-Sharing(공유에 의한 전달) |
| 예시        | number, string, boolean, undefined, null, symbol, bigint | 객체(function, array 포함)                                            |

<br/>

## 5. 프로토타입

1. 프로토타입이란 무엇인가요?
2. 프로토타입의 장단점은 무엇인가요?
3. 프로토타입을 실제로 사용해볼 일은 잘 없는데 어디에 사용할 수 있을까요?

## 6. (Weak)Map vs. (Weak)Set

## 7. `Date` 객체
