## 1. 프로토콜 - HTTP
## 프로토콜
컴퓨터 네트워크 환경 내 모든 기기가 서로 통신하며 데이터를 주고받기 위해 사전에 협의된 통신 협약/규약을 의미한다.

### HTTP/HTTPS
HTTP(HyperText Transfer Protocol)은 WWW 상에서 정보를 주고받을 수 있는 프로토콜이다. 주로 HTML 문서와 같은 리소스를 주고받는 데에 쓰인다. 클라이언트와 서버는 개별적인 메시지를 교환하며 통신하는데, 클라이언트에 의해 전송되는 메시지를 ‘요청’, ‘요청’에 대해 서버가 전송하는 메시지를 응답이라고 한다. 통신 시 사용하는 기본 포트는 80번 포트다.

HTTPS(HyperText Transfer Protocol Secure)는 HTTP의 암호화된 버전으로, 클라이언트와 서버 간의 모든 통신을 암호화하기 위해 TLS 프로토콜을 사용한다. 과거에는 SSL이라는 프로토콜을 사용했으나 공식적으로 사용이 중단되었으며, TLS의 최신 버전은 1.3이다. HTTPS를 이용하여 클라이언트가 민감한 정보를 서버와 안전하게 주고받을 수 있다. 통신 시 사용하는 기본 포트는 443번 포트다.

### HTTP/1.1,  HTTP/2, HTTP/3
**HTTP/1.1**

HTTP의 첫 번째 표준화 버전이다. HTTP는 원칙적으로 TCP 프로토콜 위에 구현되어있기 때문에, 연결을 수립하기 위해 3-Way Handshake를 수행할 필요가 있다. HTTP/1.1에서는 `Connection`, `Keep-Alive` 헤더를 추가하여 한 번 연결되면 상태를 유지하며 동일한 서버에 계속 요청을 보낼 수 있다. 또한, 송신자의 응답을 기다리지 않고도 요청을 보낼 수 있는 파이프라이닝 등이 추가되었다.

**HTTP/2**

HTTP/1.1에서 도입된 파이프라이닝은 서버가 요청을 받은 순서대로만 처리해야 하기 때문에 HOL(Head Of Line) Blocking 문제가 있다. 먼저 보내진 요청이 오래 걸릴 경우 이후의 요청이 처리를 기다리게 되어 전체적으로 처리 속도가 떨어지게 된다.

HTTP/2에서는 이를 해결하기 위해 하나의 TCP 연결에 여러 리소스를 나누어 보내고 응답도 나누어 받는 멀티플렉싱을 도입하였다. 데이터가 나누어져서 교환되므로, 자체적인 흐름 제어 기능도 추가되었다. 이외에도 서버가 클라이언트의 요청 하나에 여러 응답을 할 수 있는 서버 푸시 기능이나 헤더를 압축해서 보내는 기능 등 여러 가지가 추가되었다.

**HTTP/3**

이전까지의 버전과는 다르게, HTTP/3는 TCP가 아닌 UDP 기반의 QUIC 프로토콜을 사용하여 통신하는 새로운 HTTP 표준이다. HTTP/2에서 멀티플렉싱을 도입하여 HOL 문제를 완화했다고 하더라도, TCP를 사용하는 이상 피할 수 없는 문제이다. 때문에 TCP 대신 UDP를 선택하여 신뢰성 있는 프로토콜을 처음부터 구현한 것이 QUIC이다. HTTP/2보다 발전된 멀티플렉싱이 가능하며, TLS 1.3이 기본적으로 통합되어있기 때문에 확실한 보안 연결을 보장한다.

### Header vs. Payload(Body)
헤더란 어떠한 형식에 따라 저장되거나 전송되는 데이터의 맨 앞에 위치하는 보충 데이터를 의미한다. HTTP 프로토콜의 경우 클라이언트는 서버에게 요청을, 서버는 클라이언트에게 응답을 보내는데, 각각 요청/응답을 위한 헤더와 더불어 본문에 대한 정보를 포함하는 표현 헤더를 함께 전송한다.

**요청 헤더에 흔히 포함되는 데이터**

- `Accept-*`: 허용되는 응답 방식과 선호되는 형식
- `Authorization`: 인증 자격 증명
- `User-Agent`: 사용자 에이전트 정보
- `Cache-Control`: 캐싱을 제어하기 위한 정보

**응답 헤더에 흔히 포함되는 데이터**

- `Server`: 요청을 처리한 서버 소프트웨어의 정보
- `Allow`: 해당 엔드포인트에서 허용된 HTTP 메서드
- `Access-Control-*`: 서로 다른 출처 간 자원 공유를 제어하기 위한 정보

**표현 헤더에 흔히 포함되는 데이터**

- `Content-Type`: 자원의 파일 형식을 나타내기 위한 정보
- `Content-Encoding`: 자원에 적용되는 압축 인코딩 정보
- `Content-Language`: 해당 자원의 대상 청중을 나타내기 위한 정보

페이로드(또는 바디, 본문)는 전송의 근본적인 목적이 되는 데이터의 일부분이며, 실제로 보내고 싶은 데이터를 뜻한다. 

### HTTP METHOD
클라이언트가 서버에 어떠한 요청을 할 때, 주어진 자원에 대해 수행하길 원하는 ‘행동’을 나타낸다. 이 때문에 ‘HTTP 동사’라고 불리기도 한다.

| METHOD | 쓰임새 |
| :-: | --- |
| `GET` | 특정 자원의 표시를 요청한다. 오직 데이터를 받기만 한다. |
| `HEAD` | 응답 본문을 제외하고, GET과 동일한 응답을 요청한다. |
| `POST` | 특정 자원에 엔티티를 제출한다. 종종 서버 상태의 변화를 일으킨다. |
| `PUT` | 특정 자원의 내용을 본문 내용으로 대체하거나, 없을 경우 새로운 리소스를 생성한다. |
| `PATCH` | 특정 자원을 부분적으로 수정한다. |
| `DELETE` | 특정 자원을 삭제한다. |
| `CONNECT` | 특정 자원에 대해 양방향 연결 수립을 요청한다. |
| `OPTIONS` | 서버와 클라이언트가 통신하기 위해 필요한 정보를 요청한다. 서버가 어떤 메서드와 헤더, 본문 형식을 지원하는지 알아볼 수 있다. |
| `TRACE` | 요청이 서버로 전송될 때 거치는 네트워크 경로를 확인한다. |

**GET vs. POST**

GET 메서드는 주로 데이터를 얻어오기 위해 사용한다. 데이터를 생성/수정/삭제하지 않기 때문에 서버의 상태를 변경하지 않는다. 서버의 상태를 변경하지 않는, 즉 읽기 전용으로 사용되는 메서드는 ‘안전’하다고 말한다. POST는 주로 새로운 자원을 생성할 때 사용하기 때문에 서버의 상태를 변경한다. 따라서 POST 메서드는 ‘안전’하지 않다.

**POST, PUT의 차이점?**

PUT의 경우, 주로 자원의 식별자를 미리 알고 있는 상태에서 해당 자원을 수정하기 위해 사용하기 때문에 새로운 자원이 매번 생성되지 않는다. 따라서 여러 번 시도해도 동일한 결과를 받게 되며, 이러한 특징을 일컬어 ‘멱등(idempotent)’하다고 한다. POST는 새로운 자원을 생성하기 위해 사용하기 때문에 여러 번 시도할 경우 그 결과값이 동일하지 않다. 

### HTTP Status Code
HTTP 요청의 결과를 파악할 수 있는 세 자리 숫자이다. 현재 100~500번 대까지 정의되어 있으며, 첫 번째 자리 숫자에 따라 5가지로 분류하여 사용되고 있다.

| 분류 | 의미 |
| :-: | --- |
| 1xx | 정보 응답. 클라이언트가 서버에 보낸 요청이 여전히 처리 중임을 나타낸다. |
| 2xx | 성공 응답. 서버가 클라이언트의 요청을 성공적으로 수신하고 처리했음을 나타낸다. |
| 3xx | 리다이렉션. 클라이언트가 요청한 자원이 일시적/영구적으로 이동되었음을 나타낸다. |
| 4xx | 클라이언트 에러. 클라이언트의 요청이 잘못되어 요청을 수행할 수 없음을 나타낸다. |
| 5xx | 서버 에러. 서버 오류로 인해 요청을 정상적으로 처리할 수 없음을 나타낸다. |

## 2. RESTful API
웹의 장점을 최대한 활용하기 위해 소개된 일종의 제약/패턴인 REST(**RE**presentational **S**tate **T**ransfer) 설계 규칙을 지키며 작성된 API를 의미한다.

### REST의 특징
1. Uniform: 서버가 자원에 대해 접근할 수 있는 인터페이스를 통일된 형태로 제공한다.
2. Stateless: 작업을 위한 상태 정보를 따로 저장하고 관리하지 않아 구현이 단순해진다.
3. Cacheable: 웹에서 사용하는 기존 인프라를 그대로 활용 가능하므로, HTTP의 캐싱 기능을 사용할 수 있다.
4. Self-descriptive: 요청의 형태만으로 해당 요청이 어떤 동작이나 정보를 위한 것인지 알 수 있다.

### RESTful API의 이점
1. 확장성: 클라이언트의 요청 정보를 별도로 저장할 필요가 없기 때문에 효율적인 스케일링이 가능하다.
2. 유연성: 클라이언트-서버 간 분리 적분에 서버 애플리케이션의 플랫폼이나 기술 변경이 클라이언트 애플리케이션에 영향을 주지 않는다.
3. 독립성: 사용되는 기술과 독립적이기 때문에 API 설계에 영향을 주지 않고 다양한 프로그래밍 언어를 바꾸는 등의 변경을 가할 수 있다.

### REST의 구성 요소

| 요소 | 설명 |
| :-: | --- |
| 자원(resource) | 자원의 위치를 나타내는 URI. 자원명은 명사 형태여야 한다. |
| 행위(verb) | 자원에 대한 행위를 나타내는 HTTP Method. 수행하는 행위에 알맞은 메서드를 사용해야 한다. |
| 표현(representation) | 클라이언트가 서버에게 요청한 자원을 응답으로 보내줄 때 표현될 형식과 현재 데이터를 포함하는 내용. |

## 3. 프록시(Proxy)란?

## 4. DNS
