## 1. 프로토콜 - HTTP
## 프로토콜
컴퓨터 네트워크 환경 내 모든 기기가 서로 통신하며 데이터를 주고받기 위해 사전에 협의된 통신 협약/규약을 의미한다.

### HTTP/HTTPS
HTTP(HyperText Transfer Protocol)은 WWW 상에서 정보를 주고받을 수 있는 프로토콜이다. 주로 HTML 문서와 같은 리소스를 주고받는 데에 쓰인다. 클라이언트와 서버는 개별적인 메시지를 교환하며 통신하는데, 클라이언트에 의해 전송되는 메시지를 ‘요청’, ‘요청’에 대해 서버가 전송하는 메시지를 응답이라고 한다. 통신 시 사용하는 기본 포트는 80번 포트다.

HTTPS(HyperText Transfer Protocol Secure)는 HTTP의 암호화된 버전으로, 클라이언트와 서버 간의 모든 통신을 암호화하기 위해 TLS 프로토콜을 사용한다. 과거에는 SSL이라는 프로토콜을 사용했으나 공식적으로 사용이 중단되었으며, TLS의 최신 버전은 1.3이다. HTTPS를 이용하여 클라이언트가 민감한 정보를 서버와 안전하게 주고받을 수 있다. 통신 시 사용하는 기본 포트는 443번 포트다.

### HTTP/1.1,  HTTP/2, HTTP/3
**HTTP/1.1**

HTTP의 첫 번째 표준화 버전이다. HTTP는 원칙적으로 TCP 프로토콜 위에 구현되어있기 때문에, 연결을 수립하기 위해 3-Way Handshake를 수행할 필요가 있다. HTTP/1.1에서는 `Connection`, `Keep-Alive` 헤더를 추가하여 한 번 연결되면 상태를 유지하며 동일한 서버에 계속 요청을 보낼 수 있다. 또한, 송신자의 응답을 기다리지 않고도 요청을 보낼 수 있는 파이프라이닝 등이 추가되었다.

**HTTP/2**

HTTP/1.1에서 도입된 파이프라이닝은 서버가 요청을 받은 순서대로만 처리해야 하기 때문에 HOL(Head Of Line) Blocking 문제가 있다. 먼저 보내진 요청이 오래 걸릴 경우 이후의 요청이 처리를 기다리게 되어 전체적으로 처리 속도가 떨어지게 된다.

HTTP/2에서는 이를 해결하기 위해 하나의 TCP 연결에 여러 리소스를 나누어 보내고 응답도 나누어 받는 멀티플렉싱을 도입하였다. 데이터가 나누어져서 교환되므로, 자체적인 흐름 제어 기능도 추가되었다. 이외에도 서버가 클라이언트의 요청 하나에 여러 응답을 할 수 있는 서버 푸시 기능이나 헤더를 압축해서 보내는 기능 등 여러 가지가 추가되었다.

**HTTP/3**

이전까지의 버전과는 다르게, HTTP/3는 TCP가 아닌 UDP 기반의 QUIC 프로토콜을 사용하여 통신하는 새로운 HTTP 표준이다. HTTP/2에서 멀티플렉싱을 도입하여 HOL 문제를 완화했다고 하더라도, TCP를 사용하는 이상 피할 수 없는 문제이다. 때문에 TCP 대신 UDP를 선택하여 신뢰성 있는 프로토콜을 처음부터 구현한 것이 QUIC이다. HTTP/2보다 발전된 멀티플렉싱이 가능하며, TLS 1.3이 기본적으로 통합되어있기 때문에 확실한 보안 연결을 보장한다.

### Header vs. Payload(Body)
헤더란 어떠한 형식에 따라 저장되거나 전송되는 데이터의 맨 앞에 위치하는 보충 데이터를 의미한다. HTTP 프로토콜의 경우 클라이언트는 서버에게 요청을, 서버는 클라이언트에게 응답을 보내는데, 각각 요청/응답을 위한 헤더와 더불어 본문에 대한 정보를 포함하는 표현 헤더를 함께 전송한다.

**요청 헤더에 흔히 포함되는 데이터**

- `Accept-*`: 허용되는 응답 방식과 선호되는 형식
- `Authorization`: 인증 자격 증명
- `User-Agent`: 사용자 에이전트 정보
- `Cache-Control`: 캐싱을 제어하기 위한 정보

**응답 헤더에 흔히 포함되는 데이터**

- `Server`: 요청을 처리한 서버 소프트웨어의 정보
- `Allow`: 해당 엔드포인트에서 허용된 HTTP 메서드
- `Access-Control-*`: 서로 다른 출처 간 자원 공유를 제어하기 위한 정보

**표현 헤더에 흔히 포함되는 데이터**

- `Content-Type`: 자원의 파일 형식을 나타내기 위한 정보
- `Content-Encoding`: 자원에 적용되는 압축 인코딩 정보
- `Content-Language`: 해당 자원의 대상 청중을 나타내기 위한 정보

페이로드(또는 바디, 본문)는 전송의 근본적인 목적이 되는 데이터의 일부분이며, 실제로 보내고 싶은 데이터를 뜻한다. 

### HTTP METHOD
클라이언트가 서버에 어떠한 요청을 할 때, 주어진 자원에 대해 수행하길 원하는 ‘행동’을 나타낸다. 이 때문에 ‘HTTP 동사’라고 불리기도 한다.

| METHOD | 쓰임새 |
| :-: | --- |
| `GET` | 특정 자원의 표시를 요청한다. 오직 데이터를 받기만 한다. |
| `HEAD` | 응답 본문을 제외하고, GET과 동일한 응답을 요청한다. |
| `POST` | 특정 자원에 엔티티를 제출한다. 종종 서버 상태의 변화를 일으킨다. |
| `PUT` | 특정 자원의 내용을 본문 내용으로 대체하거나, 없을 경우 새로운 리소스를 생성한다. |
| `PATCH` | 특정 자원을 부분적으로 수정한다. |
| `DELETE` | 특정 자원을 삭제한다. |
| `CONNECT` | 특정 자원에 대해 양방향 연결 수립을 요청한다. |
| `OPTIONS` | 서버와 클라이언트가 통신하기 위해 필요한 정보를 요청한다. 서버가 어떤 메서드와 헤더, 본문 형식을 지원하는지 알아볼 수 있다. |
| `TRACE` | 요청이 서버로 전송될 때 거치는 네트워크 경로를 확인한다. |

**GET vs. POST**

GET 메서드는 주로 데이터를 얻어오기 위해 사용한다. 데이터를 생성/수정/삭제하지 않기 때문에 서버의 상태를 변경하지 않는다. 서버의 상태를 변경하지 않는, 즉 읽기 전용으로 사용되는 메서드는 ‘안전’하다고 말한다. POST는 주로 새로운 자원을 생성할 때 사용하기 때문에 서버의 상태를 변경한다. 따라서 POST 메서드는 ‘안전’하지 않다.

**POST, PUT의 차이점?**

PUT의 경우, 주로 자원의 식별자를 미리 알고 있는 상태에서 해당 자원을 수정하기 위해 사용하기 때문에 새로운 자원이 매번 생성되지 않는다. 따라서 여러 번 시도해도 동일한 결과를 받게 되며, 이러한 특징을 일컬어 ‘멱등(idempotent)’하다고 한다. POST는 새로운 자원을 생성하기 위해 사용하기 때문에 여러 번 시도할 경우 그 결과값이 동일하지 않다. 

### HTTP Status Code
HTTP 요청의 결과를 파악할 수 있는 세 자리 숫자이다. 현재 100~500번 대까지 정의되어 있으며, 첫 번째 자리 숫자에 따라 5가지로 분류하여 사용되고 있다.

| 분류 | 의미 |
| :-: | --- |
| 1xx | 정보 응답. 클라이언트가 서버에 보낸 요청이 여전히 처리 중임을 나타낸다. |
| 2xx | 성공 응답. 서버가 클라이언트의 요청을 성공적으로 수신하고 처리했음을 나타낸다. |
| 3xx | 리다이렉션. 클라이언트가 요청한 자원이 일시적/영구적으로 이동되었음을 나타낸다. |
| 4xx | 클라이언트 에러. 클라이언트의 요청이 잘못되어 요청을 수행할 수 없음을 나타낸다. |
| 5xx | 서버 에러. 서버 오류로 인해 요청을 정상적으로 처리할 수 없음을 나타낸다. |

## 2. RESTful API
웹의 장점을 최대한 활용하기 위해 소개된 일종의 제약/패턴인 REST(**RE**presentational **S**tate **T**ransfer) 설계 규칙을 지키며 작성된 API를 의미한다.

### REST의 특징
1. Uniform: 서버가 자원에 대해 접근할 수 있는 인터페이스를 통일된 형태로 제공한다.
2. Stateless: 작업을 위한 상태 정보를 따로 저장하고 관리하지 않아 구현이 단순해진다.
3. Cacheable: 웹에서 사용하는 기존 인프라를 그대로 활용 가능하므로, HTTP의 캐싱 기능을 사용할 수 있다.
4. Self-descriptive: 요청의 형태만으로 해당 요청이 어떤 동작이나 정보를 위한 것인지 알 수 있다.

### RESTful API의 이점
1. 확장성: 클라이언트의 요청 정보를 별도로 저장할 필요가 없기 때문에 효율적인 스케일링이 가능하다.
2. 유연성: 클라이언트-서버 간 분리 적분에 서버 애플리케이션의 플랫폼이나 기술 변경이 클라이언트 애플리케이션에 영향을 주지 않는다.
3. 독립성: 사용되는 기술과 독립적이기 때문에 API 설계에 영향을 주지 않고 다양한 프로그래밍 언어를 바꾸는 등의 변경을 가할 수 있다.

### REST의 구성 요소

| 요소 | 설명 |
| :-: | --- |
| 자원(resource) | 자원의 위치를 나타내는 URI. 자원명은 명사 형태여야 한다. |
| 행위(verb) | 자원에 대한 행위를 나타내는 HTTP Method. 수행하는 행위에 알맞은 메서드를 사용해야 한다. |
| 표현(representation) | 클라이언트가 서버에게 요청한 자원을 응답으로 보내줄 때 표현될 형식과 현재 데이터를 포함하는 내용. |

## 3. 프록시(Proxy)란?
프록시란 자원을 요청하는 클라이언트와 요청에 응답하여 자원을 제공하는 서버 사이에서 중개자 역할을 하는 프로그램이다. 클라이언트 입장에서 프록시는 서버처럼 요청에 대한 응답을 돌려줘야 하며, 서버 입장에서 프록시는 클라이언트처럼 요청을 보내고 응답을 받아야 한다.

### Forward proxy
클라이언트가 서버의 자원에 대한 접근을 요청할 때, 해당 자원이 위치한 서버에 직접 요청하지 않고 포워드 프록시 서버에 요청을 보내게 된다. 포워드 프록시는 요청을 받아, 클라이언트 대신 외부 서버와 통신을 진행하여 얻은 응답을 클라이언트로 전달해준다. 클라이언트는 포워드 프록시를 통해서만 정보를 얻게 되며, 서버 측에서는 포워드 프록시를 통한 접근 기록이 남게 된다.

포워드 프록시는 일반적으로 캐싱 기능을 지원하기 때문에 동일한 요청에 대해 캐싱된 데이터를 전달하여 성능을 높일 수 있으며, 자원에 대한 접근을 제한하거나 접근이 제한된 자원에 접근할 수 있다. 또한 클라이언트에서 포워드 프록시를 거칠 때 TLS를 사용하여 요청을 암호화할 수도 있다.

### Reverse proxy
서버가 클라이언트로부터 자원에 대한 접근을 요청받을 때, 서버가 직접 요청을 받지 않고 리버스 프록시 서버가 요청을 먼저 받게 된다. 리버스 프록시는 요청을 가로채 적절한 서버로 전달한다. 리버스 프록시를 통해서만 서버에 접근할 수 있으며, 클라이언트 측에서는 서버의 정보를 알 수 없다.

포워드 프록시와 마찬가지로 동일한 요청에 대해 캐싱된 데이터를 전달해줄 수 있어 성능을 높일 수 있다. 또한 특정 서버의 과부하를 방지하는 ‘로드 밸런서’의 역할을 수행할 수도 있다.

## 4. DNS
DNS(**D**omain **N**ame **S**ystem)는 사용자가 숫자 형태의 IP 주소 대신 도메인 이름을 통해 서버에 접근할 수 있도록 IP 주소와 도메인 이름 간의 변환을 수행한다.

### 주소창에 URL을 검색했을 때 일어나는 일?
1. DNS 서버에 접근하여 입력받은 URI(또는 URL)의 도메인 이름에 대한 DNS 질의 메시지를 DNS 서버로 보내 IP 주소를 얻는다. 가장 먼저 로컬 DNS 서버에 질의하며, IP 주소 정보가 없을 경우 순차적으로 루트, TLD, Authoritative 순서로 질의한다. 도메인 이름에 대한 IP 주소를 찾을 경우, 로컬 DNS 서버에 해당 정보가 캐싱된다.
    - DNS 질의는 재귀적 또는 반복적으로 일어난다.
    - 질의 요청을 받은 DNS 서버에 원하는 정보가 없을 때…
        - 재귀적 질의: DNS 서버가 직접 다른 서버에 질의하는 방법
        - 반복적 질의: 해당 질의에 응답 가능한 DNS 서버의 목록을 제공하는 방법

| 종류 | 설명 |
| :-: | --- |
| 로컬 DNS 서버 | 일반적으로 자신이 계약한 인터넷 서비스 제공자(Internet Service Provider, ISP)가 관리하는 DNS 서버를 뜻한다. |
| 루트 DNS 서버 | ICANN(국제인터넷주소관리기구)가 직접 관리하는 DNS 서버로, 인터넷 상의 모든 TLD DNS 서버들에 대한 IP 주소를 가지고 있다. |
| TLD(최상위 도메인, Top-Level Domain) DNS 서버 | IANA(인터넷 할당 번호 관리기관)이 관리하는 DNS 서버로, Authoritative DNS 서버에 대한 IP 주소를 가지고 있다. |
| Authoritative DNS 서버 | 도메인과 IP 주소를 매칭한 실제 정보가 저장/변경되는 DNS 서버로, 도메인 업체가 관리하거나 직접 구축한 DNS 서버를 의미한다. |
1. DNS 서버를 통해 얻은 IP 주소에 HTTP/S 요청을 보내 이에 대한 응답을 받는다.
2. 서버로부터 받은 응답을 파싱한 후, [CRP](https://github.com/FEDeepDive/Front-end/blob/hatchling13/9.%20WebBrowser.md#%EC%A4%91%EC%9A%94-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B2%BD%EB%A1%9Ccritical-rendering-path-crp)를 거쳐 화면에 내용을 표시한다.

### URL과 URN을 포함하는 URI
| URL(Uniform Resource Locator) | 인터넷 상에서 자원의 위치를 나타내기 위한 표현. 자원 식별자와 위치, 자원에 접근하기 위한 방법(프로토콜)을 동시에 보여준다. |
| :-: | --- |
| URN(Uniform Resource Name) | 인터넷 상의 자원에 위치/프로토콜/호스트에 독립적인 이름을 부여하기 위한 표현. |
| URI(Uniform Resource Identifier) | 인터넷에 존재하는 자원을 나타내는 유일한 주소로, URL과 URN의 개념을 포함하는 상위 집합. |