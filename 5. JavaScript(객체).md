## 1. `this`

```
💡 `this`는 함수 호출 방식에 따라 결정됩니다.
1️⃣일반 함수에서는 전역 객체, 2️⃣메서드에서는 메서드의 주인인 객체, 3️⃣생성자에서는 생성된 인스턴스, 4️⃣이벤트리스너에서는 `event.currentTarget`을 의미합니다.
```

- **함수 호출에 따라 결정되는 `this`**
  - JS에서 `this`는 함수 선언 시 정적으로 결정되는 게 아니라, **함수 호출 시 호출 상황에 따라 동적으로 결정됨**
- **함수 호출에 따른 바인딩 객체**
  - 1️⃣일반 함수 안에서 `this` ⇒ 전역 객체 (2️⃣에 근거)
    - 콜백 함수에서 `this` ⇒ 전역 객체
    - 함수 내부 함수에서 `this` ⇒ 전역 객체
  - 2️⃣메서드 안에서 `this` ⇒ 메서드 주인 객체
  - 3️⃣생성자 안에서 `this` ⇒ 생성한 인스턴스
  - 4️⃣`addEventListener()` 안에서 `this` ⇒ 이벤트를 발사한 요소 `event.currentTarget`
  - 🚨화살표 함수는 상위 요소의 `this`를 물려받음

## 2. 클래스

- **개념**
  - 객체(인스턴스)를 생성하기 위한 템플릿
  - ES6
- **특징**

  - 선언 전 사용 불가
    - 호이스팅이 안된다는 주장 vs. 호이스팅은 되는데 TDZ 제한이 있다는 주장(`let`처럼)
  - 접근 제한 기능(`#`: private)
  - 생성자(`constructor`)를 가짐
  - `extends`를 사용해 상속 가능
    - `super`를 사용해 부모 클래스의 메서드 호출 가능
  - `static`을 사용해 인스턴스화 없이 필드, 메서드 등을 사용 가능

- **번외) Prototype 상속**

  - 프로토타입을 이용해 상속 구현 가능
    - 현재 스코프에 프로퍼티가 없으면 원형 객체(프로토타입)에서 해당 프로퍼티를 찾음
    - ⇒ 이 성질을 이용해 클래스 기반 언어의 상속과 비슷한 효과를 냄
  - Prototype으로 상속 구현 시 다소 복잡함 ⇒ (ES6) Class로 간단하게 구현 가능

- **번외) `new`의 동작 방식**

  - `new` 연산자를 사용해 객체(인스턴스) 생성 가능

    ```jsx
    function User(name) {
      this.name = name;
    }

    let user = new User('Finn'); // 'new'를 붙여 함수 실행 => 생성자 함수라고 함
    ```

    ```jsx
    class User {
      this.name = name;
    }

    let user = new User("Finn"); // 'new'를 붙일 시 클래스의 constructor가 실행됨
    ```

## 3. 불변성

- **불변성이란?**

  - 값이 변경되지 않는 특성

- **원시 타입 vs. 객체**

  |  | 원시 타입(primitive) | 객체(Object) |
  | --- | --- | --- |
  | 특징 | 불변성(immutable) | 가변성(mutable) |
  | 해석 | 원시 타입의 값은 메모리에 그대로 남아있으며 절대 변형되지 않음 | 객체 내부 값 변경이 가능함. 변경 시, 객체를 참조하고 있는 다른 값들도 변경됨 |

  - 자세한 내용: [자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?](<./5.%20JavaScript(객체).md#4-자바스크립트-자료형-중에-객체와-다른-타입-간의-차이가-있을까>)

- **객체에서 불변성을 유지하는 방법**

  - `Object.freeze()`
    ```
    💡 `Object.freeze()`는 직속 객체만 얼림(얕은 동결)
    ⇒ 중첩된 객체의 경우 객체 하나하나를 얼려야 함(깊은 동결)
    ```

- **불변성 유지의 중요성**
  - 예측 가능한 코드 (변하지 않고 일관적인 상태를 가지므로)
  - 메모리 효율 증가 (변하지 않는 만큼 메모리를 덜 잡아먹으니까)
  - 안전한 병렬 처리 (여러 곳에 동시에 공유되어도 문제 없으니까)

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

### 원시 타입과 객체 간 비교

|  | 원시 타입(Primitive Type) | 객체(Object) |
| --- | --- | --- |
| 종류 | number, string, boolean, undefined, null, symbol, bigint | object(array, function 등 포함) |
| 변성 | 불변성(immutable). 즉 값 자체를 변경할 수 없음. | 가변성(mutable). |
| 저장 방식 | 메모리에 실제 값이 저장됨 | 메모리에 참조 값이 저장됨 |
| 비교 방식 | 서로 같은 값을 가지면 동등 | 서로 같은 값을 가져도, 메모리 주소값이 다르면 동등하지 않음 |
| 복사 방식 | 값을 복사 | \*주소값을 복사 |

- \*자바스크립트에서 객체는 call-by-reference가 아니라 [call-by-sharing](https://uraflower.tistory.com/entry/Call-by-Sharing)이다.

```jsx
// 원시 타입
var num = 80;
var copied = num; // 값이 복사되어, 서로 다른 메모리에 저장됨

num = 100; // 🚨 다른 값을 할당하는 건 불변성과 관련이 없음

console.log(num); // 100
console.log(copied); // 80
```

```jsx
// 객체 타입
const user1 = {
  name: 'Bob',
};
user1.age = 20; // 속성 추가/변경/삭제 가능

const user2 = user1; // user1이 참조한 객체의 메모리 주소 값을 복사해 동일한 객체 참조
user2.name = 'Alice';

console.log(user1.name); // Alice
console.log(user2.name); // Alice
```

### 참고

- [JavaScript 원시 값과 객체의 비교](https://velog.io/@najiexx/JavaScript-%EC%9B%90%EC%8B%9C-%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90-2aovlqxf)

## 5. 프로토타입

### 1. 프로토타입 개념

- 프로토타입이란, **자신의 원형(prototype)이 되는 객체**를 의미
- “프로토타입 객체”라고도 함
- **자바스크립트에서 모든 객체는 프로토타입을 가짐**

### 2. 프로토타입 동작 원리

```jsx
function Person() {}
var joon = new Person();
var jisoo = new Person();
```

![prototype-mechanism](./images/JS/prototype-mechanism.png)

- Person 함수는 Person 프로토타입 객체를 `prototype` 프로퍼티로 참조한다.
- Person 프로토타입 객체는 Person 함수를 `constructor` 프로퍼티로 참조한다.
- **Person 프로토타입 객체는 Person 함수로 생성된 모든 객체(=인스턴스)의 원형이 되는 객체**이다.
- Person 함수로 생성된 모든 객체(=인스턴스)는 프로토타입(원형)인 Person 프로토타입 객체를 `__proto__` 프로퍼티로 참조한다.

### 3. 프로토타입 관련 프로퍼티

|  | **[[Prototype]]** | **`__proto__`** | **`prototype`** | **`constructor`** |
| :-: | --- | --- | --- | --- |
| **소유 객체** | 모든 객체 | 모든 객체 | 함수 객체 (생성자가 될 수 있는) | 모든 프로토타입 객체 (함수객체.prototype) |
| **값** | 자신의 프로토타입 객체 | 자신의 프로토타입 객체 | 인스턴스의 프로토타입 객체 | 자신을 생성한 함수 객체 (=생성자) |
| **비교 예시** |  | `나.__proto__` === `생성자함수.prototype` | `나.prototype` === `인스턴스.__proto__` | `나.constructor` === `생성자함수` |
|  |  |  |  |  |
| **부연 설명** | JS 엔진의 구현 알고리즘을 설명하기 위해 있는 내부 슬롯 | `[[Prototype]]`에 접근하기 위한 접근자 프로퍼티 (`[[Prototype]]` getter, setter) |  |  |
| **주의사항** | 은닉 속성임. 접근 시 오류. ⇒ `__proto__`로 간접적 접근 O | ES6에서 표준화됨 but 사용이 권장되지 않음 | 생성자가 될 수 없는 non-constructor(화살표 함수, ES6 메서드 축약 표현으로 정의한 메서드)는 `prototype` 프로퍼티를 갖지 않음 |  |

```jsx
function Person(name) {
  this.name = name;
}
const me = new Person('Lee');

// ✅ __proto__와 prototype 프로퍼티
console.dir(me.__proto__); // Person 프로토타입 객체
console.dir(Person.prototype); // Person 프로토타입 객체
console.log(me.__proto__ === Person.prototype); // true

// ✅ constructor 프로퍼티
console.dir(Person.constructor); // Function

// Person 프로토타입 객체를 생성한 생성자 함수는 Person
console.dir(me.__proto__.constructor); // Person
console.dir(Person.prototype.constructor); // Person

// me는 constructor 프로퍼티를 갖지 않음 => 자신의 프로토타입에서 constructor를 찾음 (체인)
console.dir(me.constructor); // Person

// 🚨 콘솔에 찍었을 때 Object 나온다고해서 다 같은 Object가 아님 주의 !
console.dir(me.__proto__); // "Object" 라고 찍히지만, Person 프로토타입 객체를 의미함
console.dir(me.__proto__ === Object); // 그러므로 당연히 false
console.dir(Object); // Object 생성자 함수가 찍힘
```

### 4. 프로토타입 체인

```
💡 특정 객체의 프로퍼티/메서드를 **읽으려고 할 때**, 객체가 해당 프로퍼티/메서드를 직접 가지고 있지 않으면, 프로토타입 객체의 프로퍼티/메서드를 **차례대로** 검색하는 성질
```

```
🚨 없는 프로퍼티/메서드를 쓰려고 할 때에는 동적으로 할당되기 때문에 프로토타입 체인이 동작하지 않는다.
```

- 객체가 특정 프로퍼티/메서드를 **직접** 가지고 있는가?
- 없으면, **프로토타입 객체가** 해당 프로퍼티/메서드를 가지고 있는가?
- 없으면, **프로토타입 객체의 프로토타입 객체가** 해당 프로퍼티/메서드를 가지고 있는가? (반복)

```
💡 프로토타입 체인의 끝은 `Object.prototype` 객체이다.
```

### 5. 프로토타입 상속

```
💡 객체의 프로토타입 객체를 직접 할당하여 생성자 없이 상속을 구현하는 방법
```

```jsx
const parent = { name: 'Kim', age: 50 };
const child = {};

child.__proto__ = parent; // 프로토타입 객체로 부모를 할당
console.log(child); // {}
console.log(child.name); // Kim (프로토타입 체인 작동 => parent.name)

child.age = 20;
console.log(child); // { age: 20 }
console.log(child.age); // 20
```

### 6. 프로토타입 객체의 확장 및 활용

객체, 배열, 문자열 등 내장 함수를 추가해주지 않았는데도 사용할 수 있는 이유는 객체의 프로토타입 객체에 이미 메서드가 추가되어 있기 때문이다. (ex. `Array.prototype.sort()`)

아래 예제처럼 프로토타입 객체에 직접 메서드를 추가하여 확장할 수 있다.

```jsx
function Person(name, age) {
  this.name = name;
}

const personA = new Person('Kim');
const personB = new Person('Lee');

Person.prototype.sayHi = function () {
  console.log(`Hi. I am ${this.name}.`);
};

personA.sayHi(); // Hi. I am Kim.
personB.sayHi(); // Hi. I am Lee.
```

### 번외) 프로토타입 기반 언어 vs. 클래스 기반 언어

- **프로토타입 기반 언어**
  - 구성원을 유사성에 따라 나눔 ⇒ 구성원들 중 가장 전형적인, 즉 같은 특성을 가장 많이 공유하는 구성원을 원형(Prototype)으로 둠
  - 같은 구성원이어도 상황문맥(context)에 따라 구성원이 갖는 의미, 쓰임새가 달라질 수 O
  - Javascript, Lua 등
- **클래스 기반 언어**
  - 구성원을 분류(Classification)함 ⇒ 같은 클래스에 속하면 같은 특성을 가짐
  - Java, C++, C#, Python, PHP, Ruby 등

### 참고

- [JavaScript:프로토타입(prototype) 이해](https://www.nextree.co.kr/p7323/)
- [poiemaweb JS Prototype](https://poiemaweb.com/js-prototype)
- [Must Know About Frontend - Prototype](https://github.com/baeharam/Must-Know-About-Frontend/blob/main/Notes/javascript/prototype.md)

## 6. (Weak)Map vs. (Weak)Set

```
💡 Map은 객체와 비슷한 키-값 컬렉션입니다. 객체와 달리 키의 타입을 구분하며 모든 타입을 키로 사용할 수 있습니다. Set은 중복이 없는 값 컬렉션입니다.
```

```
💡 WeakMap은 객체 또는 등록되지 않은 심볼만 키로 사용할 수 있고, WeakSet은 객체만 값으로 사용할 수 있습니다.
**WeakMap, WeakSet이 Map, Set과 다른 점은 객체를 약하게 참조한다는 것**입니다. 어떤 객체가 Map, Set에 포함되어 있으면 객체는 삭제되지 못합니다. 반면 객체가 WeakMap 또는 WeakSet에만 포함되어 있다면 객체는 가비지 컬렉션의 대상이 됩니다. 이러한 특징 때문에 WeakMap, WeakSet에서는 전체 요소를 대상으로 한 메서드나 프로퍼티를 사용할 수 없습니다.
```

### Map

- **개념**
  - 타입을 구분하는 키-값 컬렉션
- **특징**
  - 키의 타입이 구분됨 (🆚객체는 모든 키를 String으로 변환함)
  - 모든 타입이 키가 될 수 있음 (🆚객체는 객체 키를 쓰면 `"[object Object]"`가 됨)
    - 원시 값, 객체, `null`, `undefined`, `NaN`까지도 키로 사용할 수 있음
  - 삽입 순서가 보장됨 (🆚객체도 삽입 순서를 기억하지만(ES6), 항상 순서가 보장되는 건 아님)
  - 이터러블 (🆚객체는 아님) ⇒ `for..of` 사용 가능, `forEach` 내장 메서드 지원
  - 키 중복 불가
- **사용 방법**

  ```jsx
  const map = new Map();
  const person = { name: 'Kim' };

  map.set(person, 20); // object 타입 키
  map.set('1', 'string 1'); // string 타입 키
  map.set(1, 'number 1'); // number 타입 키
  map.set(null, 'null'); // null 타입 키

  console.log(map.get('1')); // 'string 1'
  console.log(map.get(1)); // 'number 1'

  map.forEach((value, key, map) => {
    console.log(key, value); // 삽입 순서대로 출력
  });
  ```

### Set

- **개념**
  - 중복이 없는 값 컬렉션
- **특징**
  - 값 중복 불가
  - 이터러블 ⇒ `for..of` 사용 가능, `forEach` 내장 메서드 지원

### WeakMap

- **개념**
  - **객체-값** 또는 **심볼-값 컬렉션**
  - 객체를 "약하게" 잡아두는 Map
  - 주로 부수적인 데이터 저장 시 활용
- **특징 (Map과 차이점)**
  - **객체를 약하게 참조** ⇒ 객체가 위크맵의 키 외에 누구에게도 참조되지 않으면 삭제됨 (🆚맵의 키로 사용한 객체는 아무도 참조하지 않아도 맵의 키로 포함된 동안 삭제되지 않음)
  - **객체 또는 등록되지 않은 심볼만 키가 될 수 있음** (🆚맵은 무슨 타입이든 가능)
  - 열거 불가능 (🆚맵은 가능)
  - 일부 메서드가 제한됨
    - 사용 가능한 메서드: `set()`, `get()`, `delete()`, `has()`
    - 약한 참조 유지를 위해 전체 요소에 대한 기능(ex. `size`, 순회)이 제한됨
- **약한 참조 예시**

  ```jsx
  /** 📢사전 지식
   * 객체는 힙 영역에 저장됨
   * 식별자에 객체를 할당한다는 건, 사실 객체의 힙 주소를 저장하는 것임
   *
   * 객체는 아무도 자신을 참조하지 않으면 자동으로 삭제됨
   * 객체 식별자 값이 null이 되어 객체에 도달할 방법이 없어도,
   * 배열의 요소, 맵의 키 등에서 객체를 참조하고 있으면 객체는 삭제되지 않음
   */

  const map = new Map();
  const weakMap = new WeakMap();

  let a = { name: 'a' };
  let b = { name: 'b' };
  map.set(a, 'this is a');
  weakMap.set(b, 'this is b');

  /***********************************************************************/
  a = null;
  // a가 가리키던 객체에 도달할 방법이 없지만
  // 해당 객체가 Map의 키로 사용되고 있기에, 가비지 컬렉션의 대상이 되지 못함❌
  console.log(map); // 키로 객체 {name:'a'}를 가지고 있음

  /***********************************************************************/
  b = null;
  // b가 가리키던 객체에 도달할 방법이 없음
  // 해당 객체가 WeakMap의 키로 사용되고 있지만, 가비지 컬렉션의 대상이 됨⭕
  console.log(weakMap); // 비어 있음 (객체가 당장 삭제되지 않았어도 삭제가 예정됨)
  ```

### WeakSet

- **개념**
  - 중복이 없는 **객체 컬렉션**
  - 객체를 "약하게" 잡아두는 Set
  - 주로 부수적인 데이터 저장 시 활용
- **특징 (Set과 차이점)**
  - **객체를 약하게 참조** ⇒ 객체가 위크셋 외에 누구에게도 참조되지 않으면 삭제됨 (🆚셋에 포함된 객체는 아무도 참조하지 않아도 셋에 포함된 동안 삭제되지 않음)
  - **객체만 키가 될 수 있음** (🆚셋은 무슨 타입이든 가능)
  - 열거 불가능 (🆚셋은 가능)
  - 일부 메서드가 제한됨
    - 사용 가능한 메서드: `add()`, `delete()`, `has()`
    - 약한 참조 유지를 위해 전체 요소에 대한 기능(ex. `size`, 순회)이 제한됨

### 참고

- [맵과 셋](https://ko.javascript.info/map-set)
- [위크맵과 위크셋](https://ko.javascript.info/weakmap-weakset)

## 7. `Date` 객체

- **개념**
  - 날짜/시간 관련 객체
- **주요 사용 방법**
  ```jsx
  // 날짜 저장
  var date1 = new Date('2024-01-31'); // Mon Jan 31 2024 09:00:00 GMT+0900
  var date2 = new Date(2024, 0, 31); // Mon Jan 31 2024 00:00:00 GMT+0900
  var date3 = new Date(1988, 4, 5); // Thu May 05 1988 00:00:00 GMT+0900

  // 주요 메서드
  date1.getDay(); // Mon
  date1.getDate(); // 31
  date1.getYear(); // 124 (getYear 메서드는 '2000년 문제'로 문제가 있으니 사용 X)
  date3.getYear(); // 88 (1900~1999년 사이 연도는 두 자릿수로 출력해줌)
  date1.getFullYear(); // 2024 (getFullYear 메서드가 권장됨)

  // 경과한 시간(ms) 계산
  var start = Date.now(); // 1970년 1월 1일 0시 0분 0초부터 지금까지 경과된 밀리초
  var end = Date.now();
  var time = end - start; // 경과한 시간(ms) 계산 가능
  ```
  - `year`: 네 자리 숫자
  - `month`: `0`(1월)~`11`(12월) 사이 숫자
  - `date`: 일
  - `day`: 요일
