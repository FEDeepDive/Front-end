## 1. 타입스크립트의 장점
### 정적 타입 언어

정적 타입 언어는 변수의 타입이 컴파일 타임에 결정되는 언어로 다음과 같은 장점이 있다.

1. 실행 시간에 변수의 타입을 결정하기 위한 작업을 하지 않아도 되며, 타입에 대한 정보를 미리 제공하기 때문에 더 나은 최적화가 가능해져 실행 시 효율적이다.
2. 컴파일 타임에 타입 관련 에러를 검출할 수 있기 때문에 디버깅이 용이하다.
3. 코드의 구조를 엄격하게 정의할 수 있기 때문에 깔끔하고 읽기 쉬운 코드를 작성할 수 있다.

### TypeScript?
TypeScript는 정적 타입 언어이기 때문에 위에서 언급한 장점들을 가진다. 또한 정적 타입 사용으로 인해 현대적인 IDE에서 지원 가능한 툴링(코드 힌팅, 자동 완성, 리팩토링 지원 등)의 종류가 많아 생산성이 높다는 장점도 있다.

## 2. type/interface 차이
|  | type | interface |
| --- | --- | --- |
| 명칭(번역) | Type alias(타입 별칭) | Interface(인터페이스) |
| 사용 가능 타입 | 어떤 타입이든 가능 | 객체 타입만 가능 |
| 확장하는 법 | & 기호를 사용 | extends 키워드를 사용 |
| 이미 있는 타입에 필드 추가 | 불가능 | 가능(선언 병합) |

공식 문서에서는 ‘타입 별칭이 필요해지기 전까지 인터페이스를 사용하라’고 한다.

Union 타입이나 Intersection 타입을 활용해 두 개 이상의 타입을 조합해야 하는 경우에는 타입 별칭이 더 유용할 수 있고, 타입을 쉽게 확장하거나 병합해야 하는 경우에는 인터페이스가 더 유용할 수 있다.

## 3. enum/object 차이
### `enum`
`enum`은 서로 연관된 상수의 집합으로, 흔히 ‘열거형’으로 번역된다. TypeScript에서 `enum`은 크게 숫자형과 문자열형의 두 가지로 구분된다. 그 자체가 타입으로 사용될 수 있어 별도로 타입 지정을 해줄 필요가 없다. 객체와 비슷하게 `Object.keys`와 `Object.values`를 이용한 순회가 가능하다.

### `object as const`
할당된 값 그 자체를 타입으로 취급하는 것을 리터럴 타입이라고 부르는데, 객체 선언 시 `as const`를 붙여줄 경우 해당 객체의 각 프로퍼티는 선언 시에 사용된 값과 동일한 리터럴 타입을 가지게 된다.

|  | `enum`  | `object as const` |
| --- | --- | --- |
| 사용되지 않는 코드 컴파일 타임에 삭제(Tree-shaking) | 불가능(`const`로 선언 시 가능) | 가능 |
| 컴파일 후 코드 크기 | 비교적 큼 | 비교적 작음 |

## 4. JS의 `any`와 TS의 `unknown`의 차이
### 상위/하위 타입
TypeScript는 타입의 내부 구조에 따라 호환성과 동등성이 결정되는 ‘구조적 타입 시스템(Structural Type System)’을 채택하였다. 구조적 타입 시스템에서는 두 객체가 동일한 프로퍼티를 가지고 있을 경우 두 객체의 타입이 적어도 서로 호환되며, 프로퍼티의 이름과 개수가 같을 경우 두 객체의 타입이 서로 같다고 정의할 수 있다. 이때 B 타입이 처리할 수 있는 모든 작업을 A 타입이 처리할 수 있다면 ‘A 타입은 B 타입의 `하위 타입`’, ‘B 타입은 A 타입의 `상위 타입`’이라고 하며 ‘B 타입은 A 타입을 포함한다’고 이야기한다.

```ts
// SubType의 모든 값은 SuperType의 값이기도 하므로...
// SuperType은 SubType을 포함한다!

type SuperType = { x: boolean; }
type SubType = { x: boolean; y: number; }
```

`any`와 `unknown`은 TypeScript의 모든 타입에 대해 상위 타입이며, 타입 시스템으로 표현 가능한 그 어떤 타입의 값이라도 할당할 수 있다. 이 둘을 묶어 ‘최상위 타입(Top Type)’이라고 부르지만, 둘은 서로 명확히 구분된다.

### `any`
최상위 타입은 모든 타입의 값을 가질 수 있지만, 그렇기 때문에 모든 타입의 값에 대해 공통적으로 적용할 수 있는 연산만이 가능하다. 그러나 `any`는 타입을 검사하지 않는 방식으로 에러를 잠재우기 때문에, 어떠한 연산을 적용하든 에러가 발생하지 않는다. `any` 타입의 값은 `never` 타입 이외의 모든 타입에 할당될 수 있다.

### `unknown`
`unknown`은 `any`의 타입 안전한 버전으로, 타입 시스템에서 표현 가능한 모든 값을 할당할 수 있지만 자기 자신과 `any`를 제외하고는 다른 타입에 바로 할당할 수 없다. 타입을 별도로 지정해주거나 타입 좁히기 등을 통해 구체적인 타입이 정해지고 난 후 비로소 해당 타입에 적용 가능한 연산을 수행할 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/637c457f-6134-4a8f-9161-1d9b4f4e20aa/31e54f9b-f9e0-4d5b-a2dd-f547a042d208/Untitled.png)

(초록색 ✓의 경우, **`strictNullChecks`** 옵션이 꺼져 있는 경우에만 호환됨)

`any`는 타입을 검사하지 않겠다고 컴파일러에게 말하는 것과 같기 때문에, 기존에 JavaScript로 작성된 코드베이스를 TypeScript로 옮기는 과정이 아니라면 `unknown`을 쓰는 것이 더 좋다.

## 5. `never` 타입에 대해 알고 있나요?
`never`는 TypeScript의 모든 타입에 대해 하위 타입이며, 타입 시스템에서 표현 가능한 값이 없다는 것을 의미한다. 흔히 최하위 타입(또는 바닥 타입, Bottom Type)으로 부르며, 타입 시스템을 집합으로 보았을 때 원소가 없는 공집합과 같다고 볼 수 있다.

`never`는 최하위 타입이기 때문에 모든 타입의 변수에 할당할 수 있지만, `never` 타입에는 `never`밖에 할당할 수 없다.

제어 흐름 분석 결과 도달할 수 없는 구문이 있을 경우 `never` 타입을 반환하는 것으로 이를 나타낼 수 있다. 이는 `never`가 표현 가능한 값이 없다는 의미를 가지기 때문에 가능하다.

```ts
function error(message: string): never {
  throw new Error(message);
}

function move(direction: "up" | "down" | "left" | "right") {
  switch (direction) {
    case "up": {
      return [0, 1];
    }
    case "down": {
      return [0, -1];
    }
    case "left": {
      return [-1, 0];
    }
    case "right": {
      return [1, 0];
    }
  }

  return error("Unreachable");
}
```

## 6. 배열과 튜플의 차이
일반적으로 ‘배열’은 같은 메모리 크기를 가지는(즉, 같은 타입의) 요소들의 모음으로, 각 요소가 적어도 하나의 인덱스(또는 키)에 대응되는 자료구조를 뜻한다. 각 요소는 자신을 가리키는 인덱스를 일정한 수학적 공식에 대입하여 얻어낼 수 있는 위치에 저장된다. 해당 인덱스에 접근하여 값을 읽거나 수정할 수 있다.

일반적으로 컴퓨터과학에서 ‘튜플’은 순서가 정해져 있으며 여러 개의 데이터 타입을 가지는 값들의 집합을 나타낸다. 튜플의 값이나 순서는 변경할 수 없으며, 다른 값이나 순서를 가지는 튜플을 원한다면 새로운 튜플을 만들어야 한다. 흔히 ‘레코드 타입’이라는 이름으로도 불리며, 함수형 프로그래밍에서는 흔히 ‘곱 타입(product type)’이라는 이름으로 나타낸다. 관계형 데이터베이스에서는 흔히 ‘행(row)’으로도 나타낸다.

### TypeScript에서 배열과 튜플의 차이
TypeScript에서 배열은 `Array` 타입으로 나타낼 수 있다. `type[]`과 같이 나타낼 수도 있고, 제네릭 타입 파라미터를 사용하여 `Array<type>`과 같이 나타낼 수도 있다.

TypeScript에서 튜플은 배열을 나타내는 `Array` 타입의 일종으로, 고정된 길이를 가지며 `[type1, type2]`와 같이 특정 위치에 어떤 타입의 값이 오는지 명시되어 있는 타입이다.

## 7. 제네릭과 제네릭의 유틸리티 타입
정적 타입 언어에서 제네릭이란, 단일 타입이 아닌 여러 타입에 대해 재사용 가능한 코드를 만들기 위한 기능이다. 코드를 선언할 때 타입을 결정하지 않고 파라미터로 받아, 실제로 해당 코드를 사용할 때 비로소 타입을 결정하는 방식으로 동작한다. 제네릭을 사용하면 타입 안정성을 해치지 않으면서 여러 타입에 대해 동작하는 코드를 작성할 수 있다는 장점이 있다.

```ts
const numArr = [1, 2, 3, 4, 5];
const strArr = ['a', 'b', 'c', 'd', 'e'];

// 두 함수는 동일한 동작을 하지만, 타입이 다르다는 이유로 별도로 작성됨
const getFirstNumber = (arr: number[]) => arr[0];
const getFirstString = (arr: string[]) => arr[0];

// 제네릭을 사용하면 로직을 분리해낼 수 있음
const getFirst = <T, >(arr: Array<T>) => arr[0];

// 두 호출은 같은 결과값을 가짐
getFirstNumber(numArr);
getFirst<number>(numArr);

// 두 호출은 같은 결과값을 가짐
getFirstString(strArr);
getFirst<string>(strArr);

// ^ 위 함수들은 런타임 에러 발생 가능성이 있는데, 어디가 문제이고 어떻게 고칠 수 있을까?
// -------
// 제네릭은 함수 파라미터, 타입 선언, 클래스 선언에 사용할 수 있다.
interface CustomError<T> {
  message: string;
  realError: T;
}

class Stack<T> {
  #values: Array<T> = [];
  
  push(value: T) {
    ...
  }
  
  pop(): T | undefined {
    ...
  }
}
```

### 유틸리티 타입
TypeScript에서 자체적으로 제공하는 특수한 타입인 **유틸리티 타입** 또한 제네릭을 활용하여 만들어졌다. 이미 정의해 놓은 타입을 변환할 때 훨씬 간결한 문법으로 타입을 정의할 수 있다는 장점이 있다.

[유틸리티 타입 일람](https://www.typescriptlang.org/ko/docs/handbook/utility-types.html)

## 8. 유니온 타입과 인터섹션 타입에 대해 각각 한 문장으로 설명해주세요.
타입을 ‘가능한 값의 집합’으로 생각할 때, 유니온 타입과 인터섹션 타입은 각각의 이름처럼 합집합과 교집합과 같은 기능을 가진다.

### 유니온 타입
유니온 타입은 서로 다른 두 개 이상의 타입을 조합하여, 해당 타입들이 가질 수 있는 값 중 딱 한 가지만을 가지는 타입이다. `|` 연산자를 이용해 둘 이상의 타입을 연결하여 만들 수 있다.

**Tagged union(Discriminated union, Sum type)**

유니온 타입의 특정 속성을 통해, 실행 시간에 해당 값이 속할 브랜치를 컴파일 시간에 식별할 수 있는 경우, 이러한 유니온 타입을 ‘태그된 유니온’ 또는 ‘식별 가능한 유니온’(또는 ‘합 타입’)이라고 부른다.

[Discriminated union 실 사용 예시](https://github.com/Kernel360/f1-Yigil/blob/f7b04a5f7e1c21e96b67c7a3988bf99d8a649c99/frontend/src/types/response.ts#L3-L14)

### 인터섹션 타입
‘둘 이상의 타입이 가지는 모든 프로퍼티를 다 함께 가지고 있는 타입’을 나타내기 위해 인터섹션 타입을 사용한다. `&` 연산자를 이용해 둘 이상의 타입을 연결하여 만들 수 있다. 인터페이스 확장과 비슷해보이지만, 동일한 이름을 사용하는 프로퍼티가 존재할 경우 이를 처리하는 방식에 차이가 있다.

| interface extends  | intersection(&) |
| --- | --- |
| 상위 타입과 하위 타입의 프로퍼티 간에 공통된 프로퍼티가 없으면(즉, 상위 호환성을 만족하지 않으면) 에러 발생 | 별도로 에러가 발생하지 않으므로, 실제 사용 시 추가 타입 검사가 필요 |

## 9. '타입 좁히기'를 예시를 들어 설명해주세요.
‘타입 좁히기(Type narrowing)’는 어떠한 타입을 더욱 구체적인 타입으로 다루기 위한 TypeScript의 기능이다. 타입 좁히기는 실행 시간에 일정 범위 안에서 어떤 변수가 해당 타입임을 확인하는 표현식, 즉 ‘타입 가드(Type guard)’를 통해 이루어진다.

```ts
// 1. typeof를 이용한 타입 가드
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === 'number') {
    // 이 스코프 안에서 padding은 number로 취급됨
    return ' '.repeat(padding) + input;
  }
  
  // padding이 number일 경우의 처리가 끝났으므로...
  // padding은 string으로 취급됨  
  return padding + input;
}

// 2. Truthiness를 이용한 타입 가드
function multiplyAll(
  values: number[] | undefined,
  factor: number
): number[] | undefined {
  if (!values) {
    // 이 스코프에서는 values가 Truthy한 경우만 처리함
    return values;
  }
  
  return values.map((x) => x * factor);
}

// 3. instanceof를 이용한 타입 가드
function logDate(date: Date | string) {
  if (x instanceof Date) {
    // 이 스코프 안에서 date의 프로토타입 체인에는 Date.prototype이 포함됨
    console.log(date.toUTCString());
    return;
  }
  
  // date가 Date일 경우의 처리가 끝났으므로...
  // date는 string으로 취급됨 
  console.log(date.toUpperCase());
}

// 4. 동등성 비교를 이용한 타입 가드
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // isStrictlyEqual(===)은 타입까지 같아야 참
    // 따라서 두 값을 모두 string으로 좁힐 수 있음
    x.toUpperCase();
    y.toUpperCase();
    
    return;
  }
}

// 5. in 연산자를 이용한 타입 가드
type Dog = { woof: () => void };
type Cat = { meow: () => void };

function cry(pet: Dog | Cat) {
  if ('woof' in animal) {
    // 해당 객체가 'woof' 프로퍼티를 가지고 있으므로, Dog으로 취급(구조적 타이핑?)
    return animal.woof();
  }
  
  return animal.meow();
}

// 6. Type predicate를 이용한 타입 가드
// 'variable is type' 형태의 반환값을 가지는 함수
function isNumber(input: unknown): input is number {
  return typeof input === 'number';
}

function logNumber(value: unknown) {
  if (isNumber(value)) {
    // 이 스코프에서는 value를 오직 number만으로 취급할 수 있음
  }
}

// 7. Discriminated union을 이용한 타입 가드
// 같은 이름의 프로퍼티가 서로 다른 리터럴을 가지는 것이 포인트!
interface Circle = {
  kind: 'circle';
  radius: number;
}

interface Square = {
  kind: 'square';
  length: 'number'
}

type Shape = Circle | Square;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case 'circle': {
      return shape.radius ** 2 * 3.14;
    }
    case 'square': {
      return shape.length ** 2;
    }
    // 이후, shape.kind는 never이므로 처리할 필요 X (완전한 체크)
  }
}
```

[Discriminated union을 이용한 타입 가드 실 사용 예시](https://github.com/Kernel360/f1-Yigil/blob/f7b04a5f7e1c21e96b67c7a3988bf99d8a649c99/frontend/src/app/_components/reaction/Comments.tsx#L37-L48)

## 10. namespace
`TypeScript 1.5 이전 버전에서는 ‘내부 모듈(internal module)’이라는 이름으로 불리던 기능이다.`

컴퓨터과학에서 namespace(이름공간, 네임스페이스)란 ‘개체를 구분할 수 있는 범위’를 나타내는 말로, 일반적으로 하나의 이름 공간에서는 하나의 이름이 단 하나의 개체만을 가리키게 된다.

JavaScript에서는 언어 차원에서 지원하지 않아 일종의 디자인 패턴으로 받아들여졌지만, TypeScript 차원에서 지원하고 있다. 구현 상으로 이름공간은 단순히 전역 이름공간에 존재하는 일반적인 JS 객체이며, 때문에 쉽게 사용할 수 있다고 한다.

이름공간을 사용하여 클래스, 인터페이스, 함수, 변수 간의 이름 충돌을 방지하고 ‘논리적’으로 구분할 수 있다. 이는 서로 관련있는 코드가 각각 ‘물리적’으로 다른 파일에 있어도 하나의 단위로 관리할 수 있다는 의미이다.

[ES6(ECMA2015)가 등장하게 되며, 새롭게 작성되는 프로젝트들은 이름공간 대신 모듈 방식을 사용하는 것이 권장된다.](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#using-modules)