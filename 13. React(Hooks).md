## 1. hook이 뭔가요? 일반 함수랑 어떤 차이가 있나요?
Hooks는 재사용 가능한 UI 로직을 나타내는 JavaScript 함수이다. Hooks는 일반적인 JavaScript 함수이지만, 호출 가능한 곳(함수 컴포넌트나 커스텀 Hook의 최상위 레벨)이 제한되어있으며 함수 이름 맨 앞에 반드시 `use`라는 접두어가 붙어야 하는 특수한 유형의 함수이다. React의 여러 가지 기능을 함수 컴포넌트에서 사용할 수 있도록 해주는 내장 Hooks와 사용자가 직접 정의할 수 있는 커스텀 Hooks로 구분된다.

Hooks가 도입되기 전 함수 컴포넌트는 자체 상태를 가질 수 없었으며, 오직 `props`만을 이용해 UI를 표현할 수밖에 없었다. 클래스 컴포넌트는 함수 컴포넌트에 비해 상용구 코드나 제대로 동작하기 위해 해줘야 하는 작업이 많으며, 컴파일 시간에 각 메서드들이 어떻게 맞물려 동작하는지 알기 어렵기 때문에 빌드 시간에 최적화하기 힘들다는 단점이 있다. 또한 UI 로직을 재사용하기 위해 사용되던 고차 컴포넌트와 Render Props 패턴은 Wrapper 컴포넌트의 과도한 중첩을 불러 “Wrapper Hell”을 초래하는 경우가 많았다. 이러한 문제점을 해결하기 위해 Hooks가 도입되었다.

## 2. useState
`useState`는 컴포넌트에 `state` 변수를 추가할 수 있는 내장 Hook이다. 인자로는 초깃값 또는 초기화 함수를 받는다. 반환값은 길이가 2인 배열로, 첫 번째 값은 현재 `state` 변수이고 두 번째 값은 `state`를 다른 값으로 갱신하고 그에 반응하여 리렌더링을 일으키는 `set` 함수이다.

`state`를 직접 바꾸는 것은 React의 핵심 원리 중 하나인 불변성을 위반하는 것으로, 애플리케이션의 동작 예측과 디버깅을 어렵게 만든다. 또한 React는 `set` 함수의 호출에 반응하여 값의 변경을 감지하고 리렌더링을 일으키기 때문에 `state`를 직접 변경하는 것은 권장되지 않는다.

React에서는 여러 개의 `state` 갱신을 한 번의 리렌더링으로 그룹화하며, 이를 Batching(일괄 처리)이라고 한다. 이는 React의 `state` 갱신이 비동기적으로 이루어지기 때문에 가능하다. 클래스 컴포넌트의 `setState` 메서드나 `useState` hook의 setter 함수를 호출하여 `state` 갱신을 요청하면 처리를 위한 Queue에 enqueue되고, 우선순위에 따라 스케줄링되며, 컴포넌트의 불필요한 리렌더링을 최소화하도록 함께 갱신되어야 하는 `state`들을 일괄 처리하여 성능을 최적화한다.

## 3. useEffect/useLayoutEffect
### `useEffect`

`useEffect`는 React 컴포넌트를 외부 시스템과 동기화할 수 있게 해주는 내장 Hook이다. Effect란 특정 이벤트가 아닌 ‘렌더링 자체’에 의해 발생하는 부수 효과를 뜻하며, 화면이 갱신된 이후 실행된다. 이때가 React 컴포넌트를 외부 시스템과 동기화하기 좋은 타이밍이기 때문이다. 첫 번째 인자로는 Effect의 로직이 포함된 함수(`setup`)를 받으며, 두 번째 인자로는 일명 ‘의존성 배열(dependency array)’이라는 배열을 받는다. 의존성 배열에는 `setup`에서 사용되는 `props`, `state` 또는 컴포넌트 내에서 선언된 변수 및 함수(반응형 값)가 들어가야 한다. `setup`은 `cleanup` 함수를 반환할 수도 있는데 컴포넌트가 리렌더링되었을 때, 이전 렌더링에 사용된 값으로 `cleanup`을 실행한 후 새로운 값으로 `setup`을 실행한다. 컴포넌트가 DOM에서 제거되었을 경우에는 `cleanup`만이 실행된다.

의존성 배열은 각 요소의 이전 값과 현재 값을 비교하기 위해 `Object.is` 메서드를 사용한다. 때문에 객체나 배열, 함수 등을 의존성 배열에 제공할 때는 주의해야 한다. 객체나 배열의 경우, 프로퍼티 또는 요소의 추가/변경/삭제 등은 React가 변경을 감지할 수 없으며, 함수는 매 리렌더링마다 다시 생성되기 때문이다.

### `useLayoutEffect`

`useLayoutEffect`는 브라우저가 화면을 다시 그리기 전에, 즉 브라우저의 중요 렌더링 경로(CRP) 중 Repaint 과정 직전에 실행되는 내장 Hook이다. `useEffect`는 DOM이 화면에 그려지고 난 후에 호출되지만 `useLayoutEffect`는 DOM이 화면에 그려지기 전에 호출되기 때문에, DOM을 조작하는 코드가 있더라도 사용자가 flickering을 경험하지 않도록 할 수 있다.

React는 `useLayoutEffect` 내부 코드와 이로 인한 모든 `state` 갱신이 Repaint 직전에 처리되는 것을 보장하기 때문에, 해당 작업이 완료되기 전까지 브라우저가 화면을 다시 그리는 것을 막는다. 따라서 `useLayoutEffect` 내부 로직이 너무 복잡할 경우에는 사용자가 화면을 확인하기까지 시간이 오래 걸린다는 점을 주의해야 한다.

## 4. useContext

## 5. useReducer

## 6. useMemo/useCallback

## 7. useRef
