## 1. `this`

```
💡 `this`는 함수 호출 방식에 따라 결정됩니다.
1️⃣일반 함수에서는 전역 객체, 2️⃣메서드에서는 메서드의 주인인 객체, 3️⃣생성자에서는 생성된 인스턴스, 4️⃣이벤트리스너에서는 `event.currentTarget`을 의미합니다.
```

- **함수 호출에 따라 결정되는 `this`**
  - JS에서 `this`는 함수 선언 시 정적으로 결정되는 게 아니라, **함수 호출 시 호출 상황에 따라 동적으로 결정됨**
- **함수 호출에 따른 바인딩 객체**
  - 1️⃣일반 함수 안에서 `this` ⇒ 전역 객체 (2️⃣에 근거)
    - 콜백 함수에서 `this` ⇒ 전역 객체
    - 함수 내부 함수에서 `this` ⇒ 전역 객체
  - 2️⃣메서드 안에서 `this` ⇒ 메서드 주인 객체
  - 3️⃣생성자 안에서 `this` ⇒ 생성한 인스턴스
  - 4️⃣`addEventListener()` 안에서 `this` ⇒ 이벤트를 발사한 요소 `event.currentTarget`
  - 🚨화살표 함수는 상위 요소의 `this`를 물려받음

## 2. 클래스

- **개념**
  - 객체(인스턴스)를 생성하기 위한 템플릿
  - ES6
- **특징**

  - 선언 전 사용 불가
    - 호이스팅이 안된다는 주장 vs. 호이스팅은 되는데 TDZ 제한이 있다는 주장(`let`처럼)
  - 접근 제한 기능(`#`: private)
  - 생성자(`constructor`)를 가짐
  - `extends`를 사용해 상속 가능
    - `super`를 사용해 부모 클래스의 메서드 호출 가능
  - `static`을 사용해 인스턴스화 없이 필드, 메서드 등을 사용 가능

- **번외) Prototype 상속**

  - 프로토타입을 이용해 상속 구현 가능
    - 현재 스코프에 프로퍼티가 없으면 원형 객체(프로토타입)에서 해당 프로퍼티를 찾음
    - ⇒ 이 성질을 이용해 클래스 기반 언어의 상속과 비슷한 효과를 냄
  - Prototype으로 상속 구현 시 다소 복잡함 ⇒ (ES6) Class로 간단하게 구현 가능

- **번외) `new`의 동작 방식**

  - `new` 연산자를 사용해 객체(인스턴스) 생성 가능

    ```jsx
    function User(name) {
      this.name = name;
    }

    let user = new User('Finn'); // 'new'를 붙여 함수 실행 => 생성자 함수라고 함
    ```

    ```jsx
    class User {
      this.name = name;
    }

    let user = new User("Finn"); // 'new'를 붙일 시 클래스의 constructor가 실행됨
    ```

## 3. 불변성

- **불변성이란?**

  - 값이 변경되지 않는 특성

- **원시 타입 vs. 객체**

  |  | 원시 타입(primitive) | 객체(Object) |
  | --- | --- | --- |
  | 특징 | 불변성(immutable) | 가변성(mutable) |
  | 해석 | 원시 타입의 값은 메모리에 그대로 남아있으며 절대 변형되지 않음 | 객체 내부 값 변경이 가능함. 변경 시, 객체를 참조하고 있는 다른 값들도 변경됨 |

  - 자세한 내용: [자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?](<./5.%20JavaScript(객체).md#4-자바스크립트-자료형-중에-객체와-다른-타입-간의-차이가-있을까>)

- **객체에서 불변성을 유지하는 방법**

  - `Object.freeze()`
    ```
    💡 `Object.freeze()`는 직속 객체만 얼림(얕은 동결)
    ⇒ 중첩된 객체의 경우 객체 하나하나를 얼려야 함(깊은 동결)
    ```

- **불변성 유지의 중요성**
  - 예측 가능한 코드 (변하지 않고 일관적인 상태를 가지므로)
  - 메모리 효율 증가 (변하지 않는 만큼 메모리를 덜 잡아먹으니까)
  - 안전한 병렬 처리 (여러 곳에 동시에 공유되어도 문제 없으니까)

## 4. 자바스크립트 자료형 중에 객체와 다른 타입 간의 차이가 있을까?

### 원시 타입과 객체 간 비교

|  | 원시 타입(Primitive Type) | 객체(Object) |
| --- | --- | --- |
| 종류 | number, string, boolean, undefined, null, symbol, bigint | object(array, function 등 포함) |
| 변성 | 불변성(immutable). 즉 값 자체를 변경할 수 없음. | 가변성(mutable). |
| 저장 방식 | 메모리에 실제 값이 저장됨 | 메모리에 참조 값이 저장됨 |
| 비교 방식 | 서로 같은 값을 가지면 동등 | 서로 같은 값을 가져도, 메모리 주소값이 다르면 동등하지 않음 |
| 복사 방식 | 값을 복사 | \*주소값을 복사 |

- \*자바스크립트에서 객체는 call-by-reference가 아니라 [call-by-sharing](https://uraflower.tistory.com/entry/Call-by-Sharing)이다.

```jsx
// 원시 타입
var num = 80;
var copied = num; // 값이 복사되어, 서로 다른 메모리에 저장됨

num = 100; // 🚨 다른 값을 할당하는 건 불변성과 관련이 없음

console.log(num); // 100
console.log(copied); // 80
```

```jsx
// 객체 타입
const user1 = {
  name: 'Bob',
};
user1.age = 20; // 속성 추가/변경/삭제 가능

const user2 = user1; // user1이 참조한 객체의 메모리 주소 값을 복사해 동일한 객체 참조
user2.name = 'Alice';

console.log(user1.name); // Alice
console.log(user2.name); // Alice
```

### 참고

- [JavaScript 원시 값과 객체의 비교](https://velog.io/@najiexx/JavaScript-%EC%9B%90%EC%8B%9C-%EA%B0%92%EA%B3%BC-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B9%84%EA%B5%90-2aovlqxf)

## 5. 프로토타입

1. 프로토타입이란 무엇인가요?
2. 프로토타입의 장단점은 무엇인가요?
3. 프로토타입을 실제로 사용해볼 일은 잘 없는데 어디에 사용할 수 있을까요?

## 6. (Weak)Map vs. (Weak)Set

## 7. `Date` 객체
