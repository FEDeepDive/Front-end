## 1. 브라우저의 렌더링 과정
### 중요 렌더링 경로(Critical Rendering Path, CRP)

중요 렌더링 경로는 브라우저가 서버로부터 받은 HTML, CSS, JavaScript를 화면에 그려내는 일련의 단계를 의미하며, 크게 다음의 여섯 가지 단계를 거치게 된다:

| 단계 | 작업 |
| :-: | :-: |
| DOM Tree(문서 객체 모델 트리) 생성 | 응답으로 받은 HTML을 파싱하여 DOM 노드들을 만들고, 만들어진 DOM 노드들을 병합하여 DOM Tree를 만든다. |
| CSSOM Tree(CSS 객체 모델 트리) 생성 | 응답으로 받은 CSS를 파싱하여, DOM을 스타일링하기 위한 모든 스타일 정보를 포함하는 CSSOM Tree를 만든다. |
| JavaScript 적용 | DOM 또는 CSSOM을 변경하는 JavaScript 코드를 적용한다. |
| Render Tree 생성 | DOM Tree와 CSSOM Tree를 결합하여, 페이지를 렌더링하는 데 필요한 노드만 포함된 Render Tree를 만든다. |
| Layout | 생성된 렌더 트리와 화면의 크기, 뷰포트 등을 활용해 요소들이 페이지 내에서 배치되는 위치와 방법, 각 요소의 너비와 높이, 그리고 서로 관련된 위치를 결정한다. 최초 실행 이후 Layout 과정은 Reflow 또는 Relayout이라고도 부른다. |
| Paint | 렌더 트리의 각 노드를 실제로 브라우저 화면에 그린다. 다른 용어로는 Rasterizing이라고도 한다. 최초 실행 이후의 Painting 과정은 Repainting이라고도 부른다. |

### 리페인팅과 리플로우의 차이점과 실행되는 시점
|  | Reflow | Repaint |
| :-: | :-: | :-: |
| 실행 시점 | 요소의 레이아웃, 즉 높이/너비나 위치가 바뀌는 경우 트리거됨 | 요소의 레이아웃이 바뀌지 않는 변경이 있을 때 트리거됨 |
| 트리거시키는 속성 변경 예시 | `width`, `height`, `font-size` 등 | `color`, `background` 등 |
- **⚠️ Reflow 이후에는 항상 Repaint가 일어난다!**

## 2. BOM(Browser Object Model)이란?
브라우저 객체 모델은 DOM(문서 객체 모델)과는 달리 W3C의 표준 객체 모델은 아니지만, 문서 이외에 브라우저의 모든 것을 자바스크립트로 제어하기 위해 브라우저가 제공하는 추가적인 객체들을 지칭한다. 브라우저 객체의 예시로는 `location`, `history`, `navigator` 등이 있으며, 이 객체들은 모두 `window` 객체의 하위에 존재한다.

## 3. SPA, MPA, CSR, SSR의 차이
### SPA vs. MPA
| SPA(Single Page Application) | MPA(Multi Page Application) |
| :-: | :-: |
| 하나의 페이지로 구성된 웹 애플리케이션 | 여러 개의 페이지로 구성된 웹 애플리케이션 |
| 초기 동작에 필요한 모든 정적 리소스를 최초에 한 번 다운로드받음 | 새로운 페이지를 요청할 때마다 정적 리소스가 다운로드됨 |
| 새로운 페이지 요청이 있을 때, 페이지 갱신에 필요한 데이터만 전달받아 페이지를 갱신함 | 매번 전체 페이지가 갱신됨 |
| 전체 페이지를 갱신하지 않고 필요한 부분만 갱신하기 때문에 flickering 없이 자연스러운 UX를 제공할 수 있음 | 완성된 형태의 HTML 파일을 전달받기 때문에 검색 엔진이 페이지를 크롤링하기 적합하여 SEO 관점에서 유리함 |
| 서버와의 결합도가 비교적 낮음 | 서버와의 결합도가 비교적 높음 |

### CSR vs. SSR
| CSR(Client Side Rendering) | SSR(Server Side Rendering) |
| :-: | :-: |
| 웹 페이지에 표시해야 하는 모든 내용이 클라이언트, 즉 브라우저에서 처리되어 그려짐 | 웹 페이지에 표시해야 하는 내용이 서버에서 처리되어 HTML에 담긴 채로 클라이언트에 전달됨 |
| Time To View = Time To Interactive | Time To View ≠ Time To Interactive |
| 사용자 상호작용 중심인 웹 애플리케이션에 적합 | SEO 성능을 요구하는 컨텐츠 제공 중심 웹 사이트에 적합 |
| 애플리케이션의 성능이 클라이언트의 하드웨어/소프트웨어에 크게 의존 | 애플리케이션의 성능이 서버의 하드웨어/소프트웨어에 크게 의존 |

## 4. CORS 정의 및 목적
### 출처(Origin)

서버의 위치를 의미하는 URL에서 `Protocol(Scheme)`과 `Host(Domain)`를 합친 것, 즉 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 정보이다. HTTP, HTTPS 프로토콜의 기본 포트 번호가 80, 443으로 정해져 있기 때문에 생략이 가능하다.

### SOP(Same Origin Policy, 동일 출처 정책)

브라우저는 보안을 위해, 서로 같은 출처끼리만 리소스를 공유할 수 있는 정책을 적용하고 있는데, 이 정책을 동일 출처 정책이라고 한다. SOP 정책은 다른 출처에서 로드된 리소스에 대한 일기 접근을 막음으로써, 민감한 정보가 허가받지 않은 출처에 노출되지 않도록 한다.

### CORS(Cross-Origin Resource Sharing, 교차 출처 리소스 공유)

웹과 같이 열린 환경에서 다른 출처의 리소스를 가져와서 사용하는 것은 굉장히 흔한 일이기 때문에, CORS 정책을 지킨 리소스 요청은 출처가 다르더라도 허용한다. CORS의 동작을 간단히 정리하면 다음과 같다:

1. 다른 출처의 리소스를 요청하기 위해 HTTP 프로토콜을 사용하여 요청을 보낼 때, 브라우저는 요청 헤더의 `Origin` 필드에 출처를 담아 함께 보낸다.
2. 서버에서 응답을 보낼 때 응답 헤더의 `Access-Control-Allow-Origin` 필드에 접근이 허용된 출처를 함께 담아 보낸다.
3. 요청 헤더의 `Origin`과 `Access-Control-Allow-Origin`을 비교하여 응답이 유효한지 결정한다.

### CORS가 동작하는 세 가지 시나리오

| Simple Requests | Preflight | Requests with credentials |
| :-: | :-: | :-: |
| GET, POST, HEAD 중 하나의 메소드를 사용하며, [CORS에 사용 가능한 헤더](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)만을 가지고 있다면 예비 요청을 보내지 않고 바로 본 요청을 보낼 수 있다. | 본 요청을 보내는 것이 안전한지 확인하기 위해, OPTIONS 메소드를 사용하여 예비 요청을 보낸다. | 모든 요청에 인증 정보를 포함하고 싶은 경우, 브라우저에 CORS 정책 위반 여부를 검사하는 규칙이 몇 가지 더 추가된다. |

### CORS를 해결하는 방법

백엔드에서 `Access-Control-Allow-Origin` 헤더를 설정해주는 것이 정석이며, 웹 서버에서 추가해줄 수도 있지만 웹 프레임워크의 미들웨어를 사용하는 방법도 있다. 프론트엔드 개발 환경에서 CORS 문제가 발생할 경우, 프록시 기능을 사용해 CORS 정책을 우회할 수도 있다.

## 5. 웹 접근성을 높이기 위한 방법은 어떤 것들이 있을까요?
### 웹 접근성
모든 사용자가 특정 환경이나 신체적 장애에 상관없이 웹사이트나 웹 애플리케이션에서 제공하는 모든 정보에 동등하게 접근하고 이용할 수 있도록 보장해주는 것이다. W3C가 관리하는 [웹 콘텐츠 접근성 지침](https://www.w3.org/TR/WCAG21/)은 4가지 원칙의 범주로 분류하여 제공되고 있으며, 이러한 지침을 준수하기 위해 노력하면 웹 접근성을 높일 수 있다.

💡 볼 만한 채널 - [AOA11Y](https://www.youtube.com/channel/UCTI6h7Vb05Td63qHQ3wjySQ)

| 인식의 용이성(Perceivable) | 정보와 사용자 인터페이스 요소는 사용자가 인식할 수 있는 방법으로 제시되어야 한다. |
| --- | --- |
| 운용의 용이성(Operable) | 사용자 인터페이스 구성요소 및 네비게이션은 운용 가능해야 한다. |
| 이해의 용이성(Understandable) | 사용자 인터페이스의 정보와 운용은 이해 가능해야 한다. |
| 견고성(Robust) | 콘텐츠는 보조 기술을 포함한 다양한 사용자 에이전트가 해석할 수 있을 정도로 견고해야 한다. |

### 적용할 수 있는 여러 가지 방법들
1. 이미지, 로고, 그림 등의 그래픽을 인식할 수 없는 사용자나, 표현할 수 없는 기기를 위해 대체 텍스트 사용하기
2. 텍스트나 이미지를 더 쉽게 읽고 이해할 수 있게 만들기 위해 높은 색상 대비 사용하기
3. 헤더 태그(`h1` ~ `h6`)를 사용해 문서 정리하기
4. `form` 입력 요소에 레이블 적용하기
5. 개발자가 의도한 사용자 인터페이스 상호작용이나 구조적인 정보를 스크린 리더와 같은 보조 기술에 전달하여, 시각/인지 장애인들에게 비장애인들과 동일한 사용자 경험을 제공하는 WAI-ARIA 활용하기

## 6. 검색 엔진 최적화(Search Engine **O**ptimization, SEO)에 대해 알고 있나요?
검색 엔진 최적화는 웹사이트가 검색 엔진에서 상위에 노출될 수 있도록 최적화하는 과정을 말한다.

### `robots.txt`
검색 엔진 크롤러의 동작을 제어하여 트래픽을 관리할 수 있는 설정 파일이다. 크롤러의 중복 페이지 수집을 막고, 불필요한 페이지의 크롤링을 제외하여 의미있는 콘텐츠를 크롤링할 수 있도록 설정할 수 있다.

### `sitemap.xml`
일반적인 크롤링 과정에서 쉽게 발견되지 않는 페이지도 문제없이 크롤링되고 색인될 수 있게, 웹사이트 내 모든 페이지의 목록을 나열한 파일이다.

### OpenGraph
HTML 문서의 메타정보를 구조화된 형태로 쉽게 표시할 수 있도록 페이스북에서 정의한 프로토콜이다.

### SSR을 활용한 SEO
Client Side Rendering의 경우, 최초로 로드된 HTML 파일의 내용이 비어있어 웹 크롤러가 페이지에 접속해도 의미있는 정보를 얻을 수 없다. SSR을 적용하면 서버에서 의미있는 콘텐츠를 먼저 렌더링해서 전달할 수 있기 때문에, 크롤러가 웹 페이지의 콘텐츠와 메타 태그 등의 정보를 읽을 수 있어 SEO에 유리해진다.

## 7. 이벤트
프로그래밍에서 이벤트란, 시스템에서 일어나는 사건을 말한다. 시스템은 어떠한 사건이 일어나면 그에 맞는 형태의 `신호`를 생성하고, 이에 따라 자동으로 `특정한 코드`가 실행될 수 있게 하는 방법을 제공한다. 여기서 `신호`를 ‘이벤트’, `특정한 코드`를 ‘이벤트 핸들러(또는 이벤트 리스너)’라고 한다. 웹 프론트엔드 프로그래밍에서 이벤트는 일반적으로 브라우저 이벤트를 의미하며, 자세한 종류는 MDN의 [이벤트 레퍼런스](https://developer.mozilla.org/en-US/docs/Web/Events) 문서나 [이벤트 인터페이스 목록](https://developer.mozilla.org/en-US/docs/Web/API/Event#interfaces_based_on_event)을 통해 확인할 수 있다.

### 이벤트 바인딩
`특정한 코드`를 이벤트가 발생했을 때 실행시키기 위해서 해당 이벤트에 ‘등록’하게 되며, 이러한 행위는 곧 이벤트와 이벤트 핸들러를 하나로 ‘묶어서’ 다룬다고 볼 수 있기 때문에 이를 ‘이벤트 바인딩’이라고 부른다. 브라우저 상의 이벤트와 이벤트 핸들러를 바인딩하는 방법은 크게 3가지가 있다.

1. HTML 요소의 이벤트 속성 값을 이벤트 핸들러의 호출 결과로 지정해주기
2. DOM 요소의 이벤트 프로퍼티 값에 이벤트 핸들러를 사용하는 함수를 지정해주기
3. `EventTarget` 인터페이스를 구현하는 DOM 요소 객체들의 `addEventListener` 함수에 이벤트 핸들러를 인수로 전달하기

1번 방식은 HTML과 JS의 혼용이 이루어지고, 2번 방식은 한 번에 하나의 이벤트 핸들러만 등록된다는 단점이 있기 때문에 3번이 더 권장되는 방식이다!

### 이벤트 전파
하나의 요소에 이벤트가 발생하면 가장 최상단의 조상 요소를 만날 때까지 거슬러올라가며 요소 각각에 할당된 이벤트 핸들러가 동작한다. 이러한 동작이 마치 거품이 아래에서 위로 올라오는 모양과 닮아있기 때문에 이벤트 버블링이라고 부른다. `onfocus` 등의 특수한 이벤트 외의 거의 모든 이벤트는 버블링된다.

이와 반대로, 최상단 요소부터 이벤트가 발생한 요소를 찾아 내려가는 과정을 캡처링이라고 한다. `addEventListener` 함수로 이벤트 핸들러를 등록할 때 추가 인자로 `{ capture: true }`를 제공해주면 캡처링 과정에서도 이벤트 핸들러가 동작한다.

이벤트가 발생한 요소를 가리키고 싶은 경우, `Event` 인터페이스의 두 가지 속성 `event.target`과 `event.currentTarget`을 사용할 수 있다.

| event.target | event.currentTarget |
| --- | --- |
| 실제로 이벤트를 발생시킨 요소 | 이벤트 핸들러가 등록된 요소이며, event.target에서부터 이벤트 버블링이 일어나기 때문에 event.target과 서로 다른 값일 수 있음 |

이벤트 버블링의 존재 덕분에, 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 부모 요소에 한 번만 이벤트 핸들러를 바인딩한 후, `event.target` 속성을 통해 자식 요소 중 실제로 어떤 요소가 이벤트를 발생시켰는지 구분하는 **이벤트 위임** 방식을 사용할 수 있다.

이벤트 전파를 막기 위해서는 `Event` 인터페이스의 `stopPropagation()` 함수를 사용하면 된다. 같은 이벤트 에 등록된 다른 핸들러의 동작도 함께 막고 싶다면 `stopImmediatePropagation()` 함수를 사용하면 된다.

## 8. 쿠키/세션/토큰
HTTP는 기본적으로 무상태(Stateless) 프로토콜이기 때문에, 연결이 종료되는 순간 모든 상태 정보가 사라진다. 때문에 작업의 문맥을 유지하기 위해서 서버는 클라이언트가 이전 통신이 이루어졌을 때 보낸 정보를 다음 통신이 이루어질 때 알 수 없다. 그럼에도 정보를 유지하고 싶은 경우, 클라이언트 측에서 서버에게 요청을 보낼 때마다 추가로 정보를 포함시켜 전달할 수 있는데, 전달하는 방법은 크게 아래의 세 가지로 나뉜다:

### 쿠키
서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다. 브라우저는 해당 데이터를 저장해뒀다가, 동일한 서버에 다시 요청을 보낼 때 함께 전달한다. 이름/값/만료일(또는 최대 유지 시간)/도메인/전송 경로 등의 정보가 기록된 문자열 형태이다.

쿠키는 만료일 또는 최대 유지 시간이 지정되어 설정된 기간 동안 브라우저 상에서 유지되는 ‘영속적인 쿠키’와, 브라우저 또는 탭이 종료되면 사라지는 ‘세션 쿠키’의 두 가지로 구분된다. 

쿠키는 브라우저에서 자바스크립트를 통해 접근할 수 있기 때문에, XSS(Cross-Site Scripting, 사이트 간 스크립팅)에 취약하다. `HttpOnly` 접미사를 붙여 브라우저에서 쿠키에 접근할 수 없도록 할 수 있다. 또한 쿠키는 HTTP 요청 헤더에 포함되어 전송되며, HTTP는 데이터를 암호화하는 보안 메커니즘이 없기 때문에 `Secure` 접미사를 붙여 HTTPS 통신에서만 쿠키를 전송하도록 설정할 수 있다. CSRF(Cross-Site Request Forgery, 사이트 간 요청 위조)를 막기 위해 설정할 수 있는 `SameSite` 속성도 존재한다.

### 세션
쿠키만을 이용해 모든 상태를 저장할 수도 있지만, 쿠키는 보안적으로 취약하여 민감한 정보를 저장하는 데에는 부적합하다. 또한 쿠키는 최대 크기와 최대 개수가 정해져 있어 저장할 수 있는 정보량의 제한이 있고, 매 요청마다 헤더에 포함되어 전달되기 때문에, 정보량이 많을수록 요청의 크기가 커져 네트워크 성능 부하가 심해진다.

이러한 문제점을 해결하기 위해, 서버 측에서 사용자의 인증 정보를 저장하고 관리하는 방식을 세션 방식이라고 한다. 서버가 클라이언트의 인증 요청에 대해 응답할 때, 인증 상태에 대한 자료구조를 저장하고 해당 자료구조를 식별할 수 있는 ID를 쿠키에 담아 전달한다. 이후 클라이언트가 요청을 보낼 때마다 쿠키가 함께 전달되므로, 서버는 ID의 유효성을 판단하여 클라이언트를 식별할 수 있다. 서버와의 상호작용을 통해서만 세션을 식별할 수 있기 때문에, 이러한 세션 ID를 opaque token(또는 reference token)이라고 부르기도 한다.

쿠키가 외부에 노출되더라도 세션 ID 자체에는 민감한 정보가 없으므로 쿠키만 사용하는 방식보다는 훨씬 안전하지만, 누군가 세션 ID를 탈취하여 해당 클라이언트인 척 위장할 가능성도 있다.

### 토큰
세션 방식을 사용하면 서버는 요청마다 함께 전달되는 세션 ID의 유효성을 판단할 수 있도록, 유효한 세션 ID를 메모리에 로드해놓는다. 때문에 서버에 동시 접속하는 사용자가 많아질수록 부하가 심해진다는 단점이 있다. 이를 해결하기 위해, 세션 ID 대신 토큰을 발급해줄 수 있다.

**JWT(JSON Web Token)**
URL에 들어갈 수 있는 문자로만 구성되었으며, 디지털 서명되어 자체적으로 위변조 여부를 확인할 수 있는 토큰이다. `header.payload.signature`의 형태를 가지고 있으며, `.`으로 구분된 각각이 JSON 구조로 정보를 저장하고 있다. 일반적으로 서버에 직접 요청할 때 사용하는 토큰과 해당 토큰을 재발급할 목적으로 사용하는 토큰의 두 가지를 한 번에 사용하는 액세스 토큰/리프레시 토큰 방식을 자주 사용한다.

### 브라우저 저장소
여러 가지 단점이 있는 쿠키 대신 사용할 수 있는 클라이언트의 데이터 저장 기능이다. HTTP 요청에 포함되지 않기 때문에 네트워크 부하가 없고, 용량의 제한이 없으며 구조화된 객체를 저장할 수 있다.

**`window.sessionStorage`**
탭이 닫히면 데이터가 초기화되며, 도메인이 동일하더라도 각 탭/브라우저 간에 데이터가 공유되지 않는다.

**`window.localStorage`**
탭을 닫거나 브라우저를 종료해도 데이터를 영구적으로 보관하며, 도메인만 동일하다면 모든 브라우저 간에 전역적으로 데이터가 공유된다.

## 9. 성능
### Core Web Vitals
눈으로는 확인할 수 없는 웹사이트의 성능 차이를 확인하기 위해, 정량적인 지표를 측정하여 평가할 필요가 있다. 여러 가지 지표가 있지만, 구글에서 중요하다고 판단한 세 가지 지표 ‘Core Web Vitals’이 주로 사용된다.

**Largest Contentful Paint(LCP)**
페이지 로딩 속도를 측정하는 지표로, 사용자가 웹페이지를 로딩할 때 페이지의 가장 큰 콘텐츠 요소가 화면에 얼마나 빨리 렌더링되는지를 측정한다. LCP가 빠르면 빠를수록, 사용자가 더 빠르게 페이지를 이해할 수 있다.

**First Input Delay(FID)**
상호작용 반응성을 측정하는 지표로, 사용자가 웹페이지의 상호작용 요소를 클릭한 후, 실제로 브라우저가 반응을 시작하기까지 걸리는 시간을 측정한다. FID가 빠르면 빠를수록, 사용자 경험에 긍정적인 영향을 준다.

**Cumulative Layout Shift(CLS)**
콘텐츠 안정성을 측정하는 지표로, 웹페이지에서 요소들의 이동이나 크기 조정 등 레이아웃이 예상치 못하게 변경되는 빈도와 양을 측정한다. CLS가 낮으면 낮을수록, 사용자의 혼란을 줄이고 의도치 않은 동작이 줄어든다.

**Interaction to Next Paint(INP)**
2024년 3월 12일부터 FID를 대신하여 Core Web Vitals에 추가되는 지표로, 클릭/키보드 입력 등의 사용자 입력이 발생할 때 화면이 얼마나 빨리 변화하는지에 대한 응답성을 측정한다. FID는 첫 상호작용만을 측정하지만, INP는 페이지의 모든 상호작용을 측정하기 때문에 좀 더 신뢰성있는 지표라고 볼 수 있다.

### 스로틀(throttle) / 디바운스(debounce)
scroll, resize, input, mousemove 등의 이벤트는 짧은 시간 내에 연속해서 발생한다는 특징이 있다. 이러한 이벤트에 바인딩된 이벤트 핸들러는 과도하게 많이 호출되어 성능에 문제를 일으킬 수 있기 때문에, 이를 조절하기 위해 스로틀/디바운스라는 처리 기법이 소개되었다.

스로틀은 짧은 간격으로 이벤트가 연속으로 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 하는 것이며, 디바운스는 짧은 간격으로 이벤트가 발생했을 때 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 이후 한 번만 호출하는 것이다.

### `requestAnimationFrame()`
애니메이션과 그 외의 반복 작업을 수행하기 위해 브라우저가 제공하는 메서드로, 브라우저의 리페인트 주기에 맞춰 콜백 함수를 실행하도록 예약한다. 리페인트 주기는 브라우저의 화면 갱신 주기와 동일하기 때문에 애니메이션을 매끄럽게 실행할 수 있고, 사용자의 디바이스 성능과 배터리 수명을 고려하며, 비활성 상태 또는 백그라운드에서 실행되는 탭의 처리를 제한할 수 있으며, 다른 브라우저 작업과 동기화되어 실행되기 때문에 일반적으로 애니메이션 처리에 자주 사용되는 `setInterval()`이나 `setTimeout()`과 비교하여 효율적이다.

### CSS 애니메이션 vs JS 애니메이션
CSS 애니메이션은 CSS의 `transition`/`animation` 속성을 이용해 간단한 애니메이션을 적용할 때 사용할 수 있다. 반응형으로 애니메이션을 구현하기 좋으며, *컴포지터 스레드*라는 별도의 스레드에서 처리되기 때문에 기본 스레드에서 무거운 작업을 처리하고 있더라도 중단되지 않는다는 장점이 있다.

JS 애니메이션은 CSS로 처리하기 복잡한 애니메이션을 세밀하게 처리하고 싶을 때 사용할 수 있다. 예를 들어 `Framer Motion` 등의 외부 라이브러리를 통해 스프링 기반 애니메이션 등의 복잡한 애니메이션을 구현할 수 있다.

### 이미지 스프라이트
스프라이트(Sprite) 방식이란 여러 개의 작은 이미지를 하나의 이미지로 합쳐 한 번에 로드할 수 있도록 관리하는 방식을 의미한다. 각 이미지의 크기와 오프셋을 지정해 적절하게 이미지를 잘라서 보여줄 수 있다. 각각의 이미지를 하나씩 로드하는 것보다 속도가 빠르다는 장점이 있지만, 유지보수가 어려워질 수 있으며 합쳐진 이미지 파일을 불러오지 못한다면 해당 이미지를 사용 중인 모든 스프라이트를 볼 수 없게 된다는 단점이 있다.