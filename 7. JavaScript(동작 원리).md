## 1. 자바스크립트 엔진

**자바스크립트 엔진이란 ?**

자바스크립트 코드를 실행하는 인터프리터로 웹 브라우저에서 사용된다.

**V8이란 ?**

- 구글에서 만들어진 엔진으로 C++로 작성되었다.
- Chrome과 Node.js에서 사용하며 멀티쓰레드로 동작한다.
- 그 밖의 애플 사의 JavaScript Core(Safari, RN사용)와 마이크로소프트 사의 Chakra(익스플로러, Edge사용)등의 자바스크립트 엔진이 있다.

**V8의 동작 원리**

1. **토크나이저(Tokenizer)/파서(Parser)**
   - 토크나이징(Tokenizing) : 자바스크립트 코드를 분석하여 ‘의미를 갖는 최소 단위’인 토큰(Token)으로 분해하는 과정
   - 파싱(Parsing) : 분해한 ‘토큰’들을 분석하여, 문법적으로 의미를 갖는 AST 생성
2. **Ignition 인터프리터**
   - Ignition라는 인터프리터에 파싱된 결과물인 AST를 전달하고 이를 **ByteCode**로 변환하여 실행
   - Ignition 의 3가지 장점
     1. **메모리 사용량 감소 :** 기계어로 보다 바이트 코드로 컴파일 하는것이 메모리가 적게 소모됨
     2. **파싱 시 오버헤드 감소 :** 바이트 코드는 간결하기 때문에 다시 파싱하기도 편하다.
     3. **컴파일 파이프 라인의 복잡성 감소 :** **`Optimizing`** 이든 **`Deoptimizing`** 이든 바이트 코드 하나만 생각하면 되기 때문에 편하다.
3. **TuroboFan JIT 컴파일러**
   - 인터프리팅 된 ByteCode를 최적화 하기 위해 **TuroboFan JIT 컴파일러**를 사용한다.
   - 자주 사용되는 코드는 TurboFan 으로 보내줘서 **`Optimized Machine Code`**, 즉 최적화된 코드로 다시 컴파일된다. 그러다가 다시 사용이 덜 된다 싶으면 **`Deoptimizing`** 하기도 한다.
   - TurboFan은 얼마나 자주 호출되는지, 인터프리팅된 바이트 코드의 길이가 특정 임계점을 높는지 아닌지등 내부적인 조건을 최적화 될 코드를 선별한다.

**V8의 최적화 기법**

- Hidden Class(히든클래스) : 비슷한놈들 가져다 놓고 쓰는거
- Inline Cashing(인라인 캐싱) : 캐싱해주는거
- https://ui.toast.com/posts/ko_20210909
- https://www.nextree.io/javascript-engine/
- https://oliveyoung.tech/blog/2023-10-28/oliveyoung-javascript-turbofan/

**자바스크립트 엔진의 동작 원리를 고려하여 성능 좋은 자바스크립트 코드를 작성하는법**

- C나 Java 처럼 정적 타이핑 언어로 생각하며 코드를 작성한다.
- 하나의 배열에는 하나의 타입만 넣어준다.
- 잘 짜여진 JS코드는 C++에 근사한 성능을 낼 수 있다고 한다.

**자바스크립트 엔진의 메모리 구조**

자바스크립트 엔진은 콜스택(실행 컨택스트 스택)과 메모리 힙으로 이루어져 있으며 콜스택에 맞게 요청된 작업을 순차적으로 진행한다.

<br/>

## **2. 자바스크립트 런타임 환경**

자바스크립트 런타임 환경이란 자바스크립트로 만든 프로그램이 실행되는 환경을 의미한다. 자바스크립트 런타임은 자바스크립트 엔진, Web API, Task Queue(Microtask Queue, Animation Frames), EventLoop, RenderingEngine 으로 이루어져 있다.

**자바스크립트 엔진**

- 자바스크립트 코드를 해석하고 실행하는 역할을 하며 메모리 힙과 콜 스택 두개의 컴포넌트로 구성된다.
- **콜 스택(call stack)**
  - 실행컨텍스트(함수의 실행순서)가 쌓이는 스택.
  - 원시타입 데이터와 메모리 힙의 주소값의 식별자 값이 저장된다.
- **메모리 힙(memory heap)**
  - 객체가 저장되는 메모리 공간. 즉 메모리 할당이 일어나는 곳.
  - 이 때 참조타입의 데이터가 저장됨
  - 참조타입 데이터가 저장된 메모리힙의 주소값은 콜스택의 변수 식별자의 값으로 각각 저장됨
  - 콜스택에 할당되는 변수 식별자 자체는 콜스택 상의 **실행 컨텍스트(Execution Context)의 렉시컬 환경(Lexical Environment) 라는 곳에 저장**됨

**Web APIs**

- 브라우저 환경에서 비동기 작업을 처리하기위해 제공되는 API들이다.
- 네트워크 요청, 타이머 설정, DOM 조작 및 이벤트 처리 메서드를 제공한다.(ex. **setTimeout, fetch, XMLHttpRequest, addEventListener)**
- Node.js 의 경우 Web API가 아닌 C++ binding과 thread pool로 이루어져 있다.

**Task Queue(Callback Queue, Event Queue, Macrotask Queue)**

- setTimeout(), setInterval(), setImmediate()와 같은 함수에 등록된 콜백이 보관되는 큐
- Web APIs를 한번 거쳐서 오는 콜백은 Task Queue로 등록됨(궁예)

**Microtask Queue**

- Promise나 async/await, process.nextTick, Object.observe, MutationObserver 등 프로미스나 옵저버에 등록된 콜백이 보관되는 큐
- JS 문법에 관련된 콜백은 Microtask Queue 내부로 들어옴(궁예)

**Animation Frames**

- requestAnimationFrame() 과 같이 브라우저 렌더링과 관련된 함수에 등록된 콜백이 보관되는 큐
- 우선순위는 Microtask보다는 낮고, (Macro)Task보다는 높다.

**[Event Loop](https://helloinyong.tistory.com/291)(링크 클릭시 이벤트 루프의 5단계를 볼수있다.~~)~~**

- 이벤트 루프는 자바스크립트의 비동기 동작을 관리하는 핵심 매커니즘 중 하나이다.
- 태스크 큐와 콜 스택을 돌면서 현재 실행중인 실행 컨텍스트가 있는지, 태스크 큐에 대기중인 함수(콜백 함수, 이벤트 핸들러)가 있는지 반복하며 확인한다.
- 이벤트 루프는 **Microtask Queue -> Animation Frames -> Task Queue** 순으로 task를 수행한다.
- 이벤트 루프는 Microtask Queue나 Animation Frames를 방문할 때는, 큐 안에 있는 **모든 작업들을 수행**하지만, Task Queue를 방문할 때는 **한 번에 하나의 작업**만 call stack으로 전달하고 다른 Queue를 순회한다.
- 이벤트 루프는 왜 콜스택이 비어있을때만 태스크 큐의 함수들을 옮겨줄까 ?
  - 만약 콜스택이 비어있지 않을때 태스크를 넘겨주면 멀티스레드에서 발생하는 문제를 똑같이 안게 된다. 동기화 문제를 해결해야됨 그래서 **JS가 단일 스레드 언어라는 것을 보장해주기 위해서** 반드시 콜 스택이 비어있을때만 데이터 전달한다.

**RenderingEngine**

- 렌더링, 브라우저, 레이아웃 단어 그대로 웹 페이지에 대한 컨텐츠 및 데이터를 위해 동작하는 엔진

<br/>

## **3. 비동기 프로그래밍**

자바스크립트 엔진은 단 하나의 콜 스택(실행컨텍스트 스택)을 갖기 때문에 기본적으로는 동기식에 싱글 스레드로 동작한다. 하지만 실제로 자바스크립트의 작동은 웹 브라우저나 node.js같은 멀티 스레드 환경에 임베디드 되어 실행되기 때문에 자바스크립트는 비동기 프로그래밍이 가능하고 블로킹이 발생하지 않으며 멀티스레드인 것처럼 동작한다.

<br/>

## 4. 실행 컨텍스트

자바스크립트 엔진은 소스코드를 2개의 과정, **'소스코드의 평가'** 와 **'소스코드의 실행'** 과정으로 나누어 처리한다.

- 소스코드의 평가 과정 : 실행 컨텍스트를 생성하고 문만 먼저 실행해서 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경레코드)에 등록해둔다.
- 소스코드의 실행 과정 : 문을 제외한 소스코드가 순차적으로 실행된다. 즉 런타임 된다. 이때 소스코드 실행에 필요한 정보는 실행컨텍스트에서 검색해 취득하고, 소스코드의 실행 결과는 실행컨텍스트가 관리하는 스코프에 등록된다.

**실행 컨택스트란 ?**

- 변수 이름을 비롯한 모든 식별자가 등록되는는곳으로 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
- 변수 객체, 스코프 체인, this 객체, 외부 환경(클로저 구현에 사용됨), 함수 매개변수, 함수/변수 선언 위치 정보, 스코프 종류(현재 컨텍스트가 함수 스코프인지, 전역 스코프인지), strict 모드 여부를 기록한다.
- 실행 컨텍스트는 자바스크립트 엔진이 코드를 실행할때 생성되며 스택으로 쌓이면서 관리됨.

**실행 컨텍스트 스택**

- 실행 컨텍스트를 관리하는 스택 자료구조로 코드의 실행 순서를 관리한다.
- 실행 컨텍스트 스택의 최상위 실행 컨텍스트는 언제나 현재 실행중인 코드의 실행 컨텍스트이다.

**렉시컬 환경**

- 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조. 즉 스코프와 식별자를 관리한다.
- 렉시컬 환경은 **환경 레코드**와, **외부 렉시컬 환경에 대한 참조** 두개의 컴포넌트로 구성되어 있다.
- 렉시컬 스코프의 실체이다.

<br/>

## 5. 스코프

**스코프**

식별자의 유효한 범위

**스코프 체인**

스코프가 중첩되어 있는 상황에서 스코프의 연결된 구조

**스코프 체이닝**

자바스크립트 엔진이 변수 및 함수를 검색할 때 발생하는 매커니즘. 현재 스코프에서 변수 또는 함수를 찾지 못하면 상위 스코프로 이동하여 변수를 찾아냄

**렉시컬 스코프**

자바스크립트에서 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정함

**블록 레벨 스코프 / 함수 레벨 스코프**

- 함수 레벨 스코프(Function-level Scope) : var<br/>
  함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.
- 블록 레벨 스코프(Block-level Scope) : let, const<br/>
  모든 코드 블록(함수,if문,for문,while문,try/catch문 등)내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이다.

**동적 스코프 /렉시컬 스코프(정적 스코프)**

- 동적 스코프<br/>
  함수 호출 위치에 따라 상위 스코프가 결정됨
- 정적 스코프(렉시컬 스코프)<br/>
  함수 선언 위치에 따라 상위 스코프가 결정됨

<br/>

## 6. JS의 가비지 컬렉션(GC)에 대해 설명해주세요

**JS의 가비지 컬렉션**

JS는 객체가 생성되었을 때 자동으로 메모리를 할당하고, 더이상 필요하지 않을때 자동으로 메모리를 해제한다. 자바스크립트는 **도달 가능성(reachability)** 이라는 개념을 통해 메모리 관리를 수행하며, 가비지 컬렉터가 모든 객체를 모니터링하고 있다가 ‘도달할 수 없는’ 객체를 삭제한다.

**JS 가비지 컬렉션 알고리즘**

- **Reference-Counting**<br/>
  참조되지 않는 객체의 메모리를 회수. 단 순환 참조가 발생하면 메모리 누수가 발생한다.
- **Mark-and-Sweep**<br/>
  **`global`** 에서 연결된 모든 객체(=도달 가능한 객체)를 **`mark`** 하고, **`mark`** 되지 않은 객체를 메모리에서 **`sweep`** ⇒ 순환 참조 문제 해결

**V8 엔진 메모리 구조**

- V8엔진의 힙 메모리는 객체와 동적 데이터가 저장되는 공간이자 가비지 컬렉션이 발생하는곳이다.

**메모리 누수**

- https://yceffort.kr/2020/07/memory-leaks-in-javascript
- https://ui.toast.com/posts/ko_20210611

<br/>

## 7. 배열에 값을 추가/삭제했을 때 메모리가 어떻게 변화하는지 과정을 설명해주세요.

자바스크립트에서는 배열의 요소가 갖는 메모리 크기가 서로 달라도 되고, 배열 요소가 메모리 상에 연속적으로 이어져있지 않을 수 있다.(=희소배열일 수 있다).

이는 자바스크립트 에서의 배열이 일반적인 배열(밀집배열)의 동작을 흉내낸, **`index`** 와 **`length`** 를 프로퍼티로 가지고 있는 특수 객체이기 때문이다.

JavaScript 배열의 **`index`** 는 메모리를 참조하기 위해 사용되는 **`Hash Key`** 역할도 하지만, 데이터의 **순서** 를 보장하는 프로퍼티의 역할도 한다.

자바스크립트의 배열에 값을 추가하는 것은 객체에 프로퍼티를 추가하는 것과 같고, 배열 값을 삭제하는 것은 객체의 프로퍼티를 삭제하는 것과 같다.

**`push`** 나 **`pop`** 메서드 사용시 맨 마지막 요소의 **`index`** 프로퍼티 값만 바뀌고, 다른 요소에 관여를 하지 않으므로 **`O(1)`** 의 시간복잡도를 가지지만, **`shift`** 나 **`unshift`** 의 경우 모든 요소들의 **`index`** 프로퍼티의 값을 바꿔줘야 하기 때문에 **`O(n)`** 의 시간 복잡도를 가진다.

<br/>

## 8. 호이스팅(hoisting)에 대해 설명해주세요

자바스크립트 엔진은 소스코드를 한 줄씩 실행하기 전에 모든 **선언문** 을 찾아서 평가한다. 이 때 실행컨텍스트가 생성되며 선언문들이 스코프의 상단으로 끌어올려진 것처럼 동작하는 자바스크립트의 고유 특징을 호이스팅이라고 한다.
