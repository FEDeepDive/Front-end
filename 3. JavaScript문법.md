## 1. ES6에 추가된 문법

```
💡 `let`, `const`, 화살표 함수, 클래스, 모듈, 프로미스 등이 추가되었습니다. 템플릿 리터럴, 객체 리터럴 기능이 향상되었고, `String`, `Array`, `Object` 등의 객체에 메서드들이 추가되었습니다.
```

- **`let`, `const`**
- **화살표 함수(Arrow Function)**
- **매개변수 기본값, Spread 연산자, Rest 파라미터**
- **구조분해할당(Destructuring)**
- **클래스**
- **모듈**
- **프로미스**
- **`Symbol`**
- **`Map`, `Set`**
- **이터레이션(Iteration) + `for...of`**
  - 이터레이션 프로토콜을 준수한 객체는 `for...of` 순회 가능
  - `for...of`: 이터레이터의 `next()`를 호출하여 이터러블을 순회
  - 참고: [이터레이션과 for...of 문](https://poiemaweb.com/es6-iteration-for-of)
- **제너레이터(Generator)**
  - 이터러블을 생성하는 함수
  - 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편함
  - ES7의 `async/await`과 함께 사용 가능
- **향상된 템플릿 리터럴**
  - 문자열 보간 (ex. `변수는 ${variable}`)
  - 여러 줄의 문자열 O
- **향상된 객체 리터럴**
  - 프로퍼티 축약 표현 (프로퍼티 값으로 변수 사용 시, 프로퍼티 이름 생략 가능)
  - 메소드 축약 표현 (`function` 키워드 생략 O)
  - 프로퍼티 키 동적 생성 O (ex. `obj[i + '-th'] = i`)
  - 참고: [객체 리터럴 프로퍼티 기능 확장](https://poiemaweb.com/es6-enhanced-object-property)
- **`String`, `Array`, `Object` 등의 메서드 추가**

```
💡 이외에도 매우 많음. 자세한 건 [공식 문서](https://262.ecma-international.org/6.0/) 확인.
참고로, ES6(=ECMAScript2015) 이후부터는 ECMA2016처럼 년도로 표기함.
```

## 2. `var`, `const`, `let`의 차이점

```
💡 `var`는 재선언, 재할당이 불가능하고, 함수 또는 글로벌 스코프를 갖습니다. 반면 `let`, `const`는 재선언이 불가능하고, 블록 레벨 스코프를 갖습니다. `let`은 재할당이 가능하지만, `const`는 재할당이 불가능합니다.
```

|  | var | let | const |
| --- | --- | --- | --- |
| 재선언 | O | X | X |
| 재할당 | O | O | X |
| 스코프 | 함수 안 선언 시 함수 범위, 이외에는 전역 범위 | 블록({}) 범위 | 블록({}) 범위 |
| 호이스팅 | O, undefined로 초기화 | O, 초기화 X ⇒ 선언 전 사용 시 Reference Error | O, 초기화 X ⇒ 선언 전 사용 시 Reference Error |
| 기타 특성 | var 키워드 생략 가능 |  | 선언과 동시에 할당 필요 |

## 3. `null`, `undefined`?

```
💡 `null`은 빈 값이고, `undefined`는 값이 할당되지 않은 상태를 가리킵니다.
```

- `null`: 값이 비어있음
  - type: **object**
  - 빈 객체를 가리키는 객체 포인터
- `undefined`: 자료형이 지정되지 않음 (값이 할당되지 않아서)
  - type: undefined

## 4. `NaN`?

```
💡 `NaN`은 숫자가 아닌 값을 나타냅니다. 주로(항상이 아님) 숫자가 아닌 값을 숫자처럼 사용하려고 하는 경우에 `NaN`이 반환됩니다.
```

- **개념**
  - Not a Number, 즉 숫자가 아님을 나타냄
- **특징**
  - type: Number
  - 설정 불가능, 쓰기 불가능
  - `NaN === NaN` ⇒ `false`
    - [이유](https://velog.io/@eunbeann/Why-NaN-NaN-is-False): `NaN`은 다른 어떤 값과도 (자기 자신 포함) 같지 않음
    - 따라서 `NaN`인지 판별할 때 `isNaN()` 사용
- **`NaN`이 반환되는 상황**
  - 숫자로 변환 실패 (ex. `Number('abc')`)
  - 결과가 허수인 수학 계산식 (ex. `Math.sqrt(-1)`)
  - 정의할 수 없는 계산식 (ex. `0 * Infinity`, `Infinity/Infinity`)
  - `NaN` 연산 (ex. `7 * NaN`, `7 * 'abc'`) ⇒ `**NaN`은 전염성을 가짐\*\*
  - 유효하지 않은 값이 숫자로 표시되는 경우 (ex. `new Data('abc').getTime()`)

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.

```
💡 JavaScript 코드는 세미콜론이 없어도 에러가 나지 않으며, 세미콜론이 없을 경우 인터프리터가 자동으로 삽입해주기 때문입니다.
```

- **이유**
  - 세미콜론이 없어도 에러가 나지 않음
  - 세미콜론이 없을 경우, 인터프리터가 자동으로 삽입해주기 때문(=ASI (Automatic Semicolon Insertion, 자동 세미콜론 삽입))
- **번외**
  - **세미콜론 쓰면 좋은 점**
    - 가독성
    - 안전성
    - 범용성
  - **세미콜론 안 쓰면 좋은 점**
    - 코드 라인 위치 변경이 용이함
      ```jsx
      array
      	.map(...)
      	.filter(...) // 세미콜론이 없으면 라인 위치 변경이 간편함
      ```

## 6. `Symbol`에 대해 설명해주세요.

- **개념**
  - ES6에서 추가된 7번째 원시형 타입
  - 유일성이 보장됨
  - “심볼 이름”(또는 “심볼 설명”)을 가짐
    - 두 심볼이 서로 동일한 심볼 설명을 가져도 심볼값은 서로 다름
    - ⇒ 심볼 이름은 진짜 이름표 역할만 함
- **목적**
  - 숨겨진 프로퍼티, 유니크한 식별자를 만들기 위해 사용됨
- **특징**
  - `for..in` 반복문에서 배제됨 (non-Symbol이어야 순회함)
- **참고**
  - [심볼형](https://ko.javascript.info/symbol)

## 7. `==` 과 `===` 의 차이가 무엇인가요?

```
💡 엄격한 동등 연산자(`===`)는 피연산자의 타입이 서로 다른 경우 `false`를 반환합니다.
하지만 느슨한 동등 연산자(`==`)는 피연산자의 타입이 서로 다른 경우 타입 변환을 시도한 후 값을 비교합니다.
따라서 정확한 값 비교를 원한다면 엄격한 동등 연산자(`===`)를 사용하는 것이 좋습니다.
```

|  | 느슨한 동등 연산자(==) | 엄격한 동등 연산자(===, 일치 연산자) |
| --- | --- | --- |
| 비교 값 | 값 | 값 & 타입 |
| 연산 과정 | 타입이 다른 경우 타입 변환 후 비교 | 동등 연산자와 동일 but 타입이 다른 경우 바로 `false` 반환 |

**💡자세한 내용은 [MDN 동등 비교 및 동일성](https://developer.mozilla.org/ko/docs/Web/JavaScript/Equality_comparisons_and_sameness#loose_equality_using) 참고**

## 8. `for … of` / `for … in` 문

### `for...in`

- **순회 대상**
  - 모든 객체
  - 객체의 모든 \*열거가능(enumerable)하고 non-Symbol인 속성에 대해 반복
    - \*열거 속성: 내부의 열거 가능 플래그 `[[Enumerable]]`가 `true`인 속성
- **특징**
  - 객체의 key에만 접근 가능
  - 임의의 순서로 반복(=순서 보장 X)
  - 객체의 프로토타입까지 순회 가능
- **등장 시기**: ES1

### `for...of`

- **순회 대상**
  - 이터러블 객체(`[Symbol.iterator]` 속성을 갖고 있는 객체)
- **특징**
  - 객체의 key, value에 접근 가능
  - `await` 사용 가능 (`for-await-of`)
- **등장 시기**: ES6

### `Array.prototype.forEach`

- **순회 대상**: Array, Map
- **장점**
  - 배열의 요소와 인덱스에 접근 가능
  - 콜백 함수를 따로 짤 수 있음 & 화살표 함수 사용 가능
- **단점**
  - 루프 내부에서 `await` 사용이 불가
  - 반복 흐름을 제어하지 못함 (`break`, `continue` 불가능)
- **등장 시기**: ES5

### 참고

- [for...of와 for..in의 차이](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of#difference_between_for...of_and_for...in)
- [for vs for-in vs forEach vs for-of 무엇으로 자바스크립트 리스트를 돌아야 하나](https://yceffort.kr/2021/06/best-solution-for-looping-over-array)

## 9. `reduce` 사용법

```
💡 `reduce`는 배열의 각 요소에 대해 함수를 실행하고, 그 결과를 누산기에 누적하여 최종 누적 결과를 얻을 때 사용됩니다.
```

- **개념**

  - 배열을 순회하며 각 요소에 대한 함수를 실행 ⇒ 함수 반환값을 누적하여 하나의 결과값을 반환함

- **구문**

  ```jsx
  // 물음표(?)로 끝나는 변수는 Optional

  const 누적된결과값 = array.reduce(
    (누산기, 현재요소, 현재인덱스?, _호출한배열?) => {
      return 누산기에_누적할_값;
    },
    누산기초기값?,
  );
  ```

  - `array.reduce(콜백, 누산기초기값?)`
    - 콜백 매개변수
      - `누산기`: 콜백의 반환 값을 누적함
      - `현재요소`
      - `현재인덱스?`
      - `호출한배열?`: `reduce()`를 호출한 배열
    - `누산기초기값?`: 콜백 최초 호출 시 누산기 초기값으로 할당할 값. 없으면 배열의 첫 번째 요소 사용. (빈 배열 + 초기값도 없으면 오류 발생)
  - 반환값: 누산기의 최종 값

- **예시**
  ```jsx
  // 배열의 모든 원소 더하기
  const numbers = [1, 2, 3, 4];
  const sum = numbers.reduce((sum, num) => sum + num, 0);
  console.log(sum); // 10
  ```

## 10. `splice`, `slice`, `split` 차이

```
💡 `splice`와 `slice`는 배열의 특정 구간을 추출한다는 점에서 비슷합니다.
하지만 `splice`는 원본 배열을 변형하고, 배열 삭제와 추가 모두 가능한 반면,
`slice`는 원본을 변형하지 않고, 특정 부분을 획득하는 데 목적이 있다는 점에서 다릅니다.
`split`은 문자열을 구분자로 끊어 배열로 만들 때 사용됩니다.
```

|  | splice | slice | split |
| --- | --- | --- | --- |
| 목적 | 배열에 요소 삽입/삭제/교체를 통한 배열 내용 변경 | 배열/문자열의 특정 구간 획득 | 문자열을 특정 구분자로 나눔 |
| 원본변형 | O | X | X |
| 반환값 | 제거한 구간 배열 | 추출한 구간 배열 | 구분자로 나눈 결과 배열 |
| 매개변수(\*:옵셔널) | `시작 인덱스`, `*삭제할 요소 개수`, `*배열에 추가할 요소들` | `*시작 인덱스`, `*종료 인덱스(구간에 미포함)` | `*구분자`, `*끊어진 문자열의 최대 개수` |
| 매개변수 특징 | 인덱스가 음수(-n)면, 뒤에서 n번째로 계산 | 인덱스가 음수(-n)면, 뒤에서 n번째로 계산 |  |

## 11. 옵셔널 체이닝

```
💡 옵셔널 체이닝(`?.`)은 값의 존재 여부를 평가하기 위한 구문입니다. 만약 평가하려는 대상이 `null` 또는 `undefined`이라면 즉시 `undefined`를 반환하고, 그렇지 않으면 평가를 계속 진행합니다.
```

- **개념**

  - 평가대상이 존재하면 평가를 계속 진행, \*`nullish`면 `undefined` 반환
    - \*nullish: `null` 또는 `undefined`
  - ES11(ECMAScript2020)

- **문법**

  ```jsx
  // 평가대상?.anything
  obj?.prop;
  obj?.[key];
  obj?.method();
  arr?.[index];
  func?.(args);
  ```

  ```jsx
  user?.address?.street;
  // 위 코드는 아래와 동일한 의미를 가짐
  user !== null &&
  user !== undefined &&
  user.address !== null &&
  user.address !== undefined
    ? user.address.street
    : undefined;
  ```

- **특징**

  - nullish 체크를 위한 코드가 필요없음 ⇒ 코드 간결성
  - `nullish` 값을 참조했을 때 에러를 일으키지 않음 ⇒ 안전하게 접근 O
  - 평가대상이 `nullish`하면 평가를 즉시 중단함 (=단축 평가)

- **주의할 점**

  - 평가대상은 값이 존재하지 않아도 괜찮아야 함. 무분별한 사용은 ㄴㄴ.
  - 쓰기에 사용 불가 (읽기나 삭제에는 O)
    ```jsx
    user?.name = 'Finn' // SyntaxError. undefined = 'Finn'이 되기 때문
    ```

## 12. NULL 병합 연산자(`??`)는 무엇인가요?

```
💡 Null 병합 연산자(`??`)는 앞쪽 피연산자가 `null` 또는 `undefined`일 때 뒤쪽 피연산자를 반환하고, 그렇지 않으면 앞쪽 피연산자를 반환합니다.
```

- **개념**
  - 왼쪽 피연산자가 `nullish`이면 오른쪽 피연산자를, 그렇지 않으면 왼쪽 피연산자를 반환
  - 단축 평가
  - ES11(ECMAScript2020)
- **구문**
  ```jsx
  // 두 코드는 서로 동일한 의미를 가짐
  a ?? b;
  a === null || a === undefined ? b : a;
  ```
- 🚨 **OR 연산자(`||`)와 차이점: nullish vs. falsy**
  ```jsx
  // OR 연산자 살펴보기
  // 두 코드는 서로 동일한 의미를 가짐
  a || b;
  Boolean(a) === false ? b : a;
  ```
  - **Null 병합 연산자**는 `null`과 `undefined`를 제외한 *falsy*한 값을 유효한 값으로 인정함
  - **OR 연산자**는 *falsy*한 값을 유효한 값으로 인정하지 않음 ⇒ 예상치 못한 오류 발생 O
  - \**falsy*한 값: `0`, `''`, `NaN`, `null`, `undefined` 등

## 13. 단축평가

```
💡 단축평가란, 왼쪽 피연산자가 결과를 확정짓는 경우 오른쪽 피연산자를 평가하지 않은 채 평가를 중단하는 것을 말합니다. AND(`&&`), OR(`||`), 옵셔널 체이닝(`?.`), Null 병합 연산자(`??`) 등이 단축평가로 시행됩니다.
```

- **개념**
  - Short Circuit
  - 왼쪽 피연산자를 평가했을 때 연산 결과가 확정되면 오른쪽 피연산자를 평가하지 않고 평가를 중단하는 것
  - 예시: AND(`&&`), OR(`||`), 옵셔널 체이닝(`?.`), Null 병합 연산자(`??`)
    - \*옵셔널체이닝은 연산자가 아니라 구문임

## 14. Promise

```
💡 프로미스(Promise)는 기존의 콜백함수를 활용한 비동기 처리를 보완하기 위한 객체입니다.
```

- **목적**
  - 비동기 처리 (콜백함수보다 편하게)
  - **콜백함수 디자인 패턴의 대체제**
    - 가독성 완화 & 유지보수성 강화 (ex. `then` 체이닝, 비동기 처리 시점 명시 …)
    - 에러 처리 기능 `catch` 추가
    - 여러 비동기 처리를 한 번에 처리할 수 있음
- **개념**

  - X가 성공하면 A, 실패하면 B를 실행
  - **[프로미스의 3가지 상태](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md)**
    - 대기(pending): `new Promise()` 호출 시 대기 상태가 됨. 성공/실패 기다리는 상태
    - 성공(fulfilled)
    - 실패(rejected)
      ```
      💡 처리(settled) : 결과가 확정된 프로미스. 상태가 아님! 편의를 위한 용어일 뿐.
      ```
  - `Ajax`, `fetch`는 프로미스가 적용된 녀석들임

- **문법**

  ```jsx
  const promise = new Promise((resolve, reject) => {
    // 비동기 작업 수행

    if (/* 비동기 작업 수행 성공 */) {
      resolve('result');
    }
    else { /* 비동기 작업 수행 실패 */
      reject('failure reason');
    }
  });

  promise.then(function () {
    console.log("then: 프로미스 성공 시 실행");
  }).catch(function () {
    console.log("catch: 프로미스 실패 시 실행");
  }).finally(function () {
    console.log("finally: 프로미스 결과와 관계 없이 마지막에 실행");
  })
  ```

  - **`then`, `catch` 메서드는 프로미스를 반환함** ⇒ 체이닝이 가능
  - 요청에 대한 응답이 유효하면 resolve, 유효하지 않으면 reject하는 식으로 많이 쓰임

- 참고
  - [자바스크립트 Promise 쉽게 이해하기](https://joshua1988.github.io/web-development/javascript/promise-for-beginners/)
  - [프로미스](https://poiemaweb.com/es6-promise)

## 14-1. Promise란 무엇이며, async/await과 어떻게 다른지, 왜 async/await이 등장했는지?

- **프로미스(Promise)**
  - 콜백함수를 활용한 비동기 처리 패턴을 보완하기 위한 객체
- **async/await의 등장 배경**
  - 프로미스를 활용한 비동기 처리 패턴을 보완하기 위함
- **프로미스와 async/await 차이점**

  |  | 프로미스 | async/await |
  | --- | --- | --- |
  | 사용 방식 | 후속 처리 메서드(ex. `then`) 사용 | 비동기 처리할 곳에 `await` 키워드 사용 |
  | 코드 길이 | 비교적 긺 | 비교적 짧음 |
  | 비동기적 사고 | 비동기적 사고가 필요함 ⇒ 여전히 비동기 처리가 복잡함 | 비동기적 사고 필요 X ⇒ 비동기 처리를 일반 코드 짜 듯 짤 수 있음 |

## 14-2. Promise나 async/await를 es5로 트랜스파일하면 어떻게 되나요?

```
💡 프로미스(Promise)는 새롭게 추가된 객체이므로 코드가 자동으로 변경되지 않습니다. 때문에 폴리필을 추가해주어야 합니다.
반면 async/await은 코드가 자동으로 변경됩니다.
```

## 15. 클로저(Closure)란 무엇인가요?

```
💡 클로저(Closure)란 **함수와 그 함수의 어휘적 환경이 조합**되어 특별한 기능을 갖는 함수입니다. 클로저는 참조를 통해 선언 당시 주변 상태를 기억하고, 이를 통해 외부 스코프의 식별자에 접근할 수 있습니다. 클로저를 사용하면 데이터 은닉, 상태 유지 등이 가능합니다.
```

- **클로저에 앞서, 어휘적 환경(Lexical Environment)이란?**
  - **렉시컬 스코프(Lexical Scope)**
    - 식별자가 선언된 위치의 블록 + 상위 스코프
    - 식별자는 선언과 동시에 주변 상태(렉시컬 스코프에 선언된 식별자)를 참조함
  - **어휘적 환경 개념**
    - 코드가 선언될 때의 주변 환경으로, 코드의 스코프와 식별자에 대한 접근을 제공함
  - **어휘적 환경의 기능**
    - 1️⃣환경 레코드(렉시컬 스코프 정보 저장, 식별자-값 매핑)
    - 2️⃣스코프 체인 탐색을 통한 외부 환경 참조
  - **어휘적 환경의 특징**
    - 식별자 선언 시 형성됨
    - 한 번 형성되면 스코프 체인은 변하지 않음 ⇒ 정적 특성
  ```
  💡 (정리) 렉시컬 환경이란 코드가 선언될 당시 주변 환경을 말합니다. 렉시컬 환경이 있기에 각 **식별자의 렉시컬 스코프 정보를 저장**할 수 있으며, **스코프 체인**을 통해 외부 스코프를 탐색하여 식별자를 찾을 수 있습니다.
  ```
  - 예시
    ```jsx
    let name = 'finn';
    function lexical() {
      console.log(name);
    }
    name = 'jayk';
    lexical(); // 'finn'이 아닌 'jayk' => 값 기억이 X 변수 자체를 참조
    ```
    - `lexical` 함수의 렉시컬 스코프: `lexical` 함수 내부 스코프 + 전역 블록
    - `lexical` 함수는 함수가 선언될 때의 `name` 변수 값 "finn"을 기억하는 게 아니라, 전역 블록의 `name` 변수를 "참조"함
- **핵심 개념**
  - **함수 자체와 함수의 어휘적(lexical) 환경이 조합**되어 특별한 기능을 제공하는 함수
  - ⇒ **\*참조를 통해 주변 상태를 기억하여, 외부 스코프의 식별자에 접근할 수 있는 함수**
    - \*참조하지 않아도 주변 상태를 기억할 수 있음 but 위와 같은 설명이 일반적임
  - 부연 설명
    - 모든 함수는 클로저임
    - 자신이 선언됐을 때의 주변 환경을 기억함 & 해당 변수에 접근 O
    - 내부 함수에서 외부 함수로 접근 O (예시 참고)
- **예시**

  ```jsx
  // 클로저 활용 예시
  function counter() {
    let cnt = 0;

    function setCnt(x) {
      cnt = x;
    }
    function print() {
      console.log(cnt);
    }

    return {
      print,
      setCnt,
    };
  }

  const myCounter = counter();
  myCounter.print(); // 0
  myCounter.setCnt(5);
  myCounter.print(); // 5. 클로저의 특성 때문에 0이 아니라 5임!
  ```

  - 1️⃣ 내부 함수(`setCnt`, `print`)를 외부 함수(`counter`) 바깥에서 호출해도 외부 함수의 변수(`cnt`)에 접근이 가능
  - 2️⃣ 내부 함수 실행이 끝나면 외부 함수 내 `cnt`에 접근할 수 없다고 예상할 수 있음 but 클로저이기 때문에 참조가 유지되어 이게 가능한 거임
    - `myCounter` (참조)⇒ `setCnt`, `print`
    - `setCnt`, `print` (참조)⇒ `cnt`

- **캡슐화 & 모듈화**
  - 노출되어선 안되는 정보를 클로저에 넣어, **정보 접근 제한**
  - 함수 실행이 끝나도 **상태가 유지**됨 ⇒ \*모듈 패턴 구현 가능
    - \*모듈 패턴: 외부 함수 리턴 시, 객체에 여러 내부 함수를 담아 리턴
    - ⇒ 리턴 값은 외부에서 직접 접근 불가, 클로저를 할당받은 녀석(모듈)만 사용 가능
- **주의할 점**
  - 클로저 내 식별자는 언제든지 참조될 수 있기에 삭제되지 않고 메모리에 남아있게 됨 ⇒ 성능 저하의 원인
- **참고**
  - [클로저](https://poiemaweb.com/js-closure)
  - [MDN 클로저](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures#%ED%81%B4%EB%A1%9C%EC%A0%80closure)
  - [자바스크립트 클로저 실용적이고 쉬운 설명](https://www.youtube.com/watch?v=LL0DGc5pg7A&t=344s)
  - [😄 면접관: closure에 대해 설명해 보세요 🫠 네..?](https://velog.io/@rmaomina/job-interview-closure)
  - [어휘적 환경과 클로저의 기본 개념](https://taero.blog/posts/about-closure)

## 16. 구조 분해 할당(Destructuring assignment)이란?

## 17. 전개 구문(Spread syntax)이란?

## 18. 나머지 매개변수(Rest parameters)란?

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

## 20-1. `bind`를 `apply`, `call`로 어떻게 구현할 수 있을까요? 구현해보세요.
