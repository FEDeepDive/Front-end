## 1. hook이 뭔가요? 일반 함수랑 어떤 차이가 있나요?

- **등장 배경**
  - 클래스 컴포넌트를 주로 사용하던 시절임 (당시 함수 컴포넌트는 stateful할 수 없었기 때문)
  - 컴포넌트 간 stateful 로직 재사용이 어려워 HOC, render props를 이용할 경우
    - 1️⃣코드 추적이 어려움 2️⃣컴포넌트의 재구성을 강요함 3️⃣wrapper 지옥
  - 클래스 컴포넌트의 복잡성
    - 1️⃣생명주기 메서드의 복잡성 2️⃣테스트의 어려움
  - 클래스 자체의 문제
    - 1️⃣`this` 러닝커브(잘 알아도 어렵고 복잡함) 2️⃣코드가 긺 3️⃣핫 리로딩을 깨지기 쉽게 함
- **개념**
  - 함수 컴포넌트에서 상태와 생명주기 기능을 연동(hook)할 수 있게 해주는 함수
  - 재사용 가능한 로직을 담은 함수
  - 여러 컴포넌트에서 재사용 가능함
  - 한 컴포넌트에서 여러 번 호출해도, [각 호출은 독립적임](https://ko.legacy.reactjs.org/docs/hooks-faq.html#how-does-react-associate-hook-calls-with-components)
- **작성 규칙 (일반 함수와 차이)**
  - 함수 이름이 `use`로 시작함
  - **함수 내 최상단**에서만 호출 가능
    - 반복문, 조건문, 중첩 함수, `try`/`catch`/`finally` 등에서 호출할 수 없음
  - **리액트 함수(함수 컴포넌트, 커스텀 훅) 안에서만** 호출 가능 (클래스 컴포넌트에서 사용 ❌)
  - 리액트가 함수 컴포넌트를 렌더링하고 있을 때만 호출 가능
- **주의사항**
  - 순수 함수여야 함 (멱등성이 보장되어야 함)
  - 동적으로 사용 불가
  - 동적으로 변경 불가

## 2. useState

### useState 훅 사용법

```jsx
const [state, setState] = useState(initialState);
```

- **개념**
  - 상태를 사용할 수 있게 해주는 hook
  - 상태란 컴포넌트의 데이터를 기억하는 특별한 변수
- **파라미터**
  - `initialState`: `state` 초깃값
- **반환값**
  - `[state, setState]`
    - `state`: 현재 상태 값
    - `setState`: 상태 값을 업데이트하고, **리렌더링을 트리거**하는 함수
      - 업데이트할 값 또는 업데이터 함수를 파라미터로 받음
- **사용 예시**

  ```jsx
  // ✅상태 업데이트 예시
  const [name, setName] = useState('Kim');
  const handleNameChange = (newName) => {
    setName(newName);
  }

  // ✅상태 업데이트 함수 예시
  const [todos, setTodos] = useState(['some task']);
  const appendName = (newTodo) => {
    setNames((prevTodos) => [...prevTodos, newTodo]);
  }

  // ✅상태 초기화 함수 예시
  const getData = () => ({ ... });
  const [data, setData] = useState(getData);   // ✅good
  const [data, setData] = useState(getData()); // ❌bad (렌더링마다 실행됨)
  ```

### 질문

1️⃣ 왜 `state`를 직접 바꾸지 않고, `useState`를 사용하나요?

✅ `useState`를 사용해야 렌더링을 트리거할 수 있기 때문입니다. `state` 대신 지역 변수를 사용하면 값은 바뀌지만 리렌더링이 일어나지 않는 것처럼, `state`를 직접 바꾸어도 마찬가지입니다.

2️⃣ `setState`는 비동기 동작인가요? 동기 동작인가요?

✅ `setState`는 비동기 동작입니다.

```jsx
const [count, setCount] = useState(0);
const increment = () => {
  setCount(count + 1);
  console.log(count);
};

return <button onClick={increment}>plus</button>;
```

버튼을 누를 때마다 count 상태를 증가시키고 동시에 상태를 로깅하는예제입니다. 위 예제에서 버튼을 3번 클릭하면 콘솔에는 1, 2, 3이 아닌 0, 1, 2가 찍힙니다. 비동기 함수인 `setState`가 동기 함수인 `console.log`보다 나중에 실행되기 때문입니다.

3️⃣ `setState`가 비동기 동작을 취했을 때 얻을 수 있는 이점은 무엇인가요?

✅ 리액트는 여러 상태 업데이트를 모아 한 번에 처리하여, 렌더링 횟수를 줄이고 성능을 높입니다. 이를 **배치(Batch) 처리**라고 합니다. `setState`가 동기 동작이라면 이러한 배치 처리가 불가능합니다.

4️⃣ `setState`를 동기 동작처럼 만드는 방법이 있나요?

✅ `useEffect`가 마운트 이후에 실행되는 점을 이용해, `setState` 직후 상태 값을 참조할 수 있습니다.

```jsx
const increment = () => {
  setCount(count + 1);
};

useEffect(() => {
  console.log(count);
}, [count]);
```

## 3. useEffect/useLayoutEffect

### useEffect 훅 사용법

```jsx
useEffect(setup, dependencies?)
```

- **개념**
  - 외부 시스템과 컴포넌트를 동기화하는 훅
  - 렌더링 후 실행됨
- **파라미터**
  - `setup`: 이펙트 로직을 포함하고 클린업 함수(optional)를 반환하는 함수
    - 클린업 함수는 마운트 해제 시 실행됨
    - 클린업 함수를 지정하지 않아도 임의적으로 지정되어 있음
  - `dependencies`?: `setup` 함수에서 참조되는 반응형 값들을 포함하는 배열
    - 의존성 배열이 전달되지 않은 경우: 모든 렌더링마다 이펙트가 동작
    - 빈 의존성 배열이 전달되는 경우: 첫 렌더링 시 이펙트가 동작
    - 의존성 배열이 전달되는 경우: 첫 렌더링 + 의존성 값 변경 시 이펙트가 동작
- **사용 예시**

  ```jsx
  // ✅빈 의존성 배열 사용 예시
  const [todos, setTodos] = useState([]);
  useEffect(() => {
    const data = getTodos();
    setTodos(data);
  }, []);

  // ✅클린업 함수 사용 예시
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');
  useEffect(() => {
    const connection = createConnection(serverUrl);
    connection.connect();

    return () => {
      connection.disconnect();
    };
  }, [serverUrl]);
  ```

### useLayoutEffect 훅 사용법

```jsx
useLayoutEffect(setup, dependencies?)
```

- **개념**
  - 렌더링 전에 실행되는 `useEffect`
  - 화면을 렌더링하기 전에 레이아웃(컴포넌트 위치 등)을 계산해야 하는 경우 적합
    - `useEffect`: 초기 렌더링 → 이펙트 → 렌더링
    - `useLayoutEffect`: 이펙트 → 렌더링
  - 브라우저의 렌더링을 막기 때문에 성능 저하 이슈가 있으니, 가능하면 `useEffect`를 사용하자
- **파라미터 (`useEffect`와 동일함)**
- **사용 예시**

  ```jsx
  // ✅툴팁 컴포넌트 구현 예시
  function Tooltip() {
    const ref = useRef(null);
    const [tooltipHeight, setTooltipHeight] = useState(0);

    // 툴팁이 렌더링->리렌더링 되며 위치가 바뀌는 걸 사용자가 보면 안 되니까,
    // 화면이 렌더링되기 전에 작업해야 함
    useLayoutEffect(() => {
      const { height } = ref.current.getBoundingClientRect();
      setTooltipHeight(height);
    }, []);
  }
  ```

## 4. useContext

### useContext 훅 사용법

```jsx
const value = useContext(SomeContext);
```

- **개념**
  - 컴포넌트에서 컨텍스트를 읽고 구독할 수 있게 하는 훅
  - 컴포넌트 트리 전체에 전역적인 데이터를 제공할 수 있게 함
  - 다음 이유로 꼭 필요할때만 최적화해서 사용하는 게 좋음
    - [컨텍스트 API](https://ko.legacy.reactjs.org/docs/context.html#api)를 사용하면 컴포넌트 재사용이 어려워짐
    - **컨텍스트를 구독한 모든 컴포넌트는 Provider의 `value`가 바뀔 때마다 리렌더링됨**
- **파라미터**
  - `SomeContext`: `createContext`로 생성한 컨텍스트
- **반환값**
  - `value`
    - 가장 가까운 상위 `SomeContext.Provider`에 전달된 `value`
    - Provider 컴포넌트로 감싸지 않은 경우, `createContext`시 인자로 전달한 초깃값
- **사용 예시**

  ```jsx
  /* Theme 상태 전역 관리 예시 */
  // App.js
  const ThemeContext = createContext('light');

  function App() {
    const [theme, setTheme] = useState('light');
    return (
      <ThemeContext.Provider value={{ theme, setTheme }}>
        <Page />
      </ThemeContext.Provider>
    );
  }

  // Provider로 감싼 Page 컴포넌트 안 어딘가에 있는 버튼 컴포넌트
  // ThemeButton.js
  function ThemeButton() {
    const { theme, setTheme } = useContext(ThemeContext);
    return (
      <button
        style={{
          backgroundColor: theme === 'dark' ? 'black' : 'white',
          color: theme === 'dark' ? 'white' : 'black',
        }}
        onClick={() => {
          setTheme(theme === 'dark' ? 'light' : 'dark');
        }}
      >
        Toggle theme
      </button>
    );
  }
  ```

## 5. useReducer

### useReducer 훅 사용법

```jsx
const [state, dispatch] = useReducer(reducer, initialArg, init?)
```

- **개념**
  - Reducer를 활용해 주로 복잡한 구조의 상태를 생성 및 관리하기 위한 훅
    - 업데이트 로직을 단계에 따라 분리되어 구현하므로, 상태 추적에 용이함
    - 상태 업데이트 로직을 이벤트 핸들러가 아닌 reducer에서 독립적으로 관리 가능
  - **Reducer**: Action에 따른 다음 상태를 정의해놓은 **매뉴얼 북**
  - **Dispatch**: Action을 Reducer에 전달해 상태를 업데이트하는 **주체**
  - **Action**: 수행할 행위
- **파라미터**
  - `reducer`: `state`, `action`을 받고, `action`에 따른 다음 `state`을 반환하는 함수
  - `initialArg`: 상태 초깃값
  - `init?`: 상태 초기화 함수
- **반환값**
  - `[state, dispatch]`
    - `state`: 현재 상태
    - `dispatch`: `action`을 받아 상태 값을 변경하고, **리렌더링을 트리거**하는 함수
- **주의할 점**
  - `reducer`는 반드시 **순수함수**여야 함
  - `reducer`는 일반적인 컨벤션에 따르면 `switch`문을 활용해 `action`을 분기함
  - `action`은 모든 자료형이 될 수 있지만, 일반적인 컨벤션은 객체임
    - action을 정의하는 `type` 프로퍼티 + 기타 프로퍼티로 이루어진 객체
  - 각 `action`은 단일 사용자 상호작용을 설명해야 함
    - 예를 들어 form에 있는 N개의 field를 reset해야 한다고 할 때, 각 field를 reset하는 N개의 action을 보내지 말고, 'reset_all'이라는 하나의 action을 보내라는 뜻
- **사용 예시**

  - 일반적인 간단한 예제

    ```jsx
    // ✅일반적인 간단한 예제
    function reducer(state, action) {
      switch (action.type) {
        case 'changed_name': {
          return {
            name: action.nextName,
          };
        }
        default: {
          throw Error('Unknown action: ' + action.type);
        }
      }
    }

    function NameField() {
      const [state, dispatch] = useReducer(reducer, { name: '' });

      const handleInputChange = (e) => {
        dispatch({
          type: 'changed_name',
          nextName: e.target.value,
        });
      };

      return <input value={state.name} onChange={handleInputChange} />;
    }
    ```

  - 이벤트 핸들러를 외부 reducer로 분리하여 코드 복잡성을 줄이고 접근성을 높인 예제

    ```jsx
    // ✅이벤트 핸들러를 외부 reducer로 분리한 예제
    // tasksReducer.js
    export default function tasksReducer(tasks, action) {
      switch (action.type) {
        case 'added': {
          return [
            ...tasks,
            {
              id: action.id,
              text: action.text,
              done: false,
            },
          ];
        }
        case 'changed': {
          return tasks.map((t) => {
            if (t.id === action.task.id) {
              return action.task;
            } else {
              return t;
            }
          });
        }
        case 'deleted': {
          return tasks.filter((t) => t.id !== action.id);
        }
        default: {
          throw Error('Unknown action: ' + action.type);
        }
      }
    }

    // TaskApp.js
    let nextId = 3;
    const initialTasks = [
      { id: 0, text: 'Visit Kafka Museum', done: true },
      { id: 1, text: 'Watch a puppet show', done: false },
      { id: 2, text: 'Lennon Wall pic', done: false },
    ];

    function TaskApp() {
      const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

      function handleAddTask(text) {
        dispatch({
          type: 'added',
          id: nextId++,
          text: text,
        });
      }

      function handleChangeTask(task) {
        dispatch({
          type: 'changed',
          task: task,
        });
      }

      function handleDeleteTask(taskId) {
        dispatch({
          type: 'deleted',
          id: taskId,
        });
      }

      return (
        <>
          <AddTask onAddTask={handleAddTask} />
          <TaskList
            tasks={tasks}
            onChangeTask={handleChangeTask}
            onDeleteTask={handleDeleteTask}
          />
        </>
      );
    }
    ```

  - 초간단 토글 구현 예제
    ```jsx
    // ✅토글 예제. useState를 사용한 토글보다 간략하고 편함
    const [value, toggleValue] = React.useReducer((prev) => !prev, true);
    <button onClick={toggleValue}>Toggle</button>;
    ```

### useState와 useReducer 비교

|  | useState | useReducer |
| --- | --- | --- |
| 코드 크기 | 적음 | 비교적 많음 |
| 상태 크기 | 간단한 상태 관리에 적합 | 복잡한 상태 관리에 적합 |
| 디버깅 | 왜, 어디서 state가 잘못 설정됐는지 찾기 어려움 | reducer에 직접 콘솔 로그를 삽입해 버그 발생 지점을 파악 가능 but 많은 코드를 단계별로 실행해야 하는 어려움 |
| 테스팅 |  | reducer가 순수하므로 독립적으로 분리하거나 테스팅하기 좋음 |

## 6. useMemo/useCallback

## 7. useRef
