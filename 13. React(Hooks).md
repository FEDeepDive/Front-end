## 1. hook이 뭔가요? 일반 함수랑 어떤 차이가 있나요?
Hooks는 재사용 가능한 UI 로직을 나타내는 JavaScript 함수이다. Hooks는 일반적인 JavaScript 함수이지만, 호출 가능한 곳(함수 컴포넌트나 커스텀 Hook의 최상위 레벨)이 제한되어있으며 함수 이름 맨 앞에 반드시 `use`라는 접두어가 붙어야 하는 특수한 유형의 함수이다. React의 여러 가지 기능을 함수 컴포넌트에서 사용할 수 있도록 해주는 내장 Hooks와 사용자가 직접 정의할 수 있는 커스텀 Hooks로 구분된다.

Hooks가 도입되기 전 함수 컴포넌트는 자체 상태를 가질 수 없었으며, 오직 `props`만을 이용해 UI를 표현할 수밖에 없었다. 클래스 컴포넌트는 함수 컴포넌트에 비해 상용구 코드나 제대로 동작하기 위해 해줘야 하는 작업이 많으며, 컴파일 시간에 각 메서드들이 어떻게 맞물려 동작하는지 알기 어렵기 때문에 빌드 시간에 최적화하기 힘들다는 단점이 있다. 또한 UI 로직을 재사용하기 위해 사용되던 고차 컴포넌트와 Render Props 패턴은 Wrapper 컴포넌트의 과도한 중첩을 불러 “Wrapper Hell”을 초래하는 경우가 많았다. 이러한 문제점을 해결하기 위해 Hooks가 도입되었다.

## 2. useState
`useState`는 컴포넌트에 `state` 변수를 추가할 수 있는 내장 Hook이다. 인자로는 초깃값 또는 초기화 함수를 받는다. 반환값은 길이가 2인 배열로, 첫 번째 값은 현재 `state` 변수이고 두 번째 값은 `state`를 다른 값으로 갱신하고 그에 반응하여 리렌더링을 일으키는 `set` 함수이다.

`state`를 직접 바꾸는 것은 React의 핵심 원리 중 하나인 불변성을 위반하는 것으로, 애플리케이션의 동작 예측과 디버깅을 어렵게 만든다. 또한 React는 `set` 함수의 호출에 반응하여 값의 변경을 감지하고 리렌더링을 일으키기 때문에 `state`를 직접 변경하는 것은 권장되지 않는다.

React에서는 여러 개의 `state` 갱신을 한 번의 리렌더링으로 그룹화하며, 이를 Batching(일괄 처리)이라고 한다. 이는 React의 `state` 갱신이 비동기적으로 이루어지기 때문에 가능하다. 클래스 컴포넌트의 `setState` 메서드나 `useState` hook의 setter 함수를 호출하여 `state` 갱신을 요청하면 처리를 위한 Queue에 enqueue되고, 우선순위에 따라 스케줄링되며, 컴포넌트의 불필요한 리렌더링을 최소화하도록 함께 갱신되어야 하는 `state`들을 일괄 처리하여 성능을 최적화한다.

## 3. useEffect/useLayoutEffect
### `useEffect`

`useEffect`는 React 컴포넌트를 외부 시스템과 동기화할 수 있게 해주는 내장 Hook이다. Effect란 특정 이벤트가 아닌 ‘렌더링 자체’에 의해 발생하는 부수 효과를 뜻하며, 화면이 갱신된 이후 실행된다. 이때가 React 컴포넌트를 외부 시스템과 동기화하기 좋은 타이밍이기 때문이다. 첫 번째 인자로는 Effect의 로직이 포함된 함수(`setup`)를 받으며, 두 번째 인자로는 일명 ‘의존성 배열(dependency array)’이라는 배열을 받는다. 의존성 배열에는 `setup`에서 사용되는 `props`, `state` 또는 컴포넌트 내에서 선언된 변수 및 함수(반응형 값)가 들어가야 한다. `setup`은 `cleanup` 함수를 반환할 수도 있는데 컴포넌트가 리렌더링되었을 때, 이전 렌더링에 사용된 값으로 `cleanup`을 실행한 후 새로운 값으로 `setup`을 실행한다. 컴포넌트가 DOM에서 제거되었을 경우에는 `cleanup`만이 실행된다.

의존성 배열은 각 요소의 이전 값과 현재 값을 비교하기 위해 `Object.is` 메서드를 사용한다. 때문에 객체나 배열, 함수 등을 의존성 배열에 제공할 때는 주의해야 한다. 객체나 배열의 경우, 프로퍼티 또는 요소의 추가/변경/삭제 등은 React가 변경을 감지할 수 없으며, 함수는 매 리렌더링마다 다시 생성되기 때문이다.

### `useLayoutEffect`

`useLayoutEffect`는 브라우저가 화면을 다시 그리기 전에, 즉 브라우저의 중요 렌더링 경로(CRP) 중 Repaint 과정 직전에 실행되는 내장 Hook이다. `useEffect`는 DOM이 화면에 그려지고 난 후에 호출되지만 `useLayoutEffect`는 DOM이 화면에 그려지기 전에 호출되기 때문에, DOM을 조작하는 코드가 있더라도 사용자가 flickering을 경험하지 않도록 할 수 있다.

React는 `useLayoutEffect` 내부 코드와 이로 인한 모든 `state` 갱신이 Repaint 직전에 처리되는 것을 보장하기 때문에, 해당 작업이 완료되기 전까지 브라우저가 화면을 다시 그리는 것을 막는다. 따라서 `useLayoutEffect` 내부 로직이 너무 복잡할 경우에는 사용자가 화면을 확인하기까지 시간이 오래 걸린다는 점을 주의해야 한다.

## 4. useContext
### Context

부모 컴포넌트에서 자식 컴포넌트로 정보를 전달할 때는 일반적으로 `props`를 통해 제공하지만, 중간에 많은 컴포넌트를 거쳐야 하거나 여러 컴포넌트가 동일한 정보를 필요로 할 경우 `props`를 사용하면 너무 코드가 장황해지고 사용하기 어려워진다. 특히 데이터를 소유하는 컴포넌트와 실제로 사용하는 컴포넌트 간의 거리가 멀어지는 경우를 `props drilling`이라고 한다. Context를 이용하면 하위 컴포넌트 트리 전체에 데이터를 제공할 수 있다.

- Context는 상태 관리 방식이라기보다, ‘의존성 주입’을 위한 도구로 이해하는 편이 더 올바르다.

### `createContext`

컴포넌트가 제공하거나 읽을 수 있는 Context 객체를 반환하는 함수이다. 컴포넌트에서 Context를 읽으려 할 때, 상위에 해당 Context 객체의 `Provider`가 없을 경우 사용하는 값인 `defaultValue`를 입력으로 받는다. 해당 함수가 반환하는 Context 객체는 그 자체로 값을 가지지 않으며, 해당 객체의 프로퍼티인 `Provider`에다 하위 컴포넌트에 전달할 값을 제공한 다음 `useContext` hook 또는 해당 객체의 또다른 프로퍼티인 `Consumer`를 통해 접근할 수 있다.

### `useContext`

`useContext` hook은 컴포넌트에서 Context 객체에 접근할 수 있도록 해주는 hook이다. Context를 입력으로 받아, `useContext`를 사용중인 컴포넌트 상위에 위치한 해당 Context 객체의 `Provider`에 제공된 값을 반환한다. 이 때, 반환되는 값은 컴포넌트 상위에서 가장 가까운 Context `Provider`에 제공된 값이다. 해당 `Provider`에 제공된 값이 바뀔 경우 해당 변경을 감지하여 `Provider` 아래의 모든 컴포넌트를 리렌더링한다.

## 5. useReducer
### Reducer

여러 개의 상태가 여러 가지의 이벤트 핸들러를 통해 변경되는 경우 코드가 매우 복잡해질 수 있는데, 상태를 변경시키는 로직을 컴포넌트 외부의 단일 함수로 분리해낼 수 있다. 이 때, 분리해낸 함수를 `reducer`라고 부른다. `reducer`는 이전 상태와 사용자가 취한 Action을 입력으로 받아, 다음 상태를 반환하는 함수이다.

함수형 프로그래밍에서 사용되는 개념 중 하나인 `reduce`는 여러 개의 값을 나타내는 자료 구조와 해당 자료구조의 각 요소에 적용할 함수 `reducer`를 입력으로 받아, 단일 값을 반환하는 고차 함수이다. 이러한 형태와 마찬가지로, (시간에 따라 생길) 여러 개의 상태 갱신과 각각의 상태 갱신 정보들에 대해 적용할 함수 `reducer`를 입력으로 받아서 단일한 다음 상태를 반환할 수 있기 때문에 이러한 이름이 붙었다.

### `useReducer`

`useReducer` hook은 `reducer` 함수, 초기 상태, (선택적으로) 초기 상태를 반환할 `init` 함수를 입력으로 받으며 컴포넌트에서 사용 가능한 `state` 객체와, `state`를 갱신하고 리렌더링을 일으키는 `dispatch` 함수를 반환한다.

`useReducer`를 사용하여 상태를 관리할 경우, 상태 변경 로직을 컴포넌트 외부로 분리할 수 있어 컴포넌트에 UI 형태를 정의하는 코드만을 작성할 수 있게 된다. 이를 통해 컴포넌트의 가독성을 높일 수 있으며, `reducer` 함수만 살펴보며 상태 변경 로직을 확인할 수 있고,  `reducer` 함수에 대한 테스트 코드만을 작성하여 상태 변경 로직을 검증할 수 있다.

- [reducer를 작성한 실제 예시](https://github.com/Kernel360/f1-Yigil/blob/develop/frontend/src/context/travel/spot/reducer.ts)
- [reducer 함수만을 테스트한 실제 예시](https://github.com/Kernel360/f1-Yigil/blob/develop/frontend/__tests__/SpotReducer.test.ts)

해당 코드에서 실제로 무언가를 렌더링하는 코드는 없으며, 덕분에 관심사의 분리를 달성할 수 있다.

## 6. useMemo/useCallback

## 7. useRef
