## 1. 함수 선언문, 함수 표현식, 화살표 함수의 차이에 대해 설명해주세요
### 함수 선언문
일반적인 프로그래밍 언어에서의 함수 선언과 비슷한 형식이다. 함수를 의미하는 예약어 `function`, 예약어와 식별자를 나누는 공백, 함수 이름이 될 식별자, 소괄호 한 쌍과 중괄호 한 쌍, 소괄호 안의 매개변수와 중괄호 안의 함수 본문으로 이루어져 있다.

```js
function add(num1, num2) {
  return num1 + num2;
}
```

### 함수 표현식
JavaScript에서 함수는 일급 객체이기 때문에, 변수에 할당할 수 있다. 함수 선언문과 비슷한 형식으로 사용할 수 있지만, 함수 이름이 될 식별자를 생략할 수 있다. 이 경우, 해당 함수는 익명 함수가 된다. 함수 이름을 생략하지 않는 경우, 함수 이름은 함수의 몸통 안에서만 사용할 수 있다.

```js
// 익명 함수를 만들고 변수에 할당한 경우
const abs = function (num1) {
  return num1 >= 0 ? num1 : -num1;
}

// 이름이 있는 함수를 변수에 할당한 경우
const foo = function factorial(n) {
  if (n === 0) {
    return 1;
  }

  return n * factorial(n - 1);
}

// 함수가 할당된 변수는 name 속성을 가지게 됨
// result: factorial
console.log(foo.name);
```

### 화살표 함수
ES6에서 처음 도입된 문법으로, 함수 표현식보다 간결한 문법으로 함수를 만드는 방법이다. 인자가 하나밖에 없는 경우 소괄호를 생략할 수도 있으며, 함수 본문이 한 줄인 경우 중괄호와 `return` 키워드를 생략할 수도 있다. 다만, 인자에 구조 분해 할당을 적용하여 하는 경우 소괄호를 생략할 수 없으며, 본문이 없는 함수인 경우 중괄호를 생략할 수 없다.

```js
const foo = () => {};

// IIFE 형태로 사용할 수도 있다
// result: 3
((..args) => console.log(args.length))(1, 2, 3);
```

### 각각의 차이
|  | 함수 선언문 | 함수 표현식 | 화살표 함수 |
| :-: | :-: | :-: | :-: |
| 자체 this | O | O | X |
| arguments | O | O | X |
| 호이스팅 | O | X | X |
| 마지막 세미콜론 | X | O | O |
| 익명 여부 | X | O | O |

## 2. 익명 함수(anonymous function)?
익명 함수는 이름을 가지지 않는 함수로, JavaScript에서는 함수 표현식과 화살표 함수를 통해 만들어질 수 있다. 한 번만 사용한 이후 필요가 없는 함수나, 별도의 이름을 붙이는 것보다 코드 본문을 노출하는 것이 더 이해하기 쉬운 경우에 주로 사용한다.

### `function f() {}` vs. `var f = function () {}`
함수 선언문을 통해 만들어진 함수는 익명 함수가 아니며, 호이스팅의 대상이 된다. 따라서 코드 상에서 함수가 선언되기 전에 호출될 수 있다. 그러나 함수 표현식 또는 화살표 함수를 통해 만들어진 함수는 익명 함수로, 호이스팅되지 않는다. 따라서 코드 상에서 함수가 선언되기 전에 호출될 수 없다.

## 3. 즉시 실행 함수 표현(IIFE, Immediately Invoked Function Expression)이란?
익명 함수를 소괄호로 감싼 후 별도의 소괄호 쌍을 붙여, 익명 함수를 선언하는 즉시 실행하는 표현식이다. IIFE를 사용하면 자신만의 고유한 스코프가 생기기 때문에 IIFE의 외부에서 내부의 식별자에 접근할 수 없으며, 전역 스코프를 깔끔하게 유지할 수 있다.

```js
// result: Hello John
(function (name) {
  console.log(`Hello ${name}!`)
})('John');

// IIFE를 활용하여 클로저를 만들 수도 있다
const result = (function () {
  const foo = 42;

  function bar() {
    return foo + 13;
  }

  return { foo, bar };
})();

// result: 42
console.log(result.foo);
// result: 55;
console.log(result.bar());
```

## 4. 콜백함수와 콜백 지옥에 대해 설명해주세요.
JavaScript에서는 함수를 ‘일급 객체’로 취급하기 때문에, 함수를 다른 함수의 인자로 제공할 수 있다. 이러한 함수를 ‘콜백 함수’라고 부르며, 특히 이러한 콜백 함수는 익명 함수의 형태로 자주 전달되는 것을 흔하게 볼 수 있다. 콜백 함수를 여러 겹 중첩하여 사용하게 될 경우, 일반적으로 인라인 형태로 작성되는 익명 함수의 특성 때문에 코드의 들여쓰기 수준이 감당하기 어려울 정도로 깊어지게 되는데, 이러한 현상을 ‘콜백 지옥’이라고 한다.

## 5. 순수함수와 비순수함수
### 부수 효과
부수 효과란, 함수의 실행이 인자의 값이나 함수의 외부 상태를 변화시키는 것을 의미한다.

### 순수 함수와 비순수 함수의 차이
|  | 순수 함수 | 비순수 함수 |
| :-: | :-: | :-: |
| 부수 효과 | 없음 | 있음 |
| 동일한 입력에 대해 | 동일한 출력 | 서로 다른 출력 |

순수 함수는 부수 효과가 없고 동일한 입력에 대해 동일한 출력을 보장하기 때문에, 그 동작을 추론하기 쉬워 단위 테스트를 작성하기 좋다는 특성이 있다. 또한 순수 함수는 동작하는 과정이나 내부 구조를 알 필요가 없이 반환한 값만을 생각하면 되기 때문에, 코드 레벨에서의 프로그램 분석이 쉬워진다는 장점 또한 존재한다.

### 참조 투명성(Referential Transparency)
어떠한 표현식을 프로그램의 동작을 변경하지 않고도 그 결과값으로 대체할 수 있는 경우, 이를 참조 투명성이라고 한다. 예를 들어, `2 + 3`라는 표현식은 어떤 경우에서든 문제없이 `5`라는 결과값으로 대체할 수 있다. 이를 확장하여, `Math.max(2, 3, 5, 7, 11)`이라는 함수는 어떤 경우에서든 문제없이 `11`이라는 결과값으로 대체할 수 있다. 모든 순수 함수는 참조 투명하기 때문에, 코드를 분석할 때 참조 투명성을 활용하여 프로그램의 동작을 수월하게 예측할 수 있게 된다.

## 6. 고차함수에 대해 설명해주세요.
고차 함수는 하나 이상의 함수를 입력으로 받거나 출력으로 반환하는 함수이다. 이러한 동작은 해당 프로그래밍 언어가 함수를 일급 객체로 취급하고 있기 때문에 가능하다.

## 7. 일급객체란?
어떠한 객체가 다음의 조건을 만족하는 경우, 해당 객체를 일급 객체라고 부른다.

1. 함수의 인자가 될 수 있다.
2. 함수의 반환값이 될 수 있다.
3. 할당 명령문의 대상이 될 수 있다.
4. 동일 비교의 대상이 될 수 있다.

이는 해당 객체를 다른 원시값을 다루듯 다룰 수 있다는 것을 의미한다. 예를 들어 함수를 일급 객체로 취급하는 언어의 경우, 함수를 배열의 요소나 객체의 프로퍼티로 저장할 수 있게 된다.