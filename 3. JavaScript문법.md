## 1. ES6에 추가된 문법
1. `let`, `const`
2. 템플릿 리터럴
3. 화살표 함수
4. `import`, `export`
5. `class`
6. 구조 분해 할당
7. 기본(default)/나머지(rest) 매개변수, 전개(spread) 구문
8. `map()`, `filter()`, `reduce()`, `forEach()` 등
9. `Promise`
10. `for … of`

## 2. `var`, `const`, `let`의 차이점
|  | var | const | let |
| --- | --- | --- | --- |
| 스코프 | 전역/함수 | 블록 | 블록 |
| 재할당 | 가능 | 불가능 | 가능 |
| 재선언 | 가능 | 불가능 | 불가능 |
| 할당 이전 접근 가능 | 가능 | 불가능 | 불가능 |
| 전역 객체에 프로퍼티 생성 | O | X | X |

## 3. `null`, `undefined`?
`undefined`는 변수에 값이 할당되지 않은 상태를 나타낼 때 사용한다. `var` 또는 `let`을 이용해 변수는 선언했으나 값을 할당하지 않았다면 해당 변수는 자동으로 `undefined`가 할당된다.

`null`은 개발자가 해당 변수에 ‘존재하지 않음’ 또는 ‘비어 있음’을 명시적으로 나타낼 때 사용한다.

## 4. `NaN`?
**N**ot **a** **N**umber의 줄임말로, JS뿐만 아니라 컴퓨터 연산 전반에서 나타나는 개념이며 잘못된 입력을 받았음을 나타내는 기호이다. `NaN`은 그 자신을 포함하여 그 어떤 값과도 같지 않게 취급되며, 비교 연산자의 피연산자로 쓰였을 때 항상 `false`를 반환한다.

JavaScript에서 `NaN`을 결과로 반환하는 연산은 총 5가지가 있다.

### 숫자 변환 실패

예시: `parseInt("숫자 아니지롱")`, `Math.floor(undefined)`

### 허수 결과를 가지는 수학 계산식

예시: `Math.sqrt(-1)`

### 정의할 수 없는 계산식

예시: `0 * Infinity`, `Infinity - Infinity`

### 피연산자가 `NaN`이거나, `NaN`으로 강제 변환되는 표현식 또는 함수

예시: `42 + NaN`, `13 * "Hello"`

### 유효하지 않은 값을 숫자로 표시해야 하는 경우

예시: `new Date("숫자 아니지롱").getTime()`

## 5. JS에서 세미콜론이 옵션인 이유에 대해 설명해주세요.
자바스크립트 엔진이 소스 코드를 해석할 때, statement의 끝으로 예측되는 지점에 세미콜론을 삽입해주는 기능인 ‘자동 세미콜론 삽입(Automatic semicolon insertion)’을 암묵적으로 수행하기 때문에, 사용자가 직접 세미콜론을 작성하지 않아도 된다고 한다. 그러나 자바스크립트 엔진이 프로그래머의 의도대로 코드를 해석하는 것에 실패할 위험이 있기 때문에, 명시적으로 세미콜론을 붙여주는 것을 권장하는 의견이 우세하다.

## 6. `Symbol`에 대해 설명해주세요.
ES6에서 새롭게 추가된 원시 타입으로, 그 값이 고유함이 보장된다. ES5 이전까지의 객체 프로퍼티 키는 문자열만을 사용했으며, 따라서 이미 존재하는 프로퍼티를 덮어쓰게 될 가능성이 있었다. ES6에서 `Symbol`이 추가되며, 객체의 프로퍼티 키를 고유하게 설정하여 충돌을 방지할 수 있게 되었다. 이렇게 생성된 프로퍼티 키는 일반적인 문자열 키와 달리 열거 불가능하다. 즉, `for ... in` 문법으로 접근할 수 없고,`Object.getOwnPropertyName()`으로 반환할 수 없으며, `JSON.stringify()`를 통해 객체를 JSON 문자열로 만들 때 무시된다.

JavaScript 엔진 내에 미리 생성되어 상수로 존재하는 내장 심볼들도 존재한다. 대표적으로 `Symbol.iterator`가 있는데, JavaScript 엔진은 `Symbol.iterator`를 키로 가지는 메소드가 정의된 객체를 iterable한 객체로 인식한다. 이러한 객체는 `for … of` 문법을 이용해 반복할 수 있다.

## 7. `==` 과 `===` 의 차이가 무엇인가요?

|  | `==` | `===` |
| --- | --- | --- |
| 명칭 | loose equality(느슨한 동등) | strict equality(엄격한 동등) |
| null vs. undefined | true | false |
| number vs. string | number == Number(string) | false |
| BigInt vs. string | StringToBigInt(x) == BigInt | false |
| boolean vs. number | Number(boolean) == number | false |
| … | … | … |

### 기억할 점
`===`를 사용할 경우, 두 값의 타입이 같지 않다면 항상 false이다. `==`를 사용할 경우, 두 값의 타입을 일치시키는 방향으로 어느 한 값을 변환한 다음 느슨한 동등 비교를 진행한다.

## 8. `for … of` / `for … in` 문
### `for ... in`

객체의 프로퍼티 키 중 문자열로 지정된 모든 열거 가능한 속성에 대해 반복문을 사용하는 문법이다. 해당 객체의 속성을 확인하기 위해 사용할 수 있다.

### `for ... of`

ES6에서 새롭게 등장한 문법으로, `Symbol.iterator`를 키로 가지는 모든 ‘컬렉션(Array, String, Map 등)’에 대해, 모든 원소를 한 번씩 추출하여 변수에 담아 반복문을 수행하는 식으로 동작한다.

## 9. `reduce` 사용법
`reduce(callbackFn, initialValue)`는 배열의 요소를 하나의 값으로 ‘줄이는’ 작업을 수행한다.

### `callbackFn(accumulator, currentValue, currentIndex, array)`

배열의 각 요소에 대해 실행할 함수이며, 콜백 함수의 이전 반환값을 `accumulator` 변수를 통해 접근 가능하다. `initialValue` 값이 존재할 경우 `accumulator`의 첫 값은 `initialValue` 값이고, 존재하지 않을 경우 배열의 첫 요소가 `accumulator` 값이 된다. 배열의 모든 요소에 대해 `callbackFn`이 실행된 후, 그 결과가 하나의 값으로 ‘줄어들어’ 반환된다.

## 10. `splice`, `slice` 차이
### `slice(begin, end)`

`slice()`는 문자열/배열에서 특정 범위만큼 복사한 값들을 담는 **새로운** 문자열/배열을 만들기 위해 사용한다. 새로운 변수를 만들기 때문에, 해당 문자열/배열을 조작한다고 하더라도 원본 문자열/배열에 영향을 미치지 않는다.

### `splice(start, deleteCount, ...items)`

`splice()`는 배열의 기존 요소를 삭제/교체하거나 새 요소를 추가하는 등 **배열의 내용을 변경**한다.

### `split(seperator)`

`split()`은 지정한 구분자를 이용하여 대상 문자열을 여러 개의 문자열로 나눈다.

## 11. 옵셔널 체이닝

## 12. NULL 병합 연산자(`??`)는 무엇인가요?

## 13. 단축평가

## 14. Promise

## 14-1. Promise란 무엇이며, async/await과 어떻게 다른지, 왜 async/await이 등장했는지?

## 14-2. Promise나 async/await를 es5로 트랜스파일하면 어떻게 되나요?

## 15. 클로저(Closure)란 무엇인가요?

## 16. 구조 분해 할당(Destructuring assignment)이란?

## 17. 전개 구문(Spread syntax)이란?

## 18. 나머지 매개변수(Rest parameters)란?

## 19. `use strict`가 무엇인가요? 장단점을 설명해주세요.

## 20. `apply`, `call`, `bind`의 차이는 무엇인가요?

## 20-1. `bind`를 `apply`, `call`로 어떻게 구현할 수 있을까요? 구현해보세요.
