## 1. 얕은 복사와 깊은 복사의 차이
🚨 일반적으로 모든 프로퍼티가 원시 타입인 객체는 중첩된 프로퍼티가 없기 때문에, 그러한 객체의 복사에 대해서는 이야기하지 않는다!

### 얕은 복사
두 객체 `o1`, `o2` 가 서로 같은 객체가 아니면서 다음의 특징을 만족하는 경우, 해당 두 객체는 얕은 복사다.

1. `o1` 과 `o2` 의 각 프로퍼티가 서로 같은 이름과 순서를 가진다.
2. 두 객체의 프로토타입 체인이 동일하다.
3. 두 객체의 각 프로퍼티에 대한 값이 동일하다.

```js
const obj = { a: 42, b: { c: 42, d: () => 'Hello' } };

// 여러 가지 복사 방법
const obj2 = { ...obj };
const obj3 = Object.assign({}, obj);

// result: false
console.log(obj === obj2);

// result: false
console.log(obj === obj3);

// result: true
console.log(obj.b === obj2.b);

// result: true
console.log(obj.b === obj3.b);
```

### 깊은 복사
두 객체가 얕은 복사 조건 1과 2를 만족하는 상황에서, 두 객체의 각 프로퍼티에 대한 값이 동일하지는 않으나 그 구조가 같은 경우, 해당 두 객체는 깊은 복사다.

```js
const obj = { a: 42, b: { c: 'Hello' } };

// structuredClone() 이전의 깊은 복사 방법
const obj2 = JSON.parse(JSON.stringify(obj));

// result: false
console.log(obj.b === obj2.b);
```

### `structuredClone()`
기존에 자주 사용되던 `JSON.stringify`  후 `JSON.parse` 하는 방법은 순환 참조가 존재하거나, `Map` /`Set` 등의 객체에 대한 깊은 복사를 수행할 수 없었다. `structuredClone()` 을 사용하면 이러한 객체들에 대해서도 깊은 복사를 수행할 수 있다. 그러나 함수 또는 `symbol` , DOM 객체 등은 애초에 직렬화가 불가능한 객체이며, 따라서 `structuredClone()` 으로도 이러한 객체들은 깊은 복사를 수행할 수 없다.

## 2. 문(statement)과 표현식(expression)의 차이
### 문

자바스크립트 프로그램은 연속된 문으로 이루어지며, 각 문은 컴퓨터가 프로그램을 실행하며 처리해야 하는 동작에 대한 명령이다. 문은 표현식과 키워드로 구성되며, 세미콜론으로 끝난다. 자바스크립트 코드를 작성할 때, 문을 통해 프로그램의 구조를 잡는다고 생각할 수 있다.

### 표현식
표현식은 하나의 값을 생성하는 자바스크립트 코드이며, 다른 표현식의 일부가 되어 더욱 복잡한 표현식을 구성할 수 있다. 리터럴 또한 값을 생성하기 때문에 표현식이고, 연산자와 리터럴을 통해 표현된 코드 또한 표현식이다.

어떠한 자바스크립트 코드가 문인지 표현식인지 알기 위해서는 함수의 인자로 제공해볼 수 있다. 함수의 인자는 항상 표현식이어야 하기 때문에, 문을 인자로 제공하는 경우 오류가 발생한다.

## 3. JavaScript Module System
### 모듈 시스템의 등장 배경
초기 자바스크립트는 웹 페이지에 약간의 상호작용성을 부여하기 위해 사용될 뿐이었기에 일반적으로 큰 스크립트가 필요하지 않았지만, 현대의 자바스크립트는 브라우저 환경에서 실행 가능한 하나의 거대한 애플리케이션이나 서버/커맨드라인 프로그램을 작성하는 데에도 사용하게 되었다. 일정 규모 이상이 되면 하나의 파일로 모든 코드를 관리할 수 없어지기 때문에 관련있는 코드들끼리 모아서 분리하고 필요한 것들만 가져올 수 있게 하는 기능이 필요해졌으며, 그렇게 모듈 시스템이 등장하게 되었다.

### CommonJS
자바스크립트를 단순 브라우저용이 아닌 범용 언어로 쓰일 수 있도록 하겠다는 목표를 가진 CommonJS 그룹이 정의하는 방식의 모듈 시스템이다. 다른 모듈을 사용하기 위해서는 `require()` 문을, 외부에 공개하기 위해서는 `module.exports` 라는 속성을 사용한다. 동기 방식으로 작동하기 때문에, 모든 코드가 이미 로컬에 존재하는 서버 측에서 사용하기 편하다는 특징을 가지고 있다.

### ESM(ES Module)
자바스크립트는 ES6에서 공식적으로 문법 수준 모듈 시스템이 도입되었으며, 이를 ESM이라고 부른다. 다른 모듈을 사용하기 위해 `import` 문을, 외부에 공개하기 위해 `export` 문을 사용한다. CommonJS와 달리 각 모듈을 비동기적으로 가져오기 때문에, 브라우저에서도 사용하기 좋다는 특징이 있다.

### CommonJS vs. ES Module
CommonJS 방식은 가져오기와 내보내기가 동적으로 이루어질 수 있는 구조였으며, 때문에 실행 시간에만 모듈 관계를 파악할 수 있어 빌드 단계에 정적 분석을 적용하기 어렵다는 문제가 있었다. ESM에서는 정적인 구조로 모듈끼리 의존하도록 구성하여, 빌드 단계에서 정적 분석을 통해 모듈 간의 의존 관계를 파악할 수 있다.

### Dynamic import
ESM을 사용하는 경우, 일반적으로는 정적 import를 사용하면 되겠지만 모듈을 동적으로 불러와야 하는 경우가 생길 경우, `import(modulePath)`  **표현식**을 이용할 수 있다. 해당 표현식은 모듈이 내보내는 것들을 모두 포함하는 객체를 담은 Promise를 반환한다.

## 4. node.js와 그냥 js의 차이
Node.js는 Google Chrome을 만들기 위한 프로젝트인 Chromium Project에서 개발된 자바스크립트 엔진 V8에서 동작하는 자바스크립트 런타임 환경이다. 자바스크립트는 일반적으로 웹 브라우저에 내장되어 동적 웹페이지를 생성하는 데에 쓰이지만, Node.js를 통해 자바스크립트를 서버 측 스크립팅은 물론 커맨드라인 도구를 작성하는 데에 사용할 수 있게 되었다.

## 5. iterable, iterator, 유사 배열 객체

## 6. generator

## 7. polyfill이란 무엇인가요?
